
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model answer_keys
 * 
 */
export type answer_keys = $Result.DefaultSelection<Prisma.$answer_keysPayload>
/**
 * Model categories
 * 
 */
export type categories = $Result.DefaultSelection<Prisma.$categoriesPayload>
/**
 * Model comments
 * 
 */
export type comments = $Result.DefaultSelection<Prisma.$commentsPayload>
/**
 * Model course_plans
 * 
 */
export type course_plans = $Result.DefaultSelection<Prisma.$course_plansPayload>
/**
 * Model course_reviews
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type course_reviews = $Result.DefaultSelection<Prisma.$course_reviewsPayload>
/**
 * Model course_videos
 * 
 */
export type course_videos = $Result.DefaultSelection<Prisma.$course_videosPayload>
/**
 * Model courses
 * 
 */
export type courses = $Result.DefaultSelection<Prisma.$coursesPayload>
/**
 * Model enrollments
 * 
 */
export type enrollments = $Result.DefaultSelection<Prisma.$enrollmentsPayload>
/**
 * Model google_ads
 * 
 */
export type google_ads = $Result.DefaultSelection<Prisma.$google_adsPayload>
/**
 * Model mock_attempts
 * 
 */
export type mock_attempts = $Result.DefaultSelection<Prisma.$mock_attemptsPayload>
/**
 * Model mock_categories
 * 
 */
export type mock_categories = $Result.DefaultSelection<Prisma.$mock_categoriesPayload>
/**
 * Model mock_questions
 * 
 */
export type mock_questions = $Result.DefaultSelection<Prisma.$mock_questionsPayload>
/**
 * Model mock_series
 * 
 */
export type mock_series = $Result.DefaultSelection<Prisma.$mock_seriesPayload>
/**
 * Model mock_tests
 * 
 */
export type mock_tests = $Result.DefaultSelection<Prisma.$mock_testsPayload>
/**
 * Model payments
 * 
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>
/**
 * Model post_tags
 * 
 */
export type post_tags = $Result.DefaultSelection<Prisma.$post_tagsPayload>
/**
 * Model post_templates
 * 
 */
export type post_templates = $Result.DefaultSelection<Prisma.$post_templatesPayload>
/**
 * Model posts
 * 
 */
export type posts = $Result.DefaultSelection<Prisma.$postsPayload>
/**
 * Model study_materials
 * 
 */
export type study_materials = $Result.DefaultSelection<Prisma.$study_materialsPayload>
/**
 * Model tags
 * 
 */
export type tags = $Result.DefaultSelection<Prisma.$tagsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const enrollment_status: {
  active: 'active',
  expired: 'expired',
  cancelled: 'cancelled'
};

export type enrollment_status = (typeof enrollment_status)[keyof typeof enrollment_status]


export const payment_status: {
  pending: 'pending',
  success: 'success',
  failed: 'failed'
};

export type payment_status = (typeof payment_status)[keyof typeof payment_status]


export const plan_type: {
  free: 'free',
  one_time: 'one_time',
  subscription: 'subscription'
};

export type plan_type = (typeof plan_type)[keyof typeof plan_type]


export const question_type: {
  mcq: 'mcq',
  true_false: 'true_false',
  fill_blank: 'fill_blank'
};

export type question_type = (typeof question_type)[keyof typeof question_type]


export const user_role: {
  admin: 'admin',
  student: 'student'
};

export type user_role = (typeof user_role)[keyof typeof user_role]

}

export type enrollment_status = $Enums.enrollment_status

export const enrollment_status: typeof $Enums.enrollment_status

export type payment_status = $Enums.payment_status

export const payment_status: typeof $Enums.payment_status

export type plan_type = $Enums.plan_type

export const plan_type: typeof $Enums.plan_type

export type question_type = $Enums.question_type

export const question_type: typeof $Enums.question_type

export type user_role = $Enums.user_role

export const user_role: typeof $Enums.user_role

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Answer_keys
 * const answer_keys = await prisma.answer_keys.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Answer_keys
   * const answer_keys = await prisma.answer_keys.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.answer_keys`: Exposes CRUD operations for the **answer_keys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answer_keys
    * const answer_keys = await prisma.answer_keys.findMany()
    * ```
    */
  get answer_keys(): Prisma.answer_keysDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categories`: Exposes CRUD operations for the **categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comments`: Exposes CRUD operations for the **comments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comments.findMany()
    * ```
    */
  get comments(): Prisma.commentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course_plans`: Exposes CRUD operations for the **course_plans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Course_plans
    * const course_plans = await prisma.course_plans.findMany()
    * ```
    */
  get course_plans(): Prisma.course_plansDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course_reviews`: Exposes CRUD operations for the **course_reviews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Course_reviews
    * const course_reviews = await prisma.course_reviews.findMany()
    * ```
    */
  get course_reviews(): Prisma.course_reviewsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.course_videos`: Exposes CRUD operations for the **course_videos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Course_videos
    * const course_videos = await prisma.course_videos.findMany()
    * ```
    */
  get course_videos(): Prisma.course_videosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.courses`: Exposes CRUD operations for the **courses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.courses.findMany()
    * ```
    */
  get courses(): Prisma.coursesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.enrollments`: Exposes CRUD operations for the **enrollments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Enrollments
    * const enrollments = await prisma.enrollments.findMany()
    * ```
    */
  get enrollments(): Prisma.enrollmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.google_ads`: Exposes CRUD operations for the **google_ads** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Google_ads
    * const google_ads = await prisma.google_ads.findMany()
    * ```
    */
  get google_ads(): Prisma.google_adsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mock_attempts`: Exposes CRUD operations for the **mock_attempts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mock_attempts
    * const mock_attempts = await prisma.mock_attempts.findMany()
    * ```
    */
  get mock_attempts(): Prisma.mock_attemptsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mock_categories`: Exposes CRUD operations for the **mock_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mock_categories
    * const mock_categories = await prisma.mock_categories.findMany()
    * ```
    */
  get mock_categories(): Prisma.mock_categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mock_questions`: Exposes CRUD operations for the **mock_questions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mock_questions
    * const mock_questions = await prisma.mock_questions.findMany()
    * ```
    */
  get mock_questions(): Prisma.mock_questionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mock_series`: Exposes CRUD operations for the **mock_series** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mock_series
    * const mock_series = await prisma.mock_series.findMany()
    * ```
    */
  get mock_series(): Prisma.mock_seriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mock_tests`: Exposes CRUD operations for the **mock_tests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mock_tests
    * const mock_tests = await prisma.mock_tests.findMany()
    * ```
    */
  get mock_tests(): Prisma.mock_testsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post_tags`: Exposes CRUD operations for the **post_tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Post_tags
    * const post_tags = await prisma.post_tags.findMany()
    * ```
    */
  get post_tags(): Prisma.post_tagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post_templates`: Exposes CRUD operations for the **post_templates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Post_templates
    * const post_templates = await prisma.post_templates.findMany()
    * ```
    */
  get post_templates(): Prisma.post_templatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.posts`: Exposes CRUD operations for the **posts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.posts.findMany()
    * ```
    */
  get posts(): Prisma.postsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.study_materials`: Exposes CRUD operations for the **study_materials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Study_materials
    * const study_materials = await prisma.study_materials.findMany()
    * ```
    */
  get study_materials(): Prisma.study_materialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tags`: Exposes CRUD operations for the **tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tags.findMany()
    * ```
    */
  get tags(): Prisma.tagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.1
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    answer_keys: 'answer_keys',
    categories: 'categories',
    comments: 'comments',
    course_plans: 'course_plans',
    course_reviews: 'course_reviews',
    course_videos: 'course_videos',
    courses: 'courses',
    enrollments: 'enrollments',
    google_ads: 'google_ads',
    mock_attempts: 'mock_attempts',
    mock_categories: 'mock_categories',
    mock_questions: 'mock_questions',
    mock_series: 'mock_series',
    mock_tests: 'mock_tests',
    payments: 'payments',
    post_tags: 'post_tags',
    post_templates: 'post_templates',
    posts: 'posts',
    study_materials: 'study_materials',
    tags: 'tags',
    users: 'users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "answer_keys" | "categories" | "comments" | "course_plans" | "course_reviews" | "course_videos" | "courses" | "enrollments" | "google_ads" | "mock_attempts" | "mock_categories" | "mock_questions" | "mock_series" | "mock_tests" | "payments" | "post_tags" | "post_templates" | "posts" | "study_materials" | "tags" | "users"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      answer_keys: {
        payload: Prisma.$answer_keysPayload<ExtArgs>
        fields: Prisma.answer_keysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.answer_keysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answer_keysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.answer_keysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answer_keysPayload>
          }
          findFirst: {
            args: Prisma.answer_keysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answer_keysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.answer_keysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answer_keysPayload>
          }
          findMany: {
            args: Prisma.answer_keysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answer_keysPayload>[]
          }
          create: {
            args: Prisma.answer_keysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answer_keysPayload>
          }
          createMany: {
            args: Prisma.answer_keysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.answer_keysCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answer_keysPayload>[]
          }
          delete: {
            args: Prisma.answer_keysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answer_keysPayload>
          }
          update: {
            args: Prisma.answer_keysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answer_keysPayload>
          }
          deleteMany: {
            args: Prisma.answer_keysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.answer_keysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.answer_keysUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answer_keysPayload>[]
          }
          upsert: {
            args: Prisma.answer_keysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answer_keysPayload>
          }
          aggregate: {
            args: Prisma.Answer_keysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnswer_keys>
          }
          groupBy: {
            args: Prisma.answer_keysGroupByArgs<ExtArgs>
            result: $Utils.Optional<Answer_keysGroupByOutputType>[]
          }
          count: {
            args: Prisma.answer_keysCountArgs<ExtArgs>
            result: $Utils.Optional<Answer_keysCountAggregateOutputType> | number
          }
        }
      }
      categories: {
        payload: Prisma.$categoriesPayload<ExtArgs>
        fields: Prisma.categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findFirst: {
            args: Prisma.categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findMany: {
            args: Prisma.categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          create: {
            args: Prisma.categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          createMany: {
            args: Prisma.categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          delete: {
            args: Prisma.categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          update: {
            args: Prisma.categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          deleteMany: {
            args: Prisma.categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.categoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          upsert: {
            args: Prisma.categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          aggregate: {
            args: Prisma.CategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategories>
          }
          groupBy: {
            args: Prisma.categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriesCountAggregateOutputType> | number
          }
        }
      }
      comments: {
        payload: Prisma.$commentsPayload<ExtArgs>
        fields: Prisma.commentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.commentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.commentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          findFirst: {
            args: Prisma.commentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.commentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          findMany: {
            args: Prisma.commentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]
          }
          create: {
            args: Prisma.commentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          createMany: {
            args: Prisma.commentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.commentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]
          }
          delete: {
            args: Prisma.commentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          update: {
            args: Prisma.commentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          deleteMany: {
            args: Prisma.commentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.commentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.commentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>[]
          }
          upsert: {
            args: Prisma.commentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentsPayload>
          }
          aggregate: {
            args: Prisma.CommentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComments>
          }
          groupBy: {
            args: Prisma.commentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.commentsCountArgs<ExtArgs>
            result: $Utils.Optional<CommentsCountAggregateOutputType> | number
          }
        }
      }
      course_plans: {
        payload: Prisma.$course_plansPayload<ExtArgs>
        fields: Prisma.course_plansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.course_plansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_plansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.course_plansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_plansPayload>
          }
          findFirst: {
            args: Prisma.course_plansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_plansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.course_plansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_plansPayload>
          }
          findMany: {
            args: Prisma.course_plansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_plansPayload>[]
          }
          create: {
            args: Prisma.course_plansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_plansPayload>
          }
          createMany: {
            args: Prisma.course_plansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.course_plansCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_plansPayload>[]
          }
          delete: {
            args: Prisma.course_plansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_plansPayload>
          }
          update: {
            args: Prisma.course_plansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_plansPayload>
          }
          deleteMany: {
            args: Prisma.course_plansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.course_plansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.course_plansUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_plansPayload>[]
          }
          upsert: {
            args: Prisma.course_plansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_plansPayload>
          }
          aggregate: {
            args: Prisma.Course_plansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse_plans>
          }
          groupBy: {
            args: Prisma.course_plansGroupByArgs<ExtArgs>
            result: $Utils.Optional<Course_plansGroupByOutputType>[]
          }
          count: {
            args: Prisma.course_plansCountArgs<ExtArgs>
            result: $Utils.Optional<Course_plansCountAggregateOutputType> | number
          }
        }
      }
      course_reviews: {
        payload: Prisma.$course_reviewsPayload<ExtArgs>
        fields: Prisma.course_reviewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.course_reviewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_reviewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.course_reviewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_reviewsPayload>
          }
          findFirst: {
            args: Prisma.course_reviewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_reviewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.course_reviewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_reviewsPayload>
          }
          findMany: {
            args: Prisma.course_reviewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_reviewsPayload>[]
          }
          create: {
            args: Prisma.course_reviewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_reviewsPayload>
          }
          createMany: {
            args: Prisma.course_reviewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.course_reviewsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_reviewsPayload>[]
          }
          delete: {
            args: Prisma.course_reviewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_reviewsPayload>
          }
          update: {
            args: Prisma.course_reviewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_reviewsPayload>
          }
          deleteMany: {
            args: Prisma.course_reviewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.course_reviewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.course_reviewsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_reviewsPayload>[]
          }
          upsert: {
            args: Prisma.course_reviewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_reviewsPayload>
          }
          aggregate: {
            args: Prisma.Course_reviewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse_reviews>
          }
          groupBy: {
            args: Prisma.course_reviewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Course_reviewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.course_reviewsCountArgs<ExtArgs>
            result: $Utils.Optional<Course_reviewsCountAggregateOutputType> | number
          }
        }
      }
      course_videos: {
        payload: Prisma.$course_videosPayload<ExtArgs>
        fields: Prisma.course_videosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.course_videosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_videosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.course_videosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_videosPayload>
          }
          findFirst: {
            args: Prisma.course_videosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_videosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.course_videosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_videosPayload>
          }
          findMany: {
            args: Prisma.course_videosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_videosPayload>[]
          }
          create: {
            args: Prisma.course_videosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_videosPayload>
          }
          createMany: {
            args: Prisma.course_videosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.course_videosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_videosPayload>[]
          }
          delete: {
            args: Prisma.course_videosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_videosPayload>
          }
          update: {
            args: Prisma.course_videosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_videosPayload>
          }
          deleteMany: {
            args: Prisma.course_videosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.course_videosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.course_videosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_videosPayload>[]
          }
          upsert: {
            args: Prisma.course_videosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$course_videosPayload>
          }
          aggregate: {
            args: Prisma.Course_videosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse_videos>
          }
          groupBy: {
            args: Prisma.course_videosGroupByArgs<ExtArgs>
            result: $Utils.Optional<Course_videosGroupByOutputType>[]
          }
          count: {
            args: Prisma.course_videosCountArgs<ExtArgs>
            result: $Utils.Optional<Course_videosCountAggregateOutputType> | number
          }
        }
      }
      courses: {
        payload: Prisma.$coursesPayload<ExtArgs>
        fields: Prisma.coursesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.coursesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.coursesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          findFirst: {
            args: Prisma.coursesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.coursesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          findMany: {
            args: Prisma.coursesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>[]
          }
          create: {
            args: Prisma.coursesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          createMany: {
            args: Prisma.coursesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.coursesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>[]
          }
          delete: {
            args: Prisma.coursesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          update: {
            args: Prisma.coursesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          deleteMany: {
            args: Prisma.coursesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.coursesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.coursesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>[]
          }
          upsert: {
            args: Prisma.coursesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$coursesPayload>
          }
          aggregate: {
            args: Prisma.CoursesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourses>
          }
          groupBy: {
            args: Prisma.coursesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoursesGroupByOutputType>[]
          }
          count: {
            args: Prisma.coursesCountArgs<ExtArgs>
            result: $Utils.Optional<CoursesCountAggregateOutputType> | number
          }
        }
      }
      enrollments: {
        payload: Prisma.$enrollmentsPayload<ExtArgs>
        fields: Prisma.enrollmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.enrollmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.enrollmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          findFirst: {
            args: Prisma.enrollmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.enrollmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          findMany: {
            args: Prisma.enrollmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>[]
          }
          create: {
            args: Prisma.enrollmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          createMany: {
            args: Prisma.enrollmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.enrollmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>[]
          }
          delete: {
            args: Prisma.enrollmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          update: {
            args: Prisma.enrollmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          deleteMany: {
            args: Prisma.enrollmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.enrollmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.enrollmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>[]
          }
          upsert: {
            args: Prisma.enrollmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$enrollmentsPayload>
          }
          aggregate: {
            args: Prisma.EnrollmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEnrollments>
          }
          groupBy: {
            args: Prisma.enrollmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.enrollmentsCountArgs<ExtArgs>
            result: $Utils.Optional<EnrollmentsCountAggregateOutputType> | number
          }
        }
      }
      google_ads: {
        payload: Prisma.$google_adsPayload<ExtArgs>
        fields: Prisma.google_adsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.google_adsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$google_adsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.google_adsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$google_adsPayload>
          }
          findFirst: {
            args: Prisma.google_adsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$google_adsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.google_adsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$google_adsPayload>
          }
          findMany: {
            args: Prisma.google_adsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$google_adsPayload>[]
          }
          create: {
            args: Prisma.google_adsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$google_adsPayload>
          }
          createMany: {
            args: Prisma.google_adsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.google_adsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$google_adsPayload>[]
          }
          delete: {
            args: Prisma.google_adsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$google_adsPayload>
          }
          update: {
            args: Prisma.google_adsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$google_adsPayload>
          }
          deleteMany: {
            args: Prisma.google_adsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.google_adsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.google_adsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$google_adsPayload>[]
          }
          upsert: {
            args: Prisma.google_adsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$google_adsPayload>
          }
          aggregate: {
            args: Prisma.Google_adsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoogle_ads>
          }
          groupBy: {
            args: Prisma.google_adsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Google_adsGroupByOutputType>[]
          }
          count: {
            args: Prisma.google_adsCountArgs<ExtArgs>
            result: $Utils.Optional<Google_adsCountAggregateOutputType> | number
          }
        }
      }
      mock_attempts: {
        payload: Prisma.$mock_attemptsPayload<ExtArgs>
        fields: Prisma.mock_attemptsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mock_attemptsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_attemptsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mock_attemptsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_attemptsPayload>
          }
          findFirst: {
            args: Prisma.mock_attemptsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_attemptsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mock_attemptsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_attemptsPayload>
          }
          findMany: {
            args: Prisma.mock_attemptsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_attemptsPayload>[]
          }
          create: {
            args: Prisma.mock_attemptsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_attemptsPayload>
          }
          createMany: {
            args: Prisma.mock_attemptsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mock_attemptsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_attemptsPayload>[]
          }
          delete: {
            args: Prisma.mock_attemptsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_attemptsPayload>
          }
          update: {
            args: Prisma.mock_attemptsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_attemptsPayload>
          }
          deleteMany: {
            args: Prisma.mock_attemptsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mock_attemptsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mock_attemptsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_attemptsPayload>[]
          }
          upsert: {
            args: Prisma.mock_attemptsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_attemptsPayload>
          }
          aggregate: {
            args: Prisma.Mock_attemptsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMock_attempts>
          }
          groupBy: {
            args: Prisma.mock_attemptsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mock_attemptsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mock_attemptsCountArgs<ExtArgs>
            result: $Utils.Optional<Mock_attemptsCountAggregateOutputType> | number
          }
        }
      }
      mock_categories: {
        payload: Prisma.$mock_categoriesPayload<ExtArgs>
        fields: Prisma.mock_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mock_categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mock_categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_categoriesPayload>
          }
          findFirst: {
            args: Prisma.mock_categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mock_categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_categoriesPayload>
          }
          findMany: {
            args: Prisma.mock_categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_categoriesPayload>[]
          }
          create: {
            args: Prisma.mock_categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_categoriesPayload>
          }
          createMany: {
            args: Prisma.mock_categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mock_categoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_categoriesPayload>[]
          }
          delete: {
            args: Prisma.mock_categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_categoriesPayload>
          }
          update: {
            args: Prisma.mock_categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.mock_categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mock_categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mock_categoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_categoriesPayload>[]
          }
          upsert: {
            args: Prisma.mock_categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Mock_categoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMock_categories>
          }
          groupBy: {
            args: Prisma.mock_categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mock_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.mock_categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<Mock_categoriesCountAggregateOutputType> | number
          }
        }
      }
      mock_questions: {
        payload: Prisma.$mock_questionsPayload<ExtArgs>
        fields: Prisma.mock_questionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mock_questionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_questionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mock_questionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_questionsPayload>
          }
          findFirst: {
            args: Prisma.mock_questionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_questionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mock_questionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_questionsPayload>
          }
          findMany: {
            args: Prisma.mock_questionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_questionsPayload>[]
          }
          create: {
            args: Prisma.mock_questionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_questionsPayload>
          }
          createMany: {
            args: Prisma.mock_questionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mock_questionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_questionsPayload>[]
          }
          delete: {
            args: Prisma.mock_questionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_questionsPayload>
          }
          update: {
            args: Prisma.mock_questionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_questionsPayload>
          }
          deleteMany: {
            args: Prisma.mock_questionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mock_questionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mock_questionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_questionsPayload>[]
          }
          upsert: {
            args: Prisma.mock_questionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_questionsPayload>
          }
          aggregate: {
            args: Prisma.Mock_questionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMock_questions>
          }
          groupBy: {
            args: Prisma.mock_questionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mock_questionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mock_questionsCountArgs<ExtArgs>
            result: $Utils.Optional<Mock_questionsCountAggregateOutputType> | number
          }
        }
      }
      mock_series: {
        payload: Prisma.$mock_seriesPayload<ExtArgs>
        fields: Prisma.mock_seriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mock_seriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_seriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mock_seriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_seriesPayload>
          }
          findFirst: {
            args: Prisma.mock_seriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_seriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mock_seriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_seriesPayload>
          }
          findMany: {
            args: Prisma.mock_seriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_seriesPayload>[]
          }
          create: {
            args: Prisma.mock_seriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_seriesPayload>
          }
          createMany: {
            args: Prisma.mock_seriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mock_seriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_seriesPayload>[]
          }
          delete: {
            args: Prisma.mock_seriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_seriesPayload>
          }
          update: {
            args: Prisma.mock_seriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_seriesPayload>
          }
          deleteMany: {
            args: Prisma.mock_seriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mock_seriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mock_seriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_seriesPayload>[]
          }
          upsert: {
            args: Prisma.mock_seriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_seriesPayload>
          }
          aggregate: {
            args: Prisma.Mock_seriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMock_series>
          }
          groupBy: {
            args: Prisma.mock_seriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mock_seriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.mock_seriesCountArgs<ExtArgs>
            result: $Utils.Optional<Mock_seriesCountAggregateOutputType> | number
          }
        }
      }
      mock_tests: {
        payload: Prisma.$mock_testsPayload<ExtArgs>
        fields: Prisma.mock_testsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mock_testsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_testsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mock_testsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_testsPayload>
          }
          findFirst: {
            args: Prisma.mock_testsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_testsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mock_testsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_testsPayload>
          }
          findMany: {
            args: Prisma.mock_testsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_testsPayload>[]
          }
          create: {
            args: Prisma.mock_testsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_testsPayload>
          }
          createMany: {
            args: Prisma.mock_testsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mock_testsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_testsPayload>[]
          }
          delete: {
            args: Prisma.mock_testsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_testsPayload>
          }
          update: {
            args: Prisma.mock_testsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_testsPayload>
          }
          deleteMany: {
            args: Prisma.mock_testsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mock_testsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mock_testsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_testsPayload>[]
          }
          upsert: {
            args: Prisma.mock_testsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mock_testsPayload>
          }
          aggregate: {
            args: Prisma.Mock_testsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMock_tests>
          }
          groupBy: {
            args: Prisma.mock_testsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mock_testsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mock_testsCountArgs<ExtArgs>
            result: $Utils.Optional<Mock_testsCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      post_tags: {
        payload: Prisma.$post_tagsPayload<ExtArgs>
        fields: Prisma.post_tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.post_tagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.post_tagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_tagsPayload>
          }
          findFirst: {
            args: Prisma.post_tagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.post_tagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_tagsPayload>
          }
          findMany: {
            args: Prisma.post_tagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_tagsPayload>[]
          }
          create: {
            args: Prisma.post_tagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_tagsPayload>
          }
          createMany: {
            args: Prisma.post_tagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.post_tagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_tagsPayload>[]
          }
          delete: {
            args: Prisma.post_tagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_tagsPayload>
          }
          update: {
            args: Prisma.post_tagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_tagsPayload>
          }
          deleteMany: {
            args: Prisma.post_tagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.post_tagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.post_tagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_tagsPayload>[]
          }
          upsert: {
            args: Prisma.post_tagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_tagsPayload>
          }
          aggregate: {
            args: Prisma.Post_tagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost_tags>
          }
          groupBy: {
            args: Prisma.post_tagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Post_tagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.post_tagsCountArgs<ExtArgs>
            result: $Utils.Optional<Post_tagsCountAggregateOutputType> | number
          }
        }
      }
      post_templates: {
        payload: Prisma.$post_templatesPayload<ExtArgs>
        fields: Prisma.post_templatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.post_templatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_templatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.post_templatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_templatesPayload>
          }
          findFirst: {
            args: Prisma.post_templatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_templatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.post_templatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_templatesPayload>
          }
          findMany: {
            args: Prisma.post_templatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_templatesPayload>[]
          }
          create: {
            args: Prisma.post_templatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_templatesPayload>
          }
          createMany: {
            args: Prisma.post_templatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.post_templatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_templatesPayload>[]
          }
          delete: {
            args: Prisma.post_templatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_templatesPayload>
          }
          update: {
            args: Prisma.post_templatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_templatesPayload>
          }
          deleteMany: {
            args: Prisma.post_templatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.post_templatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.post_templatesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_templatesPayload>[]
          }
          upsert: {
            args: Prisma.post_templatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_templatesPayload>
          }
          aggregate: {
            args: Prisma.Post_templatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost_templates>
          }
          groupBy: {
            args: Prisma.post_templatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Post_templatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.post_templatesCountArgs<ExtArgs>
            result: $Utils.Optional<Post_templatesCountAggregateOutputType> | number
          }
        }
      }
      posts: {
        payload: Prisma.$postsPayload<ExtArgs>
        fields: Prisma.postsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.postsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.postsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          findFirst: {
            args: Prisma.postsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.postsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          findMany: {
            args: Prisma.postsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload>[]
          }
          create: {
            args: Prisma.postsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          createMany: {
            args: Prisma.postsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.postsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload>[]
          }
          delete: {
            args: Prisma.postsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          update: {
            args: Prisma.postsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          deleteMany: {
            args: Prisma.postsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.postsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.postsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload>[]
          }
          upsert: {
            args: Prisma.postsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postsPayload>
          }
          aggregate: {
            args: Prisma.PostsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePosts>
          }
          groupBy: {
            args: Prisma.postsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostsGroupByOutputType>[]
          }
          count: {
            args: Prisma.postsCountArgs<ExtArgs>
            result: $Utils.Optional<PostsCountAggregateOutputType> | number
          }
        }
      }
      study_materials: {
        payload: Prisma.$study_materialsPayload<ExtArgs>
        fields: Prisma.study_materialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.study_materialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_materialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.study_materialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_materialsPayload>
          }
          findFirst: {
            args: Prisma.study_materialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_materialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.study_materialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_materialsPayload>
          }
          findMany: {
            args: Prisma.study_materialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_materialsPayload>[]
          }
          create: {
            args: Prisma.study_materialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_materialsPayload>
          }
          createMany: {
            args: Prisma.study_materialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.study_materialsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_materialsPayload>[]
          }
          delete: {
            args: Prisma.study_materialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_materialsPayload>
          }
          update: {
            args: Prisma.study_materialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_materialsPayload>
          }
          deleteMany: {
            args: Prisma.study_materialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.study_materialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.study_materialsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_materialsPayload>[]
          }
          upsert: {
            args: Prisma.study_materialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$study_materialsPayload>
          }
          aggregate: {
            args: Prisma.Study_materialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudy_materials>
          }
          groupBy: {
            args: Prisma.study_materialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Study_materialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.study_materialsCountArgs<ExtArgs>
            result: $Utils.Optional<Study_materialsCountAggregateOutputType> | number
          }
        }
      }
      tags: {
        payload: Prisma.$tagsPayload<ExtArgs>
        fields: Prisma.tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          findFirst: {
            args: Prisma.tagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          findMany: {
            args: Prisma.tagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>[]
          }
          create: {
            args: Prisma.tagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          createMany: {
            args: Prisma.tagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>[]
          }
          delete: {
            args: Prisma.tagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          update: {
            args: Prisma.tagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          deleteMany: {
            args: Prisma.tagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>[]
          }
          upsert: {
            args: Prisma.tagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          aggregate: {
            args: Prisma.TagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTags>
          }
          groupBy: {
            args: Prisma.tagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tagsCountArgs<ExtArgs>
            result: $Utils.Optional<TagsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    answer_keys?: answer_keysOmit
    categories?: categoriesOmit
    comments?: commentsOmit
    course_plans?: course_plansOmit
    course_reviews?: course_reviewsOmit
    course_videos?: course_videosOmit
    courses?: coursesOmit
    enrollments?: enrollmentsOmit
    google_ads?: google_adsOmit
    mock_attempts?: mock_attemptsOmit
    mock_categories?: mock_categoriesOmit
    mock_questions?: mock_questionsOmit
    mock_series?: mock_seriesOmit
    mock_tests?: mock_testsOmit
    payments?: paymentsOmit
    post_tags?: post_tagsOmit
    post_templates?: post_templatesOmit
    posts?: postsOmit
    study_materials?: study_materialsOmit
    tags?: tagsOmit
    users?: usersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CategoriesCountOutputType
   */

  export type CategoriesCountOutputType = {
    posts: number
  }

  export type CategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | CategoriesCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesCountOutputType
     */
    select?: CategoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: postsWhereInput
  }


  /**
   * Count Type Course_plansCountOutputType
   */

  export type Course_plansCountOutputType = {
    enrollments: number
  }

  export type Course_plansCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | Course_plansCountOutputTypeCountEnrollmentsArgs
  }

  // Custom InputTypes
  /**
   * Course_plansCountOutputType without action
   */
  export type Course_plansCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course_plansCountOutputType
     */
    select?: Course_plansCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Course_plansCountOutputType without action
   */
  export type Course_plansCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enrollmentsWhereInput
  }


  /**
   * Count Type CoursesCountOutputType
   */

  export type CoursesCountOutputType = {
    course_plans: number
    course_reviews: number
    course_videos: number
    enrollments: number
    payments: number
  }

  export type CoursesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course_plans?: boolean | CoursesCountOutputTypeCountCourse_plansArgs
    course_reviews?: boolean | CoursesCountOutputTypeCountCourse_reviewsArgs
    course_videos?: boolean | CoursesCountOutputTypeCountCourse_videosArgs
    enrollments?: boolean | CoursesCountOutputTypeCountEnrollmentsArgs
    payments?: boolean | CoursesCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoursesCountOutputType
     */
    select?: CoursesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountCourse_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: course_plansWhereInput
  }

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountCourse_reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: course_reviewsWhereInput
  }

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountCourse_videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: course_videosWhereInput
  }

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enrollmentsWhereInput
  }

  /**
   * CoursesCountOutputType without action
   */
  export type CoursesCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }


  /**
   * Count Type Mock_categoriesCountOutputType
   */

  export type Mock_categoriesCountOutputType = {
    mock_series: number
  }

  export type Mock_categoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mock_series?: boolean | Mock_categoriesCountOutputTypeCountMock_seriesArgs
  }

  // Custom InputTypes
  /**
   * Mock_categoriesCountOutputType without action
   */
  export type Mock_categoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mock_categoriesCountOutputType
     */
    select?: Mock_categoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Mock_categoriesCountOutputType without action
   */
  export type Mock_categoriesCountOutputTypeCountMock_seriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mock_seriesWhereInput
  }


  /**
   * Count Type Mock_seriesCountOutputType
   */

  export type Mock_seriesCountOutputType = {
    mock_tests: number
    payments: number
  }

  export type Mock_seriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mock_tests?: boolean | Mock_seriesCountOutputTypeCountMock_testsArgs
    payments?: boolean | Mock_seriesCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * Mock_seriesCountOutputType without action
   */
  export type Mock_seriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mock_seriesCountOutputType
     */
    select?: Mock_seriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Mock_seriesCountOutputType without action
   */
  export type Mock_seriesCountOutputTypeCountMock_testsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mock_testsWhereInput
  }

  /**
   * Mock_seriesCountOutputType without action
   */
  export type Mock_seriesCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }


  /**
   * Count Type Mock_testsCountOutputType
   */

  export type Mock_testsCountOutputType = {
    mock_attempts: number
    mock_questions: number
  }

  export type Mock_testsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mock_attempts?: boolean | Mock_testsCountOutputTypeCountMock_attemptsArgs
    mock_questions?: boolean | Mock_testsCountOutputTypeCountMock_questionsArgs
  }

  // Custom InputTypes
  /**
   * Mock_testsCountOutputType without action
   */
  export type Mock_testsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mock_testsCountOutputType
     */
    select?: Mock_testsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Mock_testsCountOutputType without action
   */
  export type Mock_testsCountOutputTypeCountMock_attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mock_attemptsWhereInput
  }

  /**
   * Mock_testsCountOutputType without action
   */
  export type Mock_testsCountOutputTypeCountMock_questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mock_questionsWhereInput
  }


  /**
   * Count Type Post_templatesCountOutputType
   */

  export type Post_templatesCountOutputType = {
    posts: number
  }

  export type Post_templatesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | Post_templatesCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * Post_templatesCountOutputType without action
   */
  export type Post_templatesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post_templatesCountOutputType
     */
    select?: Post_templatesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Post_templatesCountOutputType without action
   */
  export type Post_templatesCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: postsWhereInput
  }


  /**
   * Count Type PostsCountOutputType
   */

  export type PostsCountOutputType = {
    comments: number
    post_tags: number
  }

  export type PostsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PostsCountOutputTypeCountCommentsArgs
    post_tags?: boolean | PostsCountOutputTypeCountPost_tagsArgs
  }

  // Custom InputTypes
  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostsCountOutputType
     */
    select?: PostsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
  }

  /**
   * PostsCountOutputType without action
   */
  export type PostsCountOutputTypeCountPost_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: post_tagsWhereInput
  }


  /**
   * Count Type TagsCountOutputType
   */

  export type TagsCountOutputType = {
    post_tags: number
  }

  export type TagsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post_tags?: boolean | TagsCountOutputTypeCountPost_tagsArgs
  }

  // Custom InputTypes
  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagsCountOutputType
     */
    select?: TagsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagsCountOutputType without action
   */
  export type TagsCountOutputTypeCountPost_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: post_tagsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    comments: number
    course_reviews: number
    enrollments: number
    mock_attempts: number
    payments: number
    posts: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | UsersCountOutputTypeCountCommentsArgs
    course_reviews?: boolean | UsersCountOutputTypeCountCourse_reviewsArgs
    enrollments?: boolean | UsersCountOutputTypeCountEnrollmentsArgs
    mock_attempts?: boolean | UsersCountOutputTypeCountMock_attemptsArgs
    payments?: boolean | UsersCountOutputTypeCountPaymentsArgs
    posts?: boolean | UsersCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCourse_reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: course_reviewsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enrollmentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMock_attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mock_attemptsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: postsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model answer_keys
   */

  export type AggregateAnswer_keys = {
    _count: Answer_keysCountAggregateOutputType | null
    _avg: Answer_keysAvgAggregateOutputType | null
    _sum: Answer_keysSumAggregateOutputType | null
    _min: Answer_keysMinAggregateOutputType | null
    _max: Answer_keysMaxAggregateOutputType | null
  }

  export type Answer_keysAvgAggregateOutputType = {
    id: number | null
    year: number | null
  }

  export type Answer_keysSumAggregateOutputType = {
    id: bigint | null
    year: number | null
  }

  export type Answer_keysMinAggregateOutputType = {
    id: bigint | null
    title: string | null
    year: number | null
    file_url: string | null
    created_at: Date | null
  }

  export type Answer_keysMaxAggregateOutputType = {
    id: bigint | null
    title: string | null
    year: number | null
    file_url: string | null
    created_at: Date | null
  }

  export type Answer_keysCountAggregateOutputType = {
    id: number
    title: number
    year: number
    file_url: number
    created_at: number
    _all: number
  }


  export type Answer_keysAvgAggregateInputType = {
    id?: true
    year?: true
  }

  export type Answer_keysSumAggregateInputType = {
    id?: true
    year?: true
  }

  export type Answer_keysMinAggregateInputType = {
    id?: true
    title?: true
    year?: true
    file_url?: true
    created_at?: true
  }

  export type Answer_keysMaxAggregateInputType = {
    id?: true
    title?: true
    year?: true
    file_url?: true
    created_at?: true
  }

  export type Answer_keysCountAggregateInputType = {
    id?: true
    title?: true
    year?: true
    file_url?: true
    created_at?: true
    _all?: true
  }

  export type Answer_keysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which answer_keys to aggregate.
     */
    where?: answer_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answer_keys to fetch.
     */
    orderBy?: answer_keysOrderByWithRelationInput | answer_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: answer_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answer_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answer_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned answer_keys
    **/
    _count?: true | Answer_keysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Answer_keysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Answer_keysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Answer_keysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Answer_keysMaxAggregateInputType
  }

  export type GetAnswer_keysAggregateType<T extends Answer_keysAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswer_keys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswer_keys[P]>
      : GetScalarType<T[P], AggregateAnswer_keys[P]>
  }




  export type answer_keysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: answer_keysWhereInput
    orderBy?: answer_keysOrderByWithAggregationInput | answer_keysOrderByWithAggregationInput[]
    by: Answer_keysScalarFieldEnum[] | Answer_keysScalarFieldEnum
    having?: answer_keysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Answer_keysCountAggregateInputType | true
    _avg?: Answer_keysAvgAggregateInputType
    _sum?: Answer_keysSumAggregateInputType
    _min?: Answer_keysMinAggregateInputType
    _max?: Answer_keysMaxAggregateInputType
  }

  export type Answer_keysGroupByOutputType = {
    id: bigint
    title: string
    year: number | null
    file_url: string
    created_at: Date | null
    _count: Answer_keysCountAggregateOutputType | null
    _avg: Answer_keysAvgAggregateOutputType | null
    _sum: Answer_keysSumAggregateOutputType | null
    _min: Answer_keysMinAggregateOutputType | null
    _max: Answer_keysMaxAggregateOutputType | null
  }

  type GetAnswer_keysGroupByPayload<T extends answer_keysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Answer_keysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Answer_keysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Answer_keysGroupByOutputType[P]>
            : GetScalarType<T[P], Answer_keysGroupByOutputType[P]>
        }
      >
    >


  export type answer_keysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    year?: boolean
    file_url?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["answer_keys"]>

  export type answer_keysSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    year?: boolean
    file_url?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["answer_keys"]>

  export type answer_keysSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    year?: boolean
    file_url?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["answer_keys"]>

  export type answer_keysSelectScalar = {
    id?: boolean
    title?: boolean
    year?: boolean
    file_url?: boolean
    created_at?: boolean
  }

  export type answer_keysOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "year" | "file_url" | "created_at", ExtArgs["result"]["answer_keys"]>

  export type $answer_keysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "answer_keys"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      title: string
      year: number | null
      file_url: string
      created_at: Date | null
    }, ExtArgs["result"]["answer_keys"]>
    composites: {}
  }

  type answer_keysGetPayload<S extends boolean | null | undefined | answer_keysDefaultArgs> = $Result.GetResult<Prisma.$answer_keysPayload, S>

  type answer_keysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<answer_keysFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Answer_keysCountAggregateInputType | true
    }

  export interface answer_keysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['answer_keys'], meta: { name: 'answer_keys' } }
    /**
     * Find zero or one Answer_keys that matches the filter.
     * @param {answer_keysFindUniqueArgs} args - Arguments to find a Answer_keys
     * @example
     * // Get one Answer_keys
     * const answer_keys = await prisma.answer_keys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends answer_keysFindUniqueArgs>(args: SelectSubset<T, answer_keysFindUniqueArgs<ExtArgs>>): Prisma__answer_keysClient<$Result.GetResult<Prisma.$answer_keysPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Answer_keys that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {answer_keysFindUniqueOrThrowArgs} args - Arguments to find a Answer_keys
     * @example
     * // Get one Answer_keys
     * const answer_keys = await prisma.answer_keys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends answer_keysFindUniqueOrThrowArgs>(args: SelectSubset<T, answer_keysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__answer_keysClient<$Result.GetResult<Prisma.$answer_keysPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Answer_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answer_keysFindFirstArgs} args - Arguments to find a Answer_keys
     * @example
     * // Get one Answer_keys
     * const answer_keys = await prisma.answer_keys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends answer_keysFindFirstArgs>(args?: SelectSubset<T, answer_keysFindFirstArgs<ExtArgs>>): Prisma__answer_keysClient<$Result.GetResult<Prisma.$answer_keysPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Answer_keys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answer_keysFindFirstOrThrowArgs} args - Arguments to find a Answer_keys
     * @example
     * // Get one Answer_keys
     * const answer_keys = await prisma.answer_keys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends answer_keysFindFirstOrThrowArgs>(args?: SelectSubset<T, answer_keysFindFirstOrThrowArgs<ExtArgs>>): Prisma__answer_keysClient<$Result.GetResult<Prisma.$answer_keysPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Answer_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answer_keysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answer_keys
     * const answer_keys = await prisma.answer_keys.findMany()
     * 
     * // Get first 10 Answer_keys
     * const answer_keys = await prisma.answer_keys.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answer_keysWithIdOnly = await prisma.answer_keys.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends answer_keysFindManyArgs>(args?: SelectSubset<T, answer_keysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$answer_keysPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Answer_keys.
     * @param {answer_keysCreateArgs} args - Arguments to create a Answer_keys.
     * @example
     * // Create one Answer_keys
     * const Answer_keys = await prisma.answer_keys.create({
     *   data: {
     *     // ... data to create a Answer_keys
     *   }
     * })
     * 
     */
    create<T extends answer_keysCreateArgs>(args: SelectSubset<T, answer_keysCreateArgs<ExtArgs>>): Prisma__answer_keysClient<$Result.GetResult<Prisma.$answer_keysPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Answer_keys.
     * @param {answer_keysCreateManyArgs} args - Arguments to create many Answer_keys.
     * @example
     * // Create many Answer_keys
     * const answer_keys = await prisma.answer_keys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends answer_keysCreateManyArgs>(args?: SelectSubset<T, answer_keysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Answer_keys and returns the data saved in the database.
     * @param {answer_keysCreateManyAndReturnArgs} args - Arguments to create many Answer_keys.
     * @example
     * // Create many Answer_keys
     * const answer_keys = await prisma.answer_keys.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Answer_keys and only return the `id`
     * const answer_keysWithIdOnly = await prisma.answer_keys.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends answer_keysCreateManyAndReturnArgs>(args?: SelectSubset<T, answer_keysCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$answer_keysPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Answer_keys.
     * @param {answer_keysDeleteArgs} args - Arguments to delete one Answer_keys.
     * @example
     * // Delete one Answer_keys
     * const Answer_keys = await prisma.answer_keys.delete({
     *   where: {
     *     // ... filter to delete one Answer_keys
     *   }
     * })
     * 
     */
    delete<T extends answer_keysDeleteArgs>(args: SelectSubset<T, answer_keysDeleteArgs<ExtArgs>>): Prisma__answer_keysClient<$Result.GetResult<Prisma.$answer_keysPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Answer_keys.
     * @param {answer_keysUpdateArgs} args - Arguments to update one Answer_keys.
     * @example
     * // Update one Answer_keys
     * const answer_keys = await prisma.answer_keys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends answer_keysUpdateArgs>(args: SelectSubset<T, answer_keysUpdateArgs<ExtArgs>>): Prisma__answer_keysClient<$Result.GetResult<Prisma.$answer_keysPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Answer_keys.
     * @param {answer_keysDeleteManyArgs} args - Arguments to filter Answer_keys to delete.
     * @example
     * // Delete a few Answer_keys
     * const { count } = await prisma.answer_keys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends answer_keysDeleteManyArgs>(args?: SelectSubset<T, answer_keysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answer_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answer_keysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answer_keys
     * const answer_keys = await prisma.answer_keys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends answer_keysUpdateManyArgs>(args: SelectSubset<T, answer_keysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answer_keys and returns the data updated in the database.
     * @param {answer_keysUpdateManyAndReturnArgs} args - Arguments to update many Answer_keys.
     * @example
     * // Update many Answer_keys
     * const answer_keys = await prisma.answer_keys.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Answer_keys and only return the `id`
     * const answer_keysWithIdOnly = await prisma.answer_keys.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends answer_keysUpdateManyAndReturnArgs>(args: SelectSubset<T, answer_keysUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$answer_keysPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Answer_keys.
     * @param {answer_keysUpsertArgs} args - Arguments to update or create a Answer_keys.
     * @example
     * // Update or create a Answer_keys
     * const answer_keys = await prisma.answer_keys.upsert({
     *   create: {
     *     // ... data to create a Answer_keys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answer_keys we want to update
     *   }
     * })
     */
    upsert<T extends answer_keysUpsertArgs>(args: SelectSubset<T, answer_keysUpsertArgs<ExtArgs>>): Prisma__answer_keysClient<$Result.GetResult<Prisma.$answer_keysPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Answer_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answer_keysCountArgs} args - Arguments to filter Answer_keys to count.
     * @example
     * // Count the number of Answer_keys
     * const count = await prisma.answer_keys.count({
     *   where: {
     *     // ... the filter for the Answer_keys we want to count
     *   }
     * })
    **/
    count<T extends answer_keysCountArgs>(
      args?: Subset<T, answer_keysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Answer_keysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answer_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Answer_keysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Answer_keysAggregateArgs>(args: Subset<T, Answer_keysAggregateArgs>): Prisma.PrismaPromise<GetAnswer_keysAggregateType<T>>

    /**
     * Group by Answer_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answer_keysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends answer_keysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: answer_keysGroupByArgs['orderBy'] }
        : { orderBy?: answer_keysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, answer_keysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswer_keysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the answer_keys model
   */
  readonly fields: answer_keysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for answer_keys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__answer_keysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the answer_keys model
   */
  interface answer_keysFieldRefs {
    readonly id: FieldRef<"answer_keys", 'BigInt'>
    readonly title: FieldRef<"answer_keys", 'String'>
    readonly year: FieldRef<"answer_keys", 'Int'>
    readonly file_url: FieldRef<"answer_keys", 'String'>
    readonly created_at: FieldRef<"answer_keys", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * answer_keys findUnique
   */
  export type answer_keysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answer_keys
     */
    select?: answer_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answer_keys
     */
    omit?: answer_keysOmit<ExtArgs> | null
    /**
     * Filter, which answer_keys to fetch.
     */
    where: answer_keysWhereUniqueInput
  }

  /**
   * answer_keys findUniqueOrThrow
   */
  export type answer_keysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answer_keys
     */
    select?: answer_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answer_keys
     */
    omit?: answer_keysOmit<ExtArgs> | null
    /**
     * Filter, which answer_keys to fetch.
     */
    where: answer_keysWhereUniqueInput
  }

  /**
   * answer_keys findFirst
   */
  export type answer_keysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answer_keys
     */
    select?: answer_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answer_keys
     */
    omit?: answer_keysOmit<ExtArgs> | null
    /**
     * Filter, which answer_keys to fetch.
     */
    where?: answer_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answer_keys to fetch.
     */
    orderBy?: answer_keysOrderByWithRelationInput | answer_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for answer_keys.
     */
    cursor?: answer_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answer_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answer_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of answer_keys.
     */
    distinct?: Answer_keysScalarFieldEnum | Answer_keysScalarFieldEnum[]
  }

  /**
   * answer_keys findFirstOrThrow
   */
  export type answer_keysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answer_keys
     */
    select?: answer_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answer_keys
     */
    omit?: answer_keysOmit<ExtArgs> | null
    /**
     * Filter, which answer_keys to fetch.
     */
    where?: answer_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answer_keys to fetch.
     */
    orderBy?: answer_keysOrderByWithRelationInput | answer_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for answer_keys.
     */
    cursor?: answer_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answer_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answer_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of answer_keys.
     */
    distinct?: Answer_keysScalarFieldEnum | Answer_keysScalarFieldEnum[]
  }

  /**
   * answer_keys findMany
   */
  export type answer_keysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answer_keys
     */
    select?: answer_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answer_keys
     */
    omit?: answer_keysOmit<ExtArgs> | null
    /**
     * Filter, which answer_keys to fetch.
     */
    where?: answer_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answer_keys to fetch.
     */
    orderBy?: answer_keysOrderByWithRelationInput | answer_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing answer_keys.
     */
    cursor?: answer_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answer_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answer_keys.
     */
    skip?: number
    distinct?: Answer_keysScalarFieldEnum | Answer_keysScalarFieldEnum[]
  }

  /**
   * answer_keys create
   */
  export type answer_keysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answer_keys
     */
    select?: answer_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answer_keys
     */
    omit?: answer_keysOmit<ExtArgs> | null
    /**
     * The data needed to create a answer_keys.
     */
    data: XOR<answer_keysCreateInput, answer_keysUncheckedCreateInput>
  }

  /**
   * answer_keys createMany
   */
  export type answer_keysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many answer_keys.
     */
    data: answer_keysCreateManyInput | answer_keysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * answer_keys createManyAndReturn
   */
  export type answer_keysCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answer_keys
     */
    select?: answer_keysSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the answer_keys
     */
    omit?: answer_keysOmit<ExtArgs> | null
    /**
     * The data used to create many answer_keys.
     */
    data: answer_keysCreateManyInput | answer_keysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * answer_keys update
   */
  export type answer_keysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answer_keys
     */
    select?: answer_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answer_keys
     */
    omit?: answer_keysOmit<ExtArgs> | null
    /**
     * The data needed to update a answer_keys.
     */
    data: XOR<answer_keysUpdateInput, answer_keysUncheckedUpdateInput>
    /**
     * Choose, which answer_keys to update.
     */
    where: answer_keysWhereUniqueInput
  }

  /**
   * answer_keys updateMany
   */
  export type answer_keysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update answer_keys.
     */
    data: XOR<answer_keysUpdateManyMutationInput, answer_keysUncheckedUpdateManyInput>
    /**
     * Filter which answer_keys to update
     */
    where?: answer_keysWhereInput
    /**
     * Limit how many answer_keys to update.
     */
    limit?: number
  }

  /**
   * answer_keys updateManyAndReturn
   */
  export type answer_keysUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answer_keys
     */
    select?: answer_keysSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the answer_keys
     */
    omit?: answer_keysOmit<ExtArgs> | null
    /**
     * The data used to update answer_keys.
     */
    data: XOR<answer_keysUpdateManyMutationInput, answer_keysUncheckedUpdateManyInput>
    /**
     * Filter which answer_keys to update
     */
    where?: answer_keysWhereInput
    /**
     * Limit how many answer_keys to update.
     */
    limit?: number
  }

  /**
   * answer_keys upsert
   */
  export type answer_keysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answer_keys
     */
    select?: answer_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answer_keys
     */
    omit?: answer_keysOmit<ExtArgs> | null
    /**
     * The filter to search for the answer_keys to update in case it exists.
     */
    where: answer_keysWhereUniqueInput
    /**
     * In case the answer_keys found by the `where` argument doesn't exist, create a new answer_keys with this data.
     */
    create: XOR<answer_keysCreateInput, answer_keysUncheckedCreateInput>
    /**
     * In case the answer_keys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<answer_keysUpdateInput, answer_keysUncheckedUpdateInput>
  }

  /**
   * answer_keys delete
   */
  export type answer_keysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answer_keys
     */
    select?: answer_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answer_keys
     */
    omit?: answer_keysOmit<ExtArgs> | null
    /**
     * Filter which answer_keys to delete.
     */
    where: answer_keysWhereUniqueInput
  }

  /**
   * answer_keys deleteMany
   */
  export type answer_keysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which answer_keys to delete
     */
    where?: answer_keysWhereInput
    /**
     * Limit how many answer_keys to delete.
     */
    limit?: number
  }

  /**
   * answer_keys without action
   */
  export type answer_keysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answer_keys
     */
    select?: answer_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answer_keys
     */
    omit?: answer_keysOmit<ExtArgs> | null
  }


  /**
   * Model categories
   */

  export type AggregateCategories = {
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoriesSumAggregateOutputType = {
    id: bigint | null
  }

  export type CategoriesMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    description: string | null
    created_at: Date | null
  }

  export type CategoriesMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    description: string | null
    created_at: Date | null
  }

  export type CategoriesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    created_at: number
    _all: number
  }


  export type CategoriesAvgAggregateInputType = {
    id?: true
  }

  export type CategoriesSumAggregateInputType = {
    id?: true
  }

  export type CategoriesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
  }

  export type CategoriesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
  }

  export type CategoriesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
    _all?: true
  }

  export type CategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to aggregate.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }




  export type categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriesWhereInput
    orderBy?: categoriesOrderByWithAggregationInput | categoriesOrderByWithAggregationInput[]
    by: CategoriesScalarFieldEnum[] | CategoriesScalarFieldEnum
    having?: categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesCountAggregateInputType | true
    _avg?: CategoriesAvgAggregateInputType
    _sum?: CategoriesSumAggregateInputType
    _min?: CategoriesMinAggregateInputType
    _max?: CategoriesMaxAggregateInputType
  }

  export type CategoriesGroupByOutputType = {
    id: bigint
    name: string
    description: string | null
    created_at: Date | null
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  type GetCategoriesGroupByPayload<T extends categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
        }
      >
    >


  export type categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
    posts?: boolean | categories$postsArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    created_at?: boolean
  }

  export type categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "created_at", ExtArgs["result"]["categories"]>
  export type categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | categories$postsArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type categoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type categoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categories"
    objects: {
      posts: Prisma.$postsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      description: string | null
      created_at: Date | null
    }, ExtArgs["result"]["categories"]>
    composites: {}
  }

  type categoriesGetPayload<S extends boolean | null | undefined | categoriesDefaultArgs> = $Result.GetResult<Prisma.$categoriesPayload, S>

  type categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriesCountAggregateInputType | true
    }

  export interface categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categories'], meta: { name: 'categories' } }
    /**
     * Find zero or one Categories that matches the filter.
     * @param {categoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoriesFindUniqueArgs>(args: SelectSubset<T, categoriesFindUniqueArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoriesFindFirstArgs>(args?: SelectSubset<T, categoriesFindFirstArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoriesFindManyArgs>(args?: SelectSubset<T, categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categories.
     * @param {categoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
     */
    create<T extends categoriesCreateArgs>(args: SelectSubset<T, categoriesCreateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {categoriesCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoriesCreateManyArgs>(args?: SelectSubset<T, categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {categoriesCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Categories.
     * @param {categoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
     */
    delete<T extends categoriesDeleteArgs>(args: SelectSubset<T, categoriesDeleteArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categories.
     * @param {categoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoriesUpdateArgs>(args: SelectSubset<T, categoriesUpdateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {categoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoriesDeleteManyArgs>(args?: SelectSubset<T, categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoriesUpdateManyArgs>(args: SelectSubset<T, categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {categoriesUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Categories.
     * @param {categoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
     */
    upsert<T extends categoriesUpsertArgs>(args: SelectSubset<T, categoriesUpsertArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoriesCountArgs>(
      args?: Subset<T, categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): Prisma.PrismaPromise<GetCategoriesAggregateType<T>>

    /**
     * Group by Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriesGroupByArgs['orderBy'] }
        : { orderBy?: categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categories model
   */
  readonly fields: categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends categories$postsArgs<ExtArgs> = {}>(args?: Subset<T, categories$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the categories model
   */
  interface categoriesFieldRefs {
    readonly id: FieldRef<"categories", 'BigInt'>
    readonly name: FieldRef<"categories", 'String'>
    readonly description: FieldRef<"categories", 'String'>
    readonly created_at: FieldRef<"categories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * categories findUnique
   */
  export type categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findUniqueOrThrow
   */
  export type categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findFirst
   */
  export type categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findFirstOrThrow
   */
  export type categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findMany
   */
  export type categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories create
   */
  export type categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a categories.
     */
    data: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
  }

  /**
   * categories createMany
   */
  export type categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoriesCreateManyInput | categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categories createManyAndReturn
   */
  export type categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * The data used to create many categories.
     */
    data: categoriesCreateManyInput | categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categories update
   */
  export type categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a categories.
     */
    data: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
    /**
     * Choose, which categories to update.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories updateMany
   */
  export type categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * categories updateManyAndReturn
   */
  export type categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * The data used to update categories.
     */
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * categories upsert
   */
  export type categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the categories to update in case it exists.
     */
    where: categoriesWhereUniqueInput
    /**
     * In case the categories found by the `where` argument doesn't exist, create a new categories with this data.
     */
    create: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
    /**
     * In case the categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
  }

  /**
   * categories delete
   */
  export type categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter which categories to delete.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories deleteMany
   */
  export type categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to delete.
     */
    limit?: number
  }

  /**
   * categories.posts
   */
  export type categories$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the posts
     */
    omit?: postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    where?: postsWhereInput
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    cursor?: postsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * categories without action
   */
  export type categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
  }


  /**
   * Model comments
   */

  export type AggregateComments = {
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  export type CommentsAvgAggregateOutputType = {
    id: number | null
    post_id: number | null
    user_id: number | null
  }

  export type CommentsSumAggregateOutputType = {
    id: bigint | null
    post_id: bigint | null
    user_id: bigint | null
  }

  export type CommentsMinAggregateOutputType = {
    id: bigint | null
    post_id: bigint | null
    user_id: bigint | null
    content: string | null
    created_at: Date | null
  }

  export type CommentsMaxAggregateOutputType = {
    id: bigint | null
    post_id: bigint | null
    user_id: bigint | null
    content: string | null
    created_at: Date | null
  }

  export type CommentsCountAggregateOutputType = {
    id: number
    post_id: number
    user_id: number
    content: number
    created_at: number
    _all: number
  }


  export type CommentsAvgAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
  }

  export type CommentsSumAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
  }

  export type CommentsMinAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
    content?: true
    created_at?: true
  }

  export type CommentsMaxAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
    content?: true
    created_at?: true
  }

  export type CommentsCountAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
    content?: true
    created_at?: true
    _all?: true
  }

  export type CommentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to aggregate.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comments
    **/
    _count?: true | CommentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentsMaxAggregateInputType
  }

  export type GetCommentsAggregateType<T extends CommentsAggregateArgs> = {
        [P in keyof T & keyof AggregateComments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComments[P]>
      : GetScalarType<T[P], AggregateComments[P]>
  }




  export type commentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithAggregationInput | commentsOrderByWithAggregationInput[]
    by: CommentsScalarFieldEnum[] | CommentsScalarFieldEnum
    having?: commentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentsCountAggregateInputType | true
    _avg?: CommentsAvgAggregateInputType
    _sum?: CommentsSumAggregateInputType
    _min?: CommentsMinAggregateInputType
    _max?: CommentsMaxAggregateInputType
  }

  export type CommentsGroupByOutputType = {
    id: bigint
    post_id: bigint | null
    user_id: bigint | null
    content: string
    created_at: Date | null
    _count: CommentsCountAggregateOutputType | null
    _avg: CommentsAvgAggregateOutputType | null
    _sum: CommentsSumAggregateOutputType | null
    _min: CommentsMinAggregateOutputType | null
    _max: CommentsMaxAggregateOutputType | null
  }

  type GetCommentsGroupByPayload<T extends commentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentsGroupByOutputType[P]>
            : GetScalarType<T[P], CommentsGroupByOutputType[P]>
        }
      >
    >


  export type commentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    content?: boolean
    created_at?: boolean
    posts?: boolean | comments$postsArgs<ExtArgs>
    users?: boolean | comments$usersArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type commentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    content?: boolean
    created_at?: boolean
    posts?: boolean | comments$postsArgs<ExtArgs>
    users?: boolean | comments$usersArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type commentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    content?: boolean
    created_at?: boolean
    posts?: boolean | comments$postsArgs<ExtArgs>
    users?: boolean | comments$usersArgs<ExtArgs>
  }, ExtArgs["result"]["comments"]>

  export type commentsSelectScalar = {
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    content?: boolean
    created_at?: boolean
  }

  export type commentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "post_id" | "user_id" | "content" | "created_at", ExtArgs["result"]["comments"]>
  export type commentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | comments$postsArgs<ExtArgs>
    users?: boolean | comments$usersArgs<ExtArgs>
  }
  export type commentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | comments$postsArgs<ExtArgs>
    users?: boolean | comments$usersArgs<ExtArgs>
  }
  export type commentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | comments$postsArgs<ExtArgs>
    users?: boolean | comments$usersArgs<ExtArgs>
  }

  export type $commentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comments"
    objects: {
      posts: Prisma.$postsPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      post_id: bigint | null
      user_id: bigint | null
      content: string
      created_at: Date | null
    }, ExtArgs["result"]["comments"]>
    composites: {}
  }

  type commentsGetPayload<S extends boolean | null | undefined | commentsDefaultArgs> = $Result.GetResult<Prisma.$commentsPayload, S>

  type commentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<commentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentsCountAggregateInputType | true
    }

  export interface commentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comments'], meta: { name: 'comments' } }
    /**
     * Find zero or one Comments that matches the filter.
     * @param {commentsFindUniqueArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends commentsFindUniqueArgs>(args: SelectSubset<T, commentsFindUniqueArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {commentsFindUniqueOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends commentsFindUniqueOrThrowArgs>(args: SelectSubset<T, commentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends commentsFindFirstArgs>(args?: SelectSubset<T, commentsFindFirstArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindFirstOrThrowArgs} args - Arguments to find a Comments
     * @example
     * // Get one Comments
     * const comments = await prisma.comments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends commentsFindFirstOrThrowArgs>(args?: SelectSubset<T, commentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comments.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentsWithIdOnly = await prisma.comments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends commentsFindManyArgs>(args?: SelectSubset<T, commentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comments.
     * @param {commentsCreateArgs} args - Arguments to create a Comments.
     * @example
     * // Create one Comments
     * const Comments = await prisma.comments.create({
     *   data: {
     *     // ... data to create a Comments
     *   }
     * })
     * 
     */
    create<T extends commentsCreateArgs>(args: SelectSubset<T, commentsCreateArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {commentsCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends commentsCreateManyArgs>(args?: SelectSubset<T, commentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {commentsCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comments = await prisma.comments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentsWithIdOnly = await prisma.comments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends commentsCreateManyAndReturnArgs>(args?: SelectSubset<T, commentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comments.
     * @param {commentsDeleteArgs} args - Arguments to delete one Comments.
     * @example
     * // Delete one Comments
     * const Comments = await prisma.comments.delete({
     *   where: {
     *     // ... filter to delete one Comments
     *   }
     * })
     * 
     */
    delete<T extends commentsDeleteArgs>(args: SelectSubset<T, commentsDeleteArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comments.
     * @param {commentsUpdateArgs} args - Arguments to update one Comments.
     * @example
     * // Update one Comments
     * const comments = await prisma.comments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends commentsUpdateArgs>(args: SelectSubset<T, commentsUpdateArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {commentsDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends commentsDeleteManyArgs>(args?: SelectSubset<T, commentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends commentsUpdateManyArgs>(args: SelectSubset<T, commentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {commentsUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comments = await prisma.comments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentsWithIdOnly = await prisma.comments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends commentsUpdateManyAndReturnArgs>(args: SelectSubset<T, commentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comments.
     * @param {commentsUpsertArgs} args - Arguments to update or create a Comments.
     * @example
     * // Update or create a Comments
     * const comments = await prisma.comments.upsert({
     *   create: {
     *     // ... data to create a Comments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comments we want to update
     *   }
     * })
     */
    upsert<T extends commentsUpsertArgs>(args: SelectSubset<T, commentsUpsertArgs<ExtArgs>>): Prisma__commentsClient<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comments.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends commentsCountArgs>(
      args?: Subset<T, commentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentsAggregateArgs>(args: Subset<T, CommentsAggregateArgs>): Prisma.PrismaPromise<GetCommentsAggregateType<T>>

    /**
     * Group by Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends commentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: commentsGroupByArgs['orderBy'] }
        : { orderBy?: commentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, commentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comments model
   */
  readonly fields: commentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__commentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends comments$postsArgs<ExtArgs> = {}>(args?: Subset<T, comments$postsArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends comments$usersArgs<ExtArgs> = {}>(args?: Subset<T, comments$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the comments model
   */
  interface commentsFieldRefs {
    readonly id: FieldRef<"comments", 'BigInt'>
    readonly post_id: FieldRef<"comments", 'BigInt'>
    readonly user_id: FieldRef<"comments", 'BigInt'>
    readonly content: FieldRef<"comments", 'String'>
    readonly created_at: FieldRef<"comments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * comments findUnique
   */
  export type commentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments findUniqueOrThrow
   */
  export type commentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments findFirst
   */
  export type commentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * comments findFirstOrThrow
   */
  export type commentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * comments findMany
   */
  export type commentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comments.
     */
    cursor?: commentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * comments create
   */
  export type commentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The data needed to create a comments.
     */
    data: XOR<commentsCreateInput, commentsUncheckedCreateInput>
  }

  /**
   * comments createMany
   */
  export type commentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comments.
     */
    data: commentsCreateManyInput | commentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * comments createManyAndReturn
   */
  export type commentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * The data used to create many comments.
     */
    data: commentsCreateManyInput | commentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * comments update
   */
  export type commentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The data needed to update a comments.
     */
    data: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>
    /**
     * Choose, which comments to update.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments updateMany
   */
  export type commentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comments.
     */
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyInput>
    /**
     * Filter which comments to update
     */
    where?: commentsWhereInput
    /**
     * Limit how many comments to update.
     */
    limit?: number
  }

  /**
   * comments updateManyAndReturn
   */
  export type commentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * The data used to update comments.
     */
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyInput>
    /**
     * Filter which comments to update
     */
    where?: commentsWhereInput
    /**
     * Limit how many comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * comments upsert
   */
  export type commentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * The filter to search for the comments to update in case it exists.
     */
    where: commentsWhereUniqueInput
    /**
     * In case the comments found by the `where` argument doesn't exist, create a new comments with this data.
     */
    create: XOR<commentsCreateInput, commentsUncheckedCreateInput>
    /**
     * In case the comments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<commentsUpdateInput, commentsUncheckedUpdateInput>
  }

  /**
   * comments delete
   */
  export type commentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    /**
     * Filter which comments to delete.
     */
    where: commentsWhereUniqueInput
  }

  /**
   * comments deleteMany
   */
  export type commentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to delete
     */
    where?: commentsWhereInput
    /**
     * Limit how many comments to delete.
     */
    limit?: number
  }

  /**
   * comments.posts
   */
  export type comments$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the posts
     */
    omit?: postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    where?: postsWhereInput
  }

  /**
   * comments.users
   */
  export type comments$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * comments without action
   */
  export type commentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
  }


  /**
   * Model course_plans
   */

  export type AggregateCourse_plans = {
    _count: Course_plansCountAggregateOutputType | null
    _avg: Course_plansAvgAggregateOutputType | null
    _sum: Course_plansSumAggregateOutputType | null
    _min: Course_plansMinAggregateOutputType | null
    _max: Course_plansMaxAggregateOutputType | null
  }

  export type Course_plansAvgAggregateOutputType = {
    id: number | null
    course_id: number | null
    price: Decimal | null
    duration_days: number | null
  }

  export type Course_plansSumAggregateOutputType = {
    id: bigint | null
    course_id: bigint | null
    price: Decimal | null
    duration_days: number | null
  }

  export type Course_plansMinAggregateOutputType = {
    id: bigint | null
    course_id: bigint | null
    plan_type: $Enums.plan_type | null
    plan_name: string | null
    price: Decimal | null
    duration_days: number | null
    created_at: Date | null
  }

  export type Course_plansMaxAggregateOutputType = {
    id: bigint | null
    course_id: bigint | null
    plan_type: $Enums.plan_type | null
    plan_name: string | null
    price: Decimal | null
    duration_days: number | null
    created_at: Date | null
  }

  export type Course_plansCountAggregateOutputType = {
    id: number
    course_id: number
    plan_type: number
    plan_name: number
    price: number
    duration_days: number
    created_at: number
    _all: number
  }


  export type Course_plansAvgAggregateInputType = {
    id?: true
    course_id?: true
    price?: true
    duration_days?: true
  }

  export type Course_plansSumAggregateInputType = {
    id?: true
    course_id?: true
    price?: true
    duration_days?: true
  }

  export type Course_plansMinAggregateInputType = {
    id?: true
    course_id?: true
    plan_type?: true
    plan_name?: true
    price?: true
    duration_days?: true
    created_at?: true
  }

  export type Course_plansMaxAggregateInputType = {
    id?: true
    course_id?: true
    plan_type?: true
    plan_name?: true
    price?: true
    duration_days?: true
    created_at?: true
  }

  export type Course_plansCountAggregateInputType = {
    id?: true
    course_id?: true
    plan_type?: true
    plan_name?: true
    price?: true
    duration_days?: true
    created_at?: true
    _all?: true
  }

  export type Course_plansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which course_plans to aggregate.
     */
    where?: course_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of course_plans to fetch.
     */
    orderBy?: course_plansOrderByWithRelationInput | course_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: course_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` course_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` course_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned course_plans
    **/
    _count?: true | Course_plansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Course_plansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Course_plansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Course_plansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Course_plansMaxAggregateInputType
  }

  export type GetCourse_plansAggregateType<T extends Course_plansAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse_plans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse_plans[P]>
      : GetScalarType<T[P], AggregateCourse_plans[P]>
  }




  export type course_plansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: course_plansWhereInput
    orderBy?: course_plansOrderByWithAggregationInput | course_plansOrderByWithAggregationInput[]
    by: Course_plansScalarFieldEnum[] | Course_plansScalarFieldEnum
    having?: course_plansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Course_plansCountAggregateInputType | true
    _avg?: Course_plansAvgAggregateInputType
    _sum?: Course_plansSumAggregateInputType
    _min?: Course_plansMinAggregateInputType
    _max?: Course_plansMaxAggregateInputType
  }

  export type Course_plansGroupByOutputType = {
    id: bigint
    course_id: bigint | null
    plan_type: $Enums.plan_type
    plan_name: string
    price: Decimal | null
    duration_days: number | null
    created_at: Date | null
    _count: Course_plansCountAggregateOutputType | null
    _avg: Course_plansAvgAggregateOutputType | null
    _sum: Course_plansSumAggregateOutputType | null
    _min: Course_plansMinAggregateOutputType | null
    _max: Course_plansMaxAggregateOutputType | null
  }

  type GetCourse_plansGroupByPayload<T extends course_plansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Course_plansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Course_plansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Course_plansGroupByOutputType[P]>
            : GetScalarType<T[P], Course_plansGroupByOutputType[P]>
        }
      >
    >


  export type course_plansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    course_id?: boolean
    plan_type?: boolean
    plan_name?: boolean
    price?: boolean
    duration_days?: boolean
    created_at?: boolean
    courses?: boolean | course_plans$coursesArgs<ExtArgs>
    enrollments?: boolean | course_plans$enrollmentsArgs<ExtArgs>
    _count?: boolean | Course_plansCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course_plans"]>

  export type course_plansSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    course_id?: boolean
    plan_type?: boolean
    plan_name?: boolean
    price?: boolean
    duration_days?: boolean
    created_at?: boolean
    courses?: boolean | course_plans$coursesArgs<ExtArgs>
  }, ExtArgs["result"]["course_plans"]>

  export type course_plansSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    course_id?: boolean
    plan_type?: boolean
    plan_name?: boolean
    price?: boolean
    duration_days?: boolean
    created_at?: boolean
    courses?: boolean | course_plans$coursesArgs<ExtArgs>
  }, ExtArgs["result"]["course_plans"]>

  export type course_plansSelectScalar = {
    id?: boolean
    course_id?: boolean
    plan_type?: boolean
    plan_name?: boolean
    price?: boolean
    duration_days?: boolean
    created_at?: boolean
  }

  export type course_plansOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "course_id" | "plan_type" | "plan_name" | "price" | "duration_days" | "created_at", ExtArgs["result"]["course_plans"]>
  export type course_plansInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | course_plans$coursesArgs<ExtArgs>
    enrollments?: boolean | course_plans$enrollmentsArgs<ExtArgs>
    _count?: boolean | Course_plansCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type course_plansIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | course_plans$coursesArgs<ExtArgs>
  }
  export type course_plansIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | course_plans$coursesArgs<ExtArgs>
  }

  export type $course_plansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "course_plans"
    objects: {
      courses: Prisma.$coursesPayload<ExtArgs> | null
      enrollments: Prisma.$enrollmentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      course_id: bigint | null
      plan_type: $Enums.plan_type
      plan_name: string
      price: Prisma.Decimal | null
      duration_days: number | null
      created_at: Date | null
    }, ExtArgs["result"]["course_plans"]>
    composites: {}
  }

  type course_plansGetPayload<S extends boolean | null | undefined | course_plansDefaultArgs> = $Result.GetResult<Prisma.$course_plansPayload, S>

  type course_plansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<course_plansFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Course_plansCountAggregateInputType | true
    }

  export interface course_plansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['course_plans'], meta: { name: 'course_plans' } }
    /**
     * Find zero or one Course_plans that matches the filter.
     * @param {course_plansFindUniqueArgs} args - Arguments to find a Course_plans
     * @example
     * // Get one Course_plans
     * const course_plans = await prisma.course_plans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends course_plansFindUniqueArgs>(args: SelectSubset<T, course_plansFindUniqueArgs<ExtArgs>>): Prisma__course_plansClient<$Result.GetResult<Prisma.$course_plansPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course_plans that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {course_plansFindUniqueOrThrowArgs} args - Arguments to find a Course_plans
     * @example
     * // Get one Course_plans
     * const course_plans = await prisma.course_plans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends course_plansFindUniqueOrThrowArgs>(args: SelectSubset<T, course_plansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__course_plansClient<$Result.GetResult<Prisma.$course_plansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course_plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_plansFindFirstArgs} args - Arguments to find a Course_plans
     * @example
     * // Get one Course_plans
     * const course_plans = await prisma.course_plans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends course_plansFindFirstArgs>(args?: SelectSubset<T, course_plansFindFirstArgs<ExtArgs>>): Prisma__course_plansClient<$Result.GetResult<Prisma.$course_plansPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course_plans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_plansFindFirstOrThrowArgs} args - Arguments to find a Course_plans
     * @example
     * // Get one Course_plans
     * const course_plans = await prisma.course_plans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends course_plansFindFirstOrThrowArgs>(args?: SelectSubset<T, course_plansFindFirstOrThrowArgs<ExtArgs>>): Prisma__course_plansClient<$Result.GetResult<Prisma.$course_plansPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Course_plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_plansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Course_plans
     * const course_plans = await prisma.course_plans.findMany()
     * 
     * // Get first 10 Course_plans
     * const course_plans = await prisma.course_plans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const course_plansWithIdOnly = await prisma.course_plans.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends course_plansFindManyArgs>(args?: SelectSubset<T, course_plansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$course_plansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course_plans.
     * @param {course_plansCreateArgs} args - Arguments to create a Course_plans.
     * @example
     * // Create one Course_plans
     * const Course_plans = await prisma.course_plans.create({
     *   data: {
     *     // ... data to create a Course_plans
     *   }
     * })
     * 
     */
    create<T extends course_plansCreateArgs>(args: SelectSubset<T, course_plansCreateArgs<ExtArgs>>): Prisma__course_plansClient<$Result.GetResult<Prisma.$course_plansPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Course_plans.
     * @param {course_plansCreateManyArgs} args - Arguments to create many Course_plans.
     * @example
     * // Create many Course_plans
     * const course_plans = await prisma.course_plans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends course_plansCreateManyArgs>(args?: SelectSubset<T, course_plansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Course_plans and returns the data saved in the database.
     * @param {course_plansCreateManyAndReturnArgs} args - Arguments to create many Course_plans.
     * @example
     * // Create many Course_plans
     * const course_plans = await prisma.course_plans.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Course_plans and only return the `id`
     * const course_plansWithIdOnly = await prisma.course_plans.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends course_plansCreateManyAndReturnArgs>(args?: SelectSubset<T, course_plansCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$course_plansPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course_plans.
     * @param {course_plansDeleteArgs} args - Arguments to delete one Course_plans.
     * @example
     * // Delete one Course_plans
     * const Course_plans = await prisma.course_plans.delete({
     *   where: {
     *     // ... filter to delete one Course_plans
     *   }
     * })
     * 
     */
    delete<T extends course_plansDeleteArgs>(args: SelectSubset<T, course_plansDeleteArgs<ExtArgs>>): Prisma__course_plansClient<$Result.GetResult<Prisma.$course_plansPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course_plans.
     * @param {course_plansUpdateArgs} args - Arguments to update one Course_plans.
     * @example
     * // Update one Course_plans
     * const course_plans = await prisma.course_plans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends course_plansUpdateArgs>(args: SelectSubset<T, course_plansUpdateArgs<ExtArgs>>): Prisma__course_plansClient<$Result.GetResult<Prisma.$course_plansPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Course_plans.
     * @param {course_plansDeleteManyArgs} args - Arguments to filter Course_plans to delete.
     * @example
     * // Delete a few Course_plans
     * const { count } = await prisma.course_plans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends course_plansDeleteManyArgs>(args?: SelectSubset<T, course_plansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Course_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_plansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Course_plans
     * const course_plans = await prisma.course_plans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends course_plansUpdateManyArgs>(args: SelectSubset<T, course_plansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Course_plans and returns the data updated in the database.
     * @param {course_plansUpdateManyAndReturnArgs} args - Arguments to update many Course_plans.
     * @example
     * // Update many Course_plans
     * const course_plans = await prisma.course_plans.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Course_plans and only return the `id`
     * const course_plansWithIdOnly = await prisma.course_plans.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends course_plansUpdateManyAndReturnArgs>(args: SelectSubset<T, course_plansUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$course_plansPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course_plans.
     * @param {course_plansUpsertArgs} args - Arguments to update or create a Course_plans.
     * @example
     * // Update or create a Course_plans
     * const course_plans = await prisma.course_plans.upsert({
     *   create: {
     *     // ... data to create a Course_plans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course_plans we want to update
     *   }
     * })
     */
    upsert<T extends course_plansUpsertArgs>(args: SelectSubset<T, course_plansUpsertArgs<ExtArgs>>): Prisma__course_plansClient<$Result.GetResult<Prisma.$course_plansPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Course_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_plansCountArgs} args - Arguments to filter Course_plans to count.
     * @example
     * // Count the number of Course_plans
     * const count = await prisma.course_plans.count({
     *   where: {
     *     // ... the filter for the Course_plans we want to count
     *   }
     * })
    **/
    count<T extends course_plansCountArgs>(
      args?: Subset<T, course_plansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Course_plansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Course_plansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Course_plansAggregateArgs>(args: Subset<T, Course_plansAggregateArgs>): Prisma.PrismaPromise<GetCourse_plansAggregateType<T>>

    /**
     * Group by Course_plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_plansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends course_plansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: course_plansGroupByArgs['orderBy'] }
        : { orderBy?: course_plansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, course_plansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourse_plansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the course_plans model
   */
  readonly fields: course_plansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for course_plans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__course_plansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends course_plans$coursesArgs<ExtArgs> = {}>(args?: Subset<T, course_plans$coursesArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    enrollments<T extends course_plans$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, course_plans$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the course_plans model
   */
  interface course_plansFieldRefs {
    readonly id: FieldRef<"course_plans", 'BigInt'>
    readonly course_id: FieldRef<"course_plans", 'BigInt'>
    readonly plan_type: FieldRef<"course_plans", 'plan_type'>
    readonly plan_name: FieldRef<"course_plans", 'String'>
    readonly price: FieldRef<"course_plans", 'Decimal'>
    readonly duration_days: FieldRef<"course_plans", 'Int'>
    readonly created_at: FieldRef<"course_plans", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * course_plans findUnique
   */
  export type course_plansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_plans
     */
    select?: course_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_plans
     */
    omit?: course_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_plansInclude<ExtArgs> | null
    /**
     * Filter, which course_plans to fetch.
     */
    where: course_plansWhereUniqueInput
  }

  /**
   * course_plans findUniqueOrThrow
   */
  export type course_plansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_plans
     */
    select?: course_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_plans
     */
    omit?: course_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_plansInclude<ExtArgs> | null
    /**
     * Filter, which course_plans to fetch.
     */
    where: course_plansWhereUniqueInput
  }

  /**
   * course_plans findFirst
   */
  export type course_plansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_plans
     */
    select?: course_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_plans
     */
    omit?: course_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_plansInclude<ExtArgs> | null
    /**
     * Filter, which course_plans to fetch.
     */
    where?: course_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of course_plans to fetch.
     */
    orderBy?: course_plansOrderByWithRelationInput | course_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for course_plans.
     */
    cursor?: course_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` course_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` course_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of course_plans.
     */
    distinct?: Course_plansScalarFieldEnum | Course_plansScalarFieldEnum[]
  }

  /**
   * course_plans findFirstOrThrow
   */
  export type course_plansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_plans
     */
    select?: course_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_plans
     */
    omit?: course_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_plansInclude<ExtArgs> | null
    /**
     * Filter, which course_plans to fetch.
     */
    where?: course_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of course_plans to fetch.
     */
    orderBy?: course_plansOrderByWithRelationInput | course_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for course_plans.
     */
    cursor?: course_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` course_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` course_plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of course_plans.
     */
    distinct?: Course_plansScalarFieldEnum | Course_plansScalarFieldEnum[]
  }

  /**
   * course_plans findMany
   */
  export type course_plansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_plans
     */
    select?: course_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_plans
     */
    omit?: course_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_plansInclude<ExtArgs> | null
    /**
     * Filter, which course_plans to fetch.
     */
    where?: course_plansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of course_plans to fetch.
     */
    orderBy?: course_plansOrderByWithRelationInput | course_plansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing course_plans.
     */
    cursor?: course_plansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` course_plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` course_plans.
     */
    skip?: number
    distinct?: Course_plansScalarFieldEnum | Course_plansScalarFieldEnum[]
  }

  /**
   * course_plans create
   */
  export type course_plansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_plans
     */
    select?: course_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_plans
     */
    omit?: course_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_plansInclude<ExtArgs> | null
    /**
     * The data needed to create a course_plans.
     */
    data: XOR<course_plansCreateInput, course_plansUncheckedCreateInput>
  }

  /**
   * course_plans createMany
   */
  export type course_plansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many course_plans.
     */
    data: course_plansCreateManyInput | course_plansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * course_plans createManyAndReturn
   */
  export type course_plansCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_plans
     */
    select?: course_plansSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the course_plans
     */
    omit?: course_plansOmit<ExtArgs> | null
    /**
     * The data used to create many course_plans.
     */
    data: course_plansCreateManyInput | course_plansCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_plansIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * course_plans update
   */
  export type course_plansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_plans
     */
    select?: course_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_plans
     */
    omit?: course_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_plansInclude<ExtArgs> | null
    /**
     * The data needed to update a course_plans.
     */
    data: XOR<course_plansUpdateInput, course_plansUncheckedUpdateInput>
    /**
     * Choose, which course_plans to update.
     */
    where: course_plansWhereUniqueInput
  }

  /**
   * course_plans updateMany
   */
  export type course_plansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update course_plans.
     */
    data: XOR<course_plansUpdateManyMutationInput, course_plansUncheckedUpdateManyInput>
    /**
     * Filter which course_plans to update
     */
    where?: course_plansWhereInput
    /**
     * Limit how many course_plans to update.
     */
    limit?: number
  }

  /**
   * course_plans updateManyAndReturn
   */
  export type course_plansUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_plans
     */
    select?: course_plansSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the course_plans
     */
    omit?: course_plansOmit<ExtArgs> | null
    /**
     * The data used to update course_plans.
     */
    data: XOR<course_plansUpdateManyMutationInput, course_plansUncheckedUpdateManyInput>
    /**
     * Filter which course_plans to update
     */
    where?: course_plansWhereInput
    /**
     * Limit how many course_plans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_plansIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * course_plans upsert
   */
  export type course_plansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_plans
     */
    select?: course_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_plans
     */
    omit?: course_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_plansInclude<ExtArgs> | null
    /**
     * The filter to search for the course_plans to update in case it exists.
     */
    where: course_plansWhereUniqueInput
    /**
     * In case the course_plans found by the `where` argument doesn't exist, create a new course_plans with this data.
     */
    create: XOR<course_plansCreateInput, course_plansUncheckedCreateInput>
    /**
     * In case the course_plans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<course_plansUpdateInput, course_plansUncheckedUpdateInput>
  }

  /**
   * course_plans delete
   */
  export type course_plansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_plans
     */
    select?: course_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_plans
     */
    omit?: course_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_plansInclude<ExtArgs> | null
    /**
     * Filter which course_plans to delete.
     */
    where: course_plansWhereUniqueInput
  }

  /**
   * course_plans deleteMany
   */
  export type course_plansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which course_plans to delete
     */
    where?: course_plansWhereInput
    /**
     * Limit how many course_plans to delete.
     */
    limit?: number
  }

  /**
   * course_plans.courses
   */
  export type course_plans$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    where?: coursesWhereInput
  }

  /**
   * course_plans.enrollments
   */
  export type course_plans$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    where?: enrollmentsWhereInput
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    cursor?: enrollmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * course_plans without action
   */
  export type course_plansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_plans
     */
    select?: course_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_plans
     */
    omit?: course_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_plansInclude<ExtArgs> | null
  }


  /**
   * Model course_reviews
   */

  export type AggregateCourse_reviews = {
    _count: Course_reviewsCountAggregateOutputType | null
    _avg: Course_reviewsAvgAggregateOutputType | null
    _sum: Course_reviewsSumAggregateOutputType | null
    _min: Course_reviewsMinAggregateOutputType | null
    _max: Course_reviewsMaxAggregateOutputType | null
  }

  export type Course_reviewsAvgAggregateOutputType = {
    id: number | null
    course_id: number | null
    user_id: number | null
    rating: number | null
  }

  export type Course_reviewsSumAggregateOutputType = {
    id: bigint | null
    course_id: bigint | null
    user_id: bigint | null
    rating: number | null
  }

  export type Course_reviewsMinAggregateOutputType = {
    id: bigint | null
    course_id: bigint | null
    user_id: bigint | null
    rating: number | null
    review: string | null
    created_at: Date | null
  }

  export type Course_reviewsMaxAggregateOutputType = {
    id: bigint | null
    course_id: bigint | null
    user_id: bigint | null
    rating: number | null
    review: string | null
    created_at: Date | null
  }

  export type Course_reviewsCountAggregateOutputType = {
    id: number
    course_id: number
    user_id: number
    rating: number
    review: number
    created_at: number
    _all: number
  }


  export type Course_reviewsAvgAggregateInputType = {
    id?: true
    course_id?: true
    user_id?: true
    rating?: true
  }

  export type Course_reviewsSumAggregateInputType = {
    id?: true
    course_id?: true
    user_id?: true
    rating?: true
  }

  export type Course_reviewsMinAggregateInputType = {
    id?: true
    course_id?: true
    user_id?: true
    rating?: true
    review?: true
    created_at?: true
  }

  export type Course_reviewsMaxAggregateInputType = {
    id?: true
    course_id?: true
    user_id?: true
    rating?: true
    review?: true
    created_at?: true
  }

  export type Course_reviewsCountAggregateInputType = {
    id?: true
    course_id?: true
    user_id?: true
    rating?: true
    review?: true
    created_at?: true
    _all?: true
  }

  export type Course_reviewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which course_reviews to aggregate.
     */
    where?: course_reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of course_reviews to fetch.
     */
    orderBy?: course_reviewsOrderByWithRelationInput | course_reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: course_reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` course_reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` course_reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned course_reviews
    **/
    _count?: true | Course_reviewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Course_reviewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Course_reviewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Course_reviewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Course_reviewsMaxAggregateInputType
  }

  export type GetCourse_reviewsAggregateType<T extends Course_reviewsAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse_reviews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse_reviews[P]>
      : GetScalarType<T[P], AggregateCourse_reviews[P]>
  }




  export type course_reviewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: course_reviewsWhereInput
    orderBy?: course_reviewsOrderByWithAggregationInput | course_reviewsOrderByWithAggregationInput[]
    by: Course_reviewsScalarFieldEnum[] | Course_reviewsScalarFieldEnum
    having?: course_reviewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Course_reviewsCountAggregateInputType | true
    _avg?: Course_reviewsAvgAggregateInputType
    _sum?: Course_reviewsSumAggregateInputType
    _min?: Course_reviewsMinAggregateInputType
    _max?: Course_reviewsMaxAggregateInputType
  }

  export type Course_reviewsGroupByOutputType = {
    id: bigint
    course_id: bigint | null
    user_id: bigint | null
    rating: number | null
    review: string | null
    created_at: Date | null
    _count: Course_reviewsCountAggregateOutputType | null
    _avg: Course_reviewsAvgAggregateOutputType | null
    _sum: Course_reviewsSumAggregateOutputType | null
    _min: Course_reviewsMinAggregateOutputType | null
    _max: Course_reviewsMaxAggregateOutputType | null
  }

  type GetCourse_reviewsGroupByPayload<T extends course_reviewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Course_reviewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Course_reviewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Course_reviewsGroupByOutputType[P]>
            : GetScalarType<T[P], Course_reviewsGroupByOutputType[P]>
        }
      >
    >


  export type course_reviewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    course_id?: boolean
    user_id?: boolean
    rating?: boolean
    review?: boolean
    created_at?: boolean
    courses?: boolean | course_reviews$coursesArgs<ExtArgs>
    users?: boolean | course_reviews$usersArgs<ExtArgs>
  }, ExtArgs["result"]["course_reviews"]>

  export type course_reviewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    course_id?: boolean
    user_id?: boolean
    rating?: boolean
    review?: boolean
    created_at?: boolean
    courses?: boolean | course_reviews$coursesArgs<ExtArgs>
    users?: boolean | course_reviews$usersArgs<ExtArgs>
  }, ExtArgs["result"]["course_reviews"]>

  export type course_reviewsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    course_id?: boolean
    user_id?: boolean
    rating?: boolean
    review?: boolean
    created_at?: boolean
    courses?: boolean | course_reviews$coursesArgs<ExtArgs>
    users?: boolean | course_reviews$usersArgs<ExtArgs>
  }, ExtArgs["result"]["course_reviews"]>

  export type course_reviewsSelectScalar = {
    id?: boolean
    course_id?: boolean
    user_id?: boolean
    rating?: boolean
    review?: boolean
    created_at?: boolean
  }

  export type course_reviewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "course_id" | "user_id" | "rating" | "review" | "created_at", ExtArgs["result"]["course_reviews"]>
  export type course_reviewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | course_reviews$coursesArgs<ExtArgs>
    users?: boolean | course_reviews$usersArgs<ExtArgs>
  }
  export type course_reviewsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | course_reviews$coursesArgs<ExtArgs>
    users?: boolean | course_reviews$usersArgs<ExtArgs>
  }
  export type course_reviewsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | course_reviews$coursesArgs<ExtArgs>
    users?: boolean | course_reviews$usersArgs<ExtArgs>
  }

  export type $course_reviewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "course_reviews"
    objects: {
      courses: Prisma.$coursesPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      course_id: bigint | null
      user_id: bigint | null
      rating: number | null
      review: string | null
      created_at: Date | null
    }, ExtArgs["result"]["course_reviews"]>
    composites: {}
  }

  type course_reviewsGetPayload<S extends boolean | null | undefined | course_reviewsDefaultArgs> = $Result.GetResult<Prisma.$course_reviewsPayload, S>

  type course_reviewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<course_reviewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Course_reviewsCountAggregateInputType | true
    }

  export interface course_reviewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['course_reviews'], meta: { name: 'course_reviews' } }
    /**
     * Find zero or one Course_reviews that matches the filter.
     * @param {course_reviewsFindUniqueArgs} args - Arguments to find a Course_reviews
     * @example
     * // Get one Course_reviews
     * const course_reviews = await prisma.course_reviews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends course_reviewsFindUniqueArgs>(args: SelectSubset<T, course_reviewsFindUniqueArgs<ExtArgs>>): Prisma__course_reviewsClient<$Result.GetResult<Prisma.$course_reviewsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course_reviews that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {course_reviewsFindUniqueOrThrowArgs} args - Arguments to find a Course_reviews
     * @example
     * // Get one Course_reviews
     * const course_reviews = await prisma.course_reviews.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends course_reviewsFindUniqueOrThrowArgs>(args: SelectSubset<T, course_reviewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__course_reviewsClient<$Result.GetResult<Prisma.$course_reviewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course_reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_reviewsFindFirstArgs} args - Arguments to find a Course_reviews
     * @example
     * // Get one Course_reviews
     * const course_reviews = await prisma.course_reviews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends course_reviewsFindFirstArgs>(args?: SelectSubset<T, course_reviewsFindFirstArgs<ExtArgs>>): Prisma__course_reviewsClient<$Result.GetResult<Prisma.$course_reviewsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course_reviews that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_reviewsFindFirstOrThrowArgs} args - Arguments to find a Course_reviews
     * @example
     * // Get one Course_reviews
     * const course_reviews = await prisma.course_reviews.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends course_reviewsFindFirstOrThrowArgs>(args?: SelectSubset<T, course_reviewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__course_reviewsClient<$Result.GetResult<Prisma.$course_reviewsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Course_reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_reviewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Course_reviews
     * const course_reviews = await prisma.course_reviews.findMany()
     * 
     * // Get first 10 Course_reviews
     * const course_reviews = await prisma.course_reviews.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const course_reviewsWithIdOnly = await prisma.course_reviews.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends course_reviewsFindManyArgs>(args?: SelectSubset<T, course_reviewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$course_reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course_reviews.
     * @param {course_reviewsCreateArgs} args - Arguments to create a Course_reviews.
     * @example
     * // Create one Course_reviews
     * const Course_reviews = await prisma.course_reviews.create({
     *   data: {
     *     // ... data to create a Course_reviews
     *   }
     * })
     * 
     */
    create<T extends course_reviewsCreateArgs>(args: SelectSubset<T, course_reviewsCreateArgs<ExtArgs>>): Prisma__course_reviewsClient<$Result.GetResult<Prisma.$course_reviewsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Course_reviews.
     * @param {course_reviewsCreateManyArgs} args - Arguments to create many Course_reviews.
     * @example
     * // Create many Course_reviews
     * const course_reviews = await prisma.course_reviews.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends course_reviewsCreateManyArgs>(args?: SelectSubset<T, course_reviewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Course_reviews and returns the data saved in the database.
     * @param {course_reviewsCreateManyAndReturnArgs} args - Arguments to create many Course_reviews.
     * @example
     * // Create many Course_reviews
     * const course_reviews = await prisma.course_reviews.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Course_reviews and only return the `id`
     * const course_reviewsWithIdOnly = await prisma.course_reviews.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends course_reviewsCreateManyAndReturnArgs>(args?: SelectSubset<T, course_reviewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$course_reviewsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course_reviews.
     * @param {course_reviewsDeleteArgs} args - Arguments to delete one Course_reviews.
     * @example
     * // Delete one Course_reviews
     * const Course_reviews = await prisma.course_reviews.delete({
     *   where: {
     *     // ... filter to delete one Course_reviews
     *   }
     * })
     * 
     */
    delete<T extends course_reviewsDeleteArgs>(args: SelectSubset<T, course_reviewsDeleteArgs<ExtArgs>>): Prisma__course_reviewsClient<$Result.GetResult<Prisma.$course_reviewsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course_reviews.
     * @param {course_reviewsUpdateArgs} args - Arguments to update one Course_reviews.
     * @example
     * // Update one Course_reviews
     * const course_reviews = await prisma.course_reviews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends course_reviewsUpdateArgs>(args: SelectSubset<T, course_reviewsUpdateArgs<ExtArgs>>): Prisma__course_reviewsClient<$Result.GetResult<Prisma.$course_reviewsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Course_reviews.
     * @param {course_reviewsDeleteManyArgs} args - Arguments to filter Course_reviews to delete.
     * @example
     * // Delete a few Course_reviews
     * const { count } = await prisma.course_reviews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends course_reviewsDeleteManyArgs>(args?: SelectSubset<T, course_reviewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Course_reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_reviewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Course_reviews
     * const course_reviews = await prisma.course_reviews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends course_reviewsUpdateManyArgs>(args: SelectSubset<T, course_reviewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Course_reviews and returns the data updated in the database.
     * @param {course_reviewsUpdateManyAndReturnArgs} args - Arguments to update many Course_reviews.
     * @example
     * // Update many Course_reviews
     * const course_reviews = await prisma.course_reviews.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Course_reviews and only return the `id`
     * const course_reviewsWithIdOnly = await prisma.course_reviews.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends course_reviewsUpdateManyAndReturnArgs>(args: SelectSubset<T, course_reviewsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$course_reviewsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course_reviews.
     * @param {course_reviewsUpsertArgs} args - Arguments to update or create a Course_reviews.
     * @example
     * // Update or create a Course_reviews
     * const course_reviews = await prisma.course_reviews.upsert({
     *   create: {
     *     // ... data to create a Course_reviews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course_reviews we want to update
     *   }
     * })
     */
    upsert<T extends course_reviewsUpsertArgs>(args: SelectSubset<T, course_reviewsUpsertArgs<ExtArgs>>): Prisma__course_reviewsClient<$Result.GetResult<Prisma.$course_reviewsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Course_reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_reviewsCountArgs} args - Arguments to filter Course_reviews to count.
     * @example
     * // Count the number of Course_reviews
     * const count = await prisma.course_reviews.count({
     *   where: {
     *     // ... the filter for the Course_reviews we want to count
     *   }
     * })
    **/
    count<T extends course_reviewsCountArgs>(
      args?: Subset<T, course_reviewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Course_reviewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course_reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Course_reviewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Course_reviewsAggregateArgs>(args: Subset<T, Course_reviewsAggregateArgs>): Prisma.PrismaPromise<GetCourse_reviewsAggregateType<T>>

    /**
     * Group by Course_reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_reviewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends course_reviewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: course_reviewsGroupByArgs['orderBy'] }
        : { orderBy?: course_reviewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, course_reviewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourse_reviewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the course_reviews model
   */
  readonly fields: course_reviewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for course_reviews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__course_reviewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends course_reviews$coursesArgs<ExtArgs> = {}>(args?: Subset<T, course_reviews$coursesArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends course_reviews$usersArgs<ExtArgs> = {}>(args?: Subset<T, course_reviews$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the course_reviews model
   */
  interface course_reviewsFieldRefs {
    readonly id: FieldRef<"course_reviews", 'BigInt'>
    readonly course_id: FieldRef<"course_reviews", 'BigInt'>
    readonly user_id: FieldRef<"course_reviews", 'BigInt'>
    readonly rating: FieldRef<"course_reviews", 'Int'>
    readonly review: FieldRef<"course_reviews", 'String'>
    readonly created_at: FieldRef<"course_reviews", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * course_reviews findUnique
   */
  export type course_reviewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_reviews
     */
    select?: course_reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_reviews
     */
    omit?: course_reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_reviewsInclude<ExtArgs> | null
    /**
     * Filter, which course_reviews to fetch.
     */
    where: course_reviewsWhereUniqueInput
  }

  /**
   * course_reviews findUniqueOrThrow
   */
  export type course_reviewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_reviews
     */
    select?: course_reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_reviews
     */
    omit?: course_reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_reviewsInclude<ExtArgs> | null
    /**
     * Filter, which course_reviews to fetch.
     */
    where: course_reviewsWhereUniqueInput
  }

  /**
   * course_reviews findFirst
   */
  export type course_reviewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_reviews
     */
    select?: course_reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_reviews
     */
    omit?: course_reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_reviewsInclude<ExtArgs> | null
    /**
     * Filter, which course_reviews to fetch.
     */
    where?: course_reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of course_reviews to fetch.
     */
    orderBy?: course_reviewsOrderByWithRelationInput | course_reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for course_reviews.
     */
    cursor?: course_reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` course_reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` course_reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of course_reviews.
     */
    distinct?: Course_reviewsScalarFieldEnum | Course_reviewsScalarFieldEnum[]
  }

  /**
   * course_reviews findFirstOrThrow
   */
  export type course_reviewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_reviews
     */
    select?: course_reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_reviews
     */
    omit?: course_reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_reviewsInclude<ExtArgs> | null
    /**
     * Filter, which course_reviews to fetch.
     */
    where?: course_reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of course_reviews to fetch.
     */
    orderBy?: course_reviewsOrderByWithRelationInput | course_reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for course_reviews.
     */
    cursor?: course_reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` course_reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` course_reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of course_reviews.
     */
    distinct?: Course_reviewsScalarFieldEnum | Course_reviewsScalarFieldEnum[]
  }

  /**
   * course_reviews findMany
   */
  export type course_reviewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_reviews
     */
    select?: course_reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_reviews
     */
    omit?: course_reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_reviewsInclude<ExtArgs> | null
    /**
     * Filter, which course_reviews to fetch.
     */
    where?: course_reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of course_reviews to fetch.
     */
    orderBy?: course_reviewsOrderByWithRelationInput | course_reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing course_reviews.
     */
    cursor?: course_reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` course_reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` course_reviews.
     */
    skip?: number
    distinct?: Course_reviewsScalarFieldEnum | Course_reviewsScalarFieldEnum[]
  }

  /**
   * course_reviews create
   */
  export type course_reviewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_reviews
     */
    select?: course_reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_reviews
     */
    omit?: course_reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_reviewsInclude<ExtArgs> | null
    /**
     * The data needed to create a course_reviews.
     */
    data?: XOR<course_reviewsCreateInput, course_reviewsUncheckedCreateInput>
  }

  /**
   * course_reviews createMany
   */
  export type course_reviewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many course_reviews.
     */
    data: course_reviewsCreateManyInput | course_reviewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * course_reviews createManyAndReturn
   */
  export type course_reviewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_reviews
     */
    select?: course_reviewsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the course_reviews
     */
    omit?: course_reviewsOmit<ExtArgs> | null
    /**
     * The data used to create many course_reviews.
     */
    data: course_reviewsCreateManyInput | course_reviewsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_reviewsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * course_reviews update
   */
  export type course_reviewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_reviews
     */
    select?: course_reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_reviews
     */
    omit?: course_reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_reviewsInclude<ExtArgs> | null
    /**
     * The data needed to update a course_reviews.
     */
    data: XOR<course_reviewsUpdateInput, course_reviewsUncheckedUpdateInput>
    /**
     * Choose, which course_reviews to update.
     */
    where: course_reviewsWhereUniqueInput
  }

  /**
   * course_reviews updateMany
   */
  export type course_reviewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update course_reviews.
     */
    data: XOR<course_reviewsUpdateManyMutationInput, course_reviewsUncheckedUpdateManyInput>
    /**
     * Filter which course_reviews to update
     */
    where?: course_reviewsWhereInput
    /**
     * Limit how many course_reviews to update.
     */
    limit?: number
  }

  /**
   * course_reviews updateManyAndReturn
   */
  export type course_reviewsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_reviews
     */
    select?: course_reviewsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the course_reviews
     */
    omit?: course_reviewsOmit<ExtArgs> | null
    /**
     * The data used to update course_reviews.
     */
    data: XOR<course_reviewsUpdateManyMutationInput, course_reviewsUncheckedUpdateManyInput>
    /**
     * Filter which course_reviews to update
     */
    where?: course_reviewsWhereInput
    /**
     * Limit how many course_reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_reviewsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * course_reviews upsert
   */
  export type course_reviewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_reviews
     */
    select?: course_reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_reviews
     */
    omit?: course_reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_reviewsInclude<ExtArgs> | null
    /**
     * The filter to search for the course_reviews to update in case it exists.
     */
    where: course_reviewsWhereUniqueInput
    /**
     * In case the course_reviews found by the `where` argument doesn't exist, create a new course_reviews with this data.
     */
    create: XOR<course_reviewsCreateInput, course_reviewsUncheckedCreateInput>
    /**
     * In case the course_reviews was found with the provided `where` argument, update it with this data.
     */
    update: XOR<course_reviewsUpdateInput, course_reviewsUncheckedUpdateInput>
  }

  /**
   * course_reviews delete
   */
  export type course_reviewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_reviews
     */
    select?: course_reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_reviews
     */
    omit?: course_reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_reviewsInclude<ExtArgs> | null
    /**
     * Filter which course_reviews to delete.
     */
    where: course_reviewsWhereUniqueInput
  }

  /**
   * course_reviews deleteMany
   */
  export type course_reviewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which course_reviews to delete
     */
    where?: course_reviewsWhereInput
    /**
     * Limit how many course_reviews to delete.
     */
    limit?: number
  }

  /**
   * course_reviews.courses
   */
  export type course_reviews$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    where?: coursesWhereInput
  }

  /**
   * course_reviews.users
   */
  export type course_reviews$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * course_reviews without action
   */
  export type course_reviewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_reviews
     */
    select?: course_reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_reviews
     */
    omit?: course_reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_reviewsInclude<ExtArgs> | null
  }


  /**
   * Model course_videos
   */

  export type AggregateCourse_videos = {
    _count: Course_videosCountAggregateOutputType | null
    _avg: Course_videosAvgAggregateOutputType | null
    _sum: Course_videosSumAggregateOutputType | null
    _min: Course_videosMinAggregateOutputType | null
    _max: Course_videosMaxAggregateOutputType | null
  }

  export type Course_videosAvgAggregateOutputType = {
    id: number | null
    course_id: number | null
    position: number | null
  }

  export type Course_videosSumAggregateOutputType = {
    id: bigint | null
    course_id: bigint | null
    position: number | null
  }

  export type Course_videosMinAggregateOutputType = {
    id: bigint | null
    course_id: bigint | null
    title: string | null
    video_url: string | null
    position: number | null
    is_demo: boolean | null
    created_at: Date | null
  }

  export type Course_videosMaxAggregateOutputType = {
    id: bigint | null
    course_id: bigint | null
    title: string | null
    video_url: string | null
    position: number | null
    is_demo: boolean | null
    created_at: Date | null
  }

  export type Course_videosCountAggregateOutputType = {
    id: number
    course_id: number
    title: number
    video_url: number
    position: number
    is_demo: number
    created_at: number
    _all: number
  }


  export type Course_videosAvgAggregateInputType = {
    id?: true
    course_id?: true
    position?: true
  }

  export type Course_videosSumAggregateInputType = {
    id?: true
    course_id?: true
    position?: true
  }

  export type Course_videosMinAggregateInputType = {
    id?: true
    course_id?: true
    title?: true
    video_url?: true
    position?: true
    is_demo?: true
    created_at?: true
  }

  export type Course_videosMaxAggregateInputType = {
    id?: true
    course_id?: true
    title?: true
    video_url?: true
    position?: true
    is_demo?: true
    created_at?: true
  }

  export type Course_videosCountAggregateInputType = {
    id?: true
    course_id?: true
    title?: true
    video_url?: true
    position?: true
    is_demo?: true
    created_at?: true
    _all?: true
  }

  export type Course_videosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which course_videos to aggregate.
     */
    where?: course_videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of course_videos to fetch.
     */
    orderBy?: course_videosOrderByWithRelationInput | course_videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: course_videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` course_videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` course_videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned course_videos
    **/
    _count?: true | Course_videosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Course_videosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Course_videosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Course_videosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Course_videosMaxAggregateInputType
  }

  export type GetCourse_videosAggregateType<T extends Course_videosAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse_videos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse_videos[P]>
      : GetScalarType<T[P], AggregateCourse_videos[P]>
  }




  export type course_videosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: course_videosWhereInput
    orderBy?: course_videosOrderByWithAggregationInput | course_videosOrderByWithAggregationInput[]
    by: Course_videosScalarFieldEnum[] | Course_videosScalarFieldEnum
    having?: course_videosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Course_videosCountAggregateInputType | true
    _avg?: Course_videosAvgAggregateInputType
    _sum?: Course_videosSumAggregateInputType
    _min?: Course_videosMinAggregateInputType
    _max?: Course_videosMaxAggregateInputType
  }

  export type Course_videosGroupByOutputType = {
    id: bigint
    course_id: bigint | null
    title: string
    video_url: string
    position: number
    is_demo: boolean | null
    created_at: Date | null
    _count: Course_videosCountAggregateOutputType | null
    _avg: Course_videosAvgAggregateOutputType | null
    _sum: Course_videosSumAggregateOutputType | null
    _min: Course_videosMinAggregateOutputType | null
    _max: Course_videosMaxAggregateOutputType | null
  }

  type GetCourse_videosGroupByPayload<T extends course_videosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Course_videosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Course_videosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Course_videosGroupByOutputType[P]>
            : GetScalarType<T[P], Course_videosGroupByOutputType[P]>
        }
      >
    >


  export type course_videosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    course_id?: boolean
    title?: boolean
    video_url?: boolean
    position?: boolean
    is_demo?: boolean
    created_at?: boolean
    courses?: boolean | course_videos$coursesArgs<ExtArgs>
  }, ExtArgs["result"]["course_videos"]>

  export type course_videosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    course_id?: boolean
    title?: boolean
    video_url?: boolean
    position?: boolean
    is_demo?: boolean
    created_at?: boolean
    courses?: boolean | course_videos$coursesArgs<ExtArgs>
  }, ExtArgs["result"]["course_videos"]>

  export type course_videosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    course_id?: boolean
    title?: boolean
    video_url?: boolean
    position?: boolean
    is_demo?: boolean
    created_at?: boolean
    courses?: boolean | course_videos$coursesArgs<ExtArgs>
  }, ExtArgs["result"]["course_videos"]>

  export type course_videosSelectScalar = {
    id?: boolean
    course_id?: boolean
    title?: boolean
    video_url?: boolean
    position?: boolean
    is_demo?: boolean
    created_at?: boolean
  }

  export type course_videosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "course_id" | "title" | "video_url" | "position" | "is_demo" | "created_at", ExtArgs["result"]["course_videos"]>
  export type course_videosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | course_videos$coursesArgs<ExtArgs>
  }
  export type course_videosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | course_videos$coursesArgs<ExtArgs>
  }
  export type course_videosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | course_videos$coursesArgs<ExtArgs>
  }

  export type $course_videosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "course_videos"
    objects: {
      courses: Prisma.$coursesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      course_id: bigint | null
      title: string
      video_url: string
      position: number
      is_demo: boolean | null
      created_at: Date | null
    }, ExtArgs["result"]["course_videos"]>
    composites: {}
  }

  type course_videosGetPayload<S extends boolean | null | undefined | course_videosDefaultArgs> = $Result.GetResult<Prisma.$course_videosPayload, S>

  type course_videosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<course_videosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Course_videosCountAggregateInputType | true
    }

  export interface course_videosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['course_videos'], meta: { name: 'course_videos' } }
    /**
     * Find zero or one Course_videos that matches the filter.
     * @param {course_videosFindUniqueArgs} args - Arguments to find a Course_videos
     * @example
     * // Get one Course_videos
     * const course_videos = await prisma.course_videos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends course_videosFindUniqueArgs>(args: SelectSubset<T, course_videosFindUniqueArgs<ExtArgs>>): Prisma__course_videosClient<$Result.GetResult<Prisma.$course_videosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Course_videos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {course_videosFindUniqueOrThrowArgs} args - Arguments to find a Course_videos
     * @example
     * // Get one Course_videos
     * const course_videos = await prisma.course_videos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends course_videosFindUniqueOrThrowArgs>(args: SelectSubset<T, course_videosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__course_videosClient<$Result.GetResult<Prisma.$course_videosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course_videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_videosFindFirstArgs} args - Arguments to find a Course_videos
     * @example
     * // Get one Course_videos
     * const course_videos = await prisma.course_videos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends course_videosFindFirstArgs>(args?: SelectSubset<T, course_videosFindFirstArgs<ExtArgs>>): Prisma__course_videosClient<$Result.GetResult<Prisma.$course_videosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Course_videos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_videosFindFirstOrThrowArgs} args - Arguments to find a Course_videos
     * @example
     * // Get one Course_videos
     * const course_videos = await prisma.course_videos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends course_videosFindFirstOrThrowArgs>(args?: SelectSubset<T, course_videosFindFirstOrThrowArgs<ExtArgs>>): Prisma__course_videosClient<$Result.GetResult<Prisma.$course_videosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Course_videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_videosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Course_videos
     * const course_videos = await prisma.course_videos.findMany()
     * 
     * // Get first 10 Course_videos
     * const course_videos = await prisma.course_videos.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const course_videosWithIdOnly = await prisma.course_videos.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends course_videosFindManyArgs>(args?: SelectSubset<T, course_videosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$course_videosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Course_videos.
     * @param {course_videosCreateArgs} args - Arguments to create a Course_videos.
     * @example
     * // Create one Course_videos
     * const Course_videos = await prisma.course_videos.create({
     *   data: {
     *     // ... data to create a Course_videos
     *   }
     * })
     * 
     */
    create<T extends course_videosCreateArgs>(args: SelectSubset<T, course_videosCreateArgs<ExtArgs>>): Prisma__course_videosClient<$Result.GetResult<Prisma.$course_videosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Course_videos.
     * @param {course_videosCreateManyArgs} args - Arguments to create many Course_videos.
     * @example
     * // Create many Course_videos
     * const course_videos = await prisma.course_videos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends course_videosCreateManyArgs>(args?: SelectSubset<T, course_videosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Course_videos and returns the data saved in the database.
     * @param {course_videosCreateManyAndReturnArgs} args - Arguments to create many Course_videos.
     * @example
     * // Create many Course_videos
     * const course_videos = await prisma.course_videos.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Course_videos and only return the `id`
     * const course_videosWithIdOnly = await prisma.course_videos.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends course_videosCreateManyAndReturnArgs>(args?: SelectSubset<T, course_videosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$course_videosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Course_videos.
     * @param {course_videosDeleteArgs} args - Arguments to delete one Course_videos.
     * @example
     * // Delete one Course_videos
     * const Course_videos = await prisma.course_videos.delete({
     *   where: {
     *     // ... filter to delete one Course_videos
     *   }
     * })
     * 
     */
    delete<T extends course_videosDeleteArgs>(args: SelectSubset<T, course_videosDeleteArgs<ExtArgs>>): Prisma__course_videosClient<$Result.GetResult<Prisma.$course_videosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Course_videos.
     * @param {course_videosUpdateArgs} args - Arguments to update one Course_videos.
     * @example
     * // Update one Course_videos
     * const course_videos = await prisma.course_videos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends course_videosUpdateArgs>(args: SelectSubset<T, course_videosUpdateArgs<ExtArgs>>): Prisma__course_videosClient<$Result.GetResult<Prisma.$course_videosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Course_videos.
     * @param {course_videosDeleteManyArgs} args - Arguments to filter Course_videos to delete.
     * @example
     * // Delete a few Course_videos
     * const { count } = await prisma.course_videos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends course_videosDeleteManyArgs>(args?: SelectSubset<T, course_videosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Course_videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_videosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Course_videos
     * const course_videos = await prisma.course_videos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends course_videosUpdateManyArgs>(args: SelectSubset<T, course_videosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Course_videos and returns the data updated in the database.
     * @param {course_videosUpdateManyAndReturnArgs} args - Arguments to update many Course_videos.
     * @example
     * // Update many Course_videos
     * const course_videos = await prisma.course_videos.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Course_videos and only return the `id`
     * const course_videosWithIdOnly = await prisma.course_videos.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends course_videosUpdateManyAndReturnArgs>(args: SelectSubset<T, course_videosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$course_videosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Course_videos.
     * @param {course_videosUpsertArgs} args - Arguments to update or create a Course_videos.
     * @example
     * // Update or create a Course_videos
     * const course_videos = await prisma.course_videos.upsert({
     *   create: {
     *     // ... data to create a Course_videos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course_videos we want to update
     *   }
     * })
     */
    upsert<T extends course_videosUpsertArgs>(args: SelectSubset<T, course_videosUpsertArgs<ExtArgs>>): Prisma__course_videosClient<$Result.GetResult<Prisma.$course_videosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Course_videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_videosCountArgs} args - Arguments to filter Course_videos to count.
     * @example
     * // Count the number of Course_videos
     * const count = await prisma.course_videos.count({
     *   where: {
     *     // ... the filter for the Course_videos we want to count
     *   }
     * })
    **/
    count<T extends course_videosCountArgs>(
      args?: Subset<T, course_videosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Course_videosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course_videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Course_videosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Course_videosAggregateArgs>(args: Subset<T, Course_videosAggregateArgs>): Prisma.PrismaPromise<GetCourse_videosAggregateType<T>>

    /**
     * Group by Course_videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {course_videosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends course_videosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: course_videosGroupByArgs['orderBy'] }
        : { orderBy?: course_videosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, course_videosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourse_videosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the course_videos model
   */
  readonly fields: course_videosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for course_videos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__course_videosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends course_videos$coursesArgs<ExtArgs> = {}>(args?: Subset<T, course_videos$coursesArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the course_videos model
   */
  interface course_videosFieldRefs {
    readonly id: FieldRef<"course_videos", 'BigInt'>
    readonly course_id: FieldRef<"course_videos", 'BigInt'>
    readonly title: FieldRef<"course_videos", 'String'>
    readonly video_url: FieldRef<"course_videos", 'String'>
    readonly position: FieldRef<"course_videos", 'Int'>
    readonly is_demo: FieldRef<"course_videos", 'Boolean'>
    readonly created_at: FieldRef<"course_videos", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * course_videos findUnique
   */
  export type course_videosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_videos
     */
    select?: course_videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_videos
     */
    omit?: course_videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_videosInclude<ExtArgs> | null
    /**
     * Filter, which course_videos to fetch.
     */
    where: course_videosWhereUniqueInput
  }

  /**
   * course_videos findUniqueOrThrow
   */
  export type course_videosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_videos
     */
    select?: course_videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_videos
     */
    omit?: course_videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_videosInclude<ExtArgs> | null
    /**
     * Filter, which course_videos to fetch.
     */
    where: course_videosWhereUniqueInput
  }

  /**
   * course_videos findFirst
   */
  export type course_videosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_videos
     */
    select?: course_videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_videos
     */
    omit?: course_videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_videosInclude<ExtArgs> | null
    /**
     * Filter, which course_videos to fetch.
     */
    where?: course_videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of course_videos to fetch.
     */
    orderBy?: course_videosOrderByWithRelationInput | course_videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for course_videos.
     */
    cursor?: course_videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` course_videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` course_videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of course_videos.
     */
    distinct?: Course_videosScalarFieldEnum | Course_videosScalarFieldEnum[]
  }

  /**
   * course_videos findFirstOrThrow
   */
  export type course_videosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_videos
     */
    select?: course_videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_videos
     */
    omit?: course_videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_videosInclude<ExtArgs> | null
    /**
     * Filter, which course_videos to fetch.
     */
    where?: course_videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of course_videos to fetch.
     */
    orderBy?: course_videosOrderByWithRelationInput | course_videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for course_videos.
     */
    cursor?: course_videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` course_videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` course_videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of course_videos.
     */
    distinct?: Course_videosScalarFieldEnum | Course_videosScalarFieldEnum[]
  }

  /**
   * course_videos findMany
   */
  export type course_videosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_videos
     */
    select?: course_videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_videos
     */
    omit?: course_videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_videosInclude<ExtArgs> | null
    /**
     * Filter, which course_videos to fetch.
     */
    where?: course_videosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of course_videos to fetch.
     */
    orderBy?: course_videosOrderByWithRelationInput | course_videosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing course_videos.
     */
    cursor?: course_videosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` course_videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` course_videos.
     */
    skip?: number
    distinct?: Course_videosScalarFieldEnum | Course_videosScalarFieldEnum[]
  }

  /**
   * course_videos create
   */
  export type course_videosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_videos
     */
    select?: course_videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_videos
     */
    omit?: course_videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_videosInclude<ExtArgs> | null
    /**
     * The data needed to create a course_videos.
     */
    data: XOR<course_videosCreateInput, course_videosUncheckedCreateInput>
  }

  /**
   * course_videos createMany
   */
  export type course_videosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many course_videos.
     */
    data: course_videosCreateManyInput | course_videosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * course_videos createManyAndReturn
   */
  export type course_videosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_videos
     */
    select?: course_videosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the course_videos
     */
    omit?: course_videosOmit<ExtArgs> | null
    /**
     * The data used to create many course_videos.
     */
    data: course_videosCreateManyInput | course_videosCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_videosIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * course_videos update
   */
  export type course_videosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_videos
     */
    select?: course_videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_videos
     */
    omit?: course_videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_videosInclude<ExtArgs> | null
    /**
     * The data needed to update a course_videos.
     */
    data: XOR<course_videosUpdateInput, course_videosUncheckedUpdateInput>
    /**
     * Choose, which course_videos to update.
     */
    where: course_videosWhereUniqueInput
  }

  /**
   * course_videos updateMany
   */
  export type course_videosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update course_videos.
     */
    data: XOR<course_videosUpdateManyMutationInput, course_videosUncheckedUpdateManyInput>
    /**
     * Filter which course_videos to update
     */
    where?: course_videosWhereInput
    /**
     * Limit how many course_videos to update.
     */
    limit?: number
  }

  /**
   * course_videos updateManyAndReturn
   */
  export type course_videosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_videos
     */
    select?: course_videosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the course_videos
     */
    omit?: course_videosOmit<ExtArgs> | null
    /**
     * The data used to update course_videos.
     */
    data: XOR<course_videosUpdateManyMutationInput, course_videosUncheckedUpdateManyInput>
    /**
     * Filter which course_videos to update
     */
    where?: course_videosWhereInput
    /**
     * Limit how many course_videos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_videosIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * course_videos upsert
   */
  export type course_videosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_videos
     */
    select?: course_videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_videos
     */
    omit?: course_videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_videosInclude<ExtArgs> | null
    /**
     * The filter to search for the course_videos to update in case it exists.
     */
    where: course_videosWhereUniqueInput
    /**
     * In case the course_videos found by the `where` argument doesn't exist, create a new course_videos with this data.
     */
    create: XOR<course_videosCreateInput, course_videosUncheckedCreateInput>
    /**
     * In case the course_videos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<course_videosUpdateInput, course_videosUncheckedUpdateInput>
  }

  /**
   * course_videos delete
   */
  export type course_videosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_videos
     */
    select?: course_videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_videos
     */
    omit?: course_videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_videosInclude<ExtArgs> | null
    /**
     * Filter which course_videos to delete.
     */
    where: course_videosWhereUniqueInput
  }

  /**
   * course_videos deleteMany
   */
  export type course_videosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which course_videos to delete
     */
    where?: course_videosWhereInput
    /**
     * Limit how many course_videos to delete.
     */
    limit?: number
  }

  /**
   * course_videos.courses
   */
  export type course_videos$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    where?: coursesWhereInput
  }

  /**
   * course_videos without action
   */
  export type course_videosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_videos
     */
    select?: course_videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_videos
     */
    omit?: course_videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_videosInclude<ExtArgs> | null
  }


  /**
   * Model courses
   */

  export type AggregateCourses = {
    _count: CoursesCountAggregateOutputType | null
    _avg: CoursesAvgAggregateOutputType | null
    _sum: CoursesSumAggregateOutputType | null
    _min: CoursesMinAggregateOutputType | null
    _max: CoursesMaxAggregateOutputType | null
  }

  export type CoursesAvgAggregateOutputType = {
    id: number | null
  }

  export type CoursesSumAggregateOutputType = {
    id: bigint | null
  }

  export type CoursesMinAggregateOutputType = {
    id: bigint | null
    title: string | null
    description: string | null
    thumbnail_url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CoursesMaxAggregateOutputType = {
    id: bigint | null
    title: string | null
    description: string | null
    thumbnail_url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CoursesCountAggregateOutputType = {
    id: number
    title: number
    description: number
    thumbnail_url: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CoursesAvgAggregateInputType = {
    id?: true
  }

  export type CoursesSumAggregateInputType = {
    id?: true
  }

  export type CoursesMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail_url?: true
    created_at?: true
    updated_at?: true
  }

  export type CoursesMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail_url?: true
    created_at?: true
    updated_at?: true
  }

  export type CoursesCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    thumbnail_url?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CoursesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which courses to aggregate.
     */
    where?: coursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     */
    orderBy?: coursesOrderByWithRelationInput | coursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: coursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned courses
    **/
    _count?: true | CoursesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoursesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoursesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoursesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoursesMaxAggregateInputType
  }

  export type GetCoursesAggregateType<T extends CoursesAggregateArgs> = {
        [P in keyof T & keyof AggregateCourses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourses[P]>
      : GetScalarType<T[P], AggregateCourses[P]>
  }




  export type coursesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: coursesWhereInput
    orderBy?: coursesOrderByWithAggregationInput | coursesOrderByWithAggregationInput[]
    by: CoursesScalarFieldEnum[] | CoursesScalarFieldEnum
    having?: coursesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoursesCountAggregateInputType | true
    _avg?: CoursesAvgAggregateInputType
    _sum?: CoursesSumAggregateInputType
    _min?: CoursesMinAggregateInputType
    _max?: CoursesMaxAggregateInputType
  }

  export type CoursesGroupByOutputType = {
    id: bigint
    title: string
    description: string | null
    thumbnail_url: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: CoursesCountAggregateOutputType | null
    _avg: CoursesAvgAggregateOutputType | null
    _sum: CoursesSumAggregateOutputType | null
    _min: CoursesMinAggregateOutputType | null
    _max: CoursesMaxAggregateOutputType | null
  }

  type GetCoursesGroupByPayload<T extends coursesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoursesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoursesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoursesGroupByOutputType[P]>
            : GetScalarType<T[P], CoursesGroupByOutputType[P]>
        }
      >
    >


  export type coursesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    course_plans?: boolean | courses$course_plansArgs<ExtArgs>
    course_reviews?: boolean | courses$course_reviewsArgs<ExtArgs>
    course_videos?: boolean | courses$course_videosArgs<ExtArgs>
    enrollments?: boolean | courses$enrollmentsArgs<ExtArgs>
    payments?: boolean | courses$paymentsArgs<ExtArgs>
    _count?: boolean | CoursesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courses"]>

  export type coursesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail_url?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["courses"]>

  export type coursesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail_url?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["courses"]>

  export type coursesSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    thumbnail_url?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type coursesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "thumbnail_url" | "created_at" | "updated_at", ExtArgs["result"]["courses"]>
  export type coursesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course_plans?: boolean | courses$course_plansArgs<ExtArgs>
    course_reviews?: boolean | courses$course_reviewsArgs<ExtArgs>
    course_videos?: boolean | courses$course_videosArgs<ExtArgs>
    enrollments?: boolean | courses$enrollmentsArgs<ExtArgs>
    payments?: boolean | courses$paymentsArgs<ExtArgs>
    _count?: boolean | CoursesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type coursesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type coursesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $coursesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "courses"
    objects: {
      course_plans: Prisma.$course_plansPayload<ExtArgs>[]
      course_reviews: Prisma.$course_reviewsPayload<ExtArgs>[]
      course_videos: Prisma.$course_videosPayload<ExtArgs>[]
      enrollments: Prisma.$enrollmentsPayload<ExtArgs>[]
      payments: Prisma.$paymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      title: string
      description: string | null
      thumbnail_url: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["courses"]>
    composites: {}
  }

  type coursesGetPayload<S extends boolean | null | undefined | coursesDefaultArgs> = $Result.GetResult<Prisma.$coursesPayload, S>

  type coursesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<coursesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CoursesCountAggregateInputType | true
    }

  export interface coursesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['courses'], meta: { name: 'courses' } }
    /**
     * Find zero or one Courses that matches the filter.
     * @param {coursesFindUniqueArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends coursesFindUniqueArgs>(args: SelectSubset<T, coursesFindUniqueArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Courses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {coursesFindUniqueOrThrowArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends coursesFindUniqueOrThrowArgs>(args: SelectSubset<T, coursesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesFindFirstArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends coursesFindFirstArgs>(args?: SelectSubset<T, coursesFindFirstArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Courses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesFindFirstOrThrowArgs} args - Arguments to find a Courses
     * @example
     * // Get one Courses
     * const courses = await prisma.courses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends coursesFindFirstOrThrowArgs>(args?: SelectSubset<T, coursesFindFirstOrThrowArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.courses.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.courses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coursesWithIdOnly = await prisma.courses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends coursesFindManyArgs>(args?: SelectSubset<T, coursesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Courses.
     * @param {coursesCreateArgs} args - Arguments to create a Courses.
     * @example
     * // Create one Courses
     * const Courses = await prisma.courses.create({
     *   data: {
     *     // ... data to create a Courses
     *   }
     * })
     * 
     */
    create<T extends coursesCreateArgs>(args: SelectSubset<T, coursesCreateArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Courses.
     * @param {coursesCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const courses = await prisma.courses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends coursesCreateManyArgs>(args?: SelectSubset<T, coursesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {coursesCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const courses = await prisma.courses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const coursesWithIdOnly = await prisma.courses.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends coursesCreateManyAndReturnArgs>(args?: SelectSubset<T, coursesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Courses.
     * @param {coursesDeleteArgs} args - Arguments to delete one Courses.
     * @example
     * // Delete one Courses
     * const Courses = await prisma.courses.delete({
     *   where: {
     *     // ... filter to delete one Courses
     *   }
     * })
     * 
     */
    delete<T extends coursesDeleteArgs>(args: SelectSubset<T, coursesDeleteArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Courses.
     * @param {coursesUpdateArgs} args - Arguments to update one Courses.
     * @example
     * // Update one Courses
     * const courses = await prisma.courses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends coursesUpdateArgs>(args: SelectSubset<T, coursesUpdateArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Courses.
     * @param {coursesDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.courses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends coursesDeleteManyArgs>(args?: SelectSubset<T, coursesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const courses = await prisma.courses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends coursesUpdateManyArgs>(args: SelectSubset<T, coursesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses and returns the data updated in the database.
     * @param {coursesUpdateManyAndReturnArgs} args - Arguments to update many Courses.
     * @example
     * // Update many Courses
     * const courses = await prisma.courses.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Courses and only return the `id`
     * const coursesWithIdOnly = await prisma.courses.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends coursesUpdateManyAndReturnArgs>(args: SelectSubset<T, coursesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Courses.
     * @param {coursesUpsertArgs} args - Arguments to update or create a Courses.
     * @example
     * // Update or create a Courses
     * const courses = await prisma.courses.upsert({
     *   create: {
     *     // ... data to create a Courses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Courses we want to update
     *   }
     * })
     */
    upsert<T extends coursesUpsertArgs>(args: SelectSubset<T, coursesUpsertArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.courses.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends coursesCountArgs>(
      args?: Subset<T, coursesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoursesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoursesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoursesAggregateArgs>(args: Subset<T, CoursesAggregateArgs>): Prisma.PrismaPromise<GetCoursesAggregateType<T>>

    /**
     * Group by Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {coursesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends coursesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: coursesGroupByArgs['orderBy'] }
        : { orderBy?: coursesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, coursesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoursesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the courses model
   */
  readonly fields: coursesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for courses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__coursesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course_plans<T extends courses$course_plansArgs<ExtArgs> = {}>(args?: Subset<T, courses$course_plansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$course_plansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    course_reviews<T extends courses$course_reviewsArgs<ExtArgs> = {}>(args?: Subset<T, courses$course_reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$course_reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    course_videos<T extends courses$course_videosArgs<ExtArgs> = {}>(args?: Subset<T, courses$course_videosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$course_videosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends courses$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, courses$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends courses$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, courses$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the courses model
   */
  interface coursesFieldRefs {
    readonly id: FieldRef<"courses", 'BigInt'>
    readonly title: FieldRef<"courses", 'String'>
    readonly description: FieldRef<"courses", 'String'>
    readonly thumbnail_url: FieldRef<"courses", 'String'>
    readonly created_at: FieldRef<"courses", 'DateTime'>
    readonly updated_at: FieldRef<"courses", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * courses findUnique
   */
  export type coursesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter, which courses to fetch.
     */
    where: coursesWhereUniqueInput
  }

  /**
   * courses findUniqueOrThrow
   */
  export type coursesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter, which courses to fetch.
     */
    where: coursesWhereUniqueInput
  }

  /**
   * courses findFirst
   */
  export type coursesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter, which courses to fetch.
     */
    where?: coursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     */
    orderBy?: coursesOrderByWithRelationInput | coursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for courses.
     */
    cursor?: coursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of courses.
     */
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * courses findFirstOrThrow
   */
  export type coursesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter, which courses to fetch.
     */
    where?: coursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     */
    orderBy?: coursesOrderByWithRelationInput | coursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for courses.
     */
    cursor?: coursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of courses.
     */
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * courses findMany
   */
  export type coursesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter, which courses to fetch.
     */
    where?: coursesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of courses to fetch.
     */
    orderBy?: coursesOrderByWithRelationInput | coursesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing courses.
     */
    cursor?: coursesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` courses.
     */
    skip?: number
    distinct?: CoursesScalarFieldEnum | CoursesScalarFieldEnum[]
  }

  /**
   * courses create
   */
  export type coursesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * The data needed to create a courses.
     */
    data: XOR<coursesCreateInput, coursesUncheckedCreateInput>
  }

  /**
   * courses createMany
   */
  export type coursesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many courses.
     */
    data: coursesCreateManyInput | coursesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * courses createManyAndReturn
   */
  export type coursesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * The data used to create many courses.
     */
    data: coursesCreateManyInput | coursesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * courses update
   */
  export type coursesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * The data needed to update a courses.
     */
    data: XOR<coursesUpdateInput, coursesUncheckedUpdateInput>
    /**
     * Choose, which courses to update.
     */
    where: coursesWhereUniqueInput
  }

  /**
   * courses updateMany
   */
  export type coursesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update courses.
     */
    data: XOR<coursesUpdateManyMutationInput, coursesUncheckedUpdateManyInput>
    /**
     * Filter which courses to update
     */
    where?: coursesWhereInput
    /**
     * Limit how many courses to update.
     */
    limit?: number
  }

  /**
   * courses updateManyAndReturn
   */
  export type coursesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * The data used to update courses.
     */
    data: XOR<coursesUpdateManyMutationInput, coursesUncheckedUpdateManyInput>
    /**
     * Filter which courses to update
     */
    where?: coursesWhereInput
    /**
     * Limit how many courses to update.
     */
    limit?: number
  }

  /**
   * courses upsert
   */
  export type coursesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * The filter to search for the courses to update in case it exists.
     */
    where: coursesWhereUniqueInput
    /**
     * In case the courses found by the `where` argument doesn't exist, create a new courses with this data.
     */
    create: XOR<coursesCreateInput, coursesUncheckedCreateInput>
    /**
     * In case the courses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<coursesUpdateInput, coursesUncheckedUpdateInput>
  }

  /**
   * courses delete
   */
  export type coursesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    /**
     * Filter which courses to delete.
     */
    where: coursesWhereUniqueInput
  }

  /**
   * courses deleteMany
   */
  export type coursesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which courses to delete
     */
    where?: coursesWhereInput
    /**
     * Limit how many courses to delete.
     */
    limit?: number
  }

  /**
   * courses.course_plans
   */
  export type courses$course_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_plans
     */
    select?: course_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_plans
     */
    omit?: course_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_plansInclude<ExtArgs> | null
    where?: course_plansWhereInput
    orderBy?: course_plansOrderByWithRelationInput | course_plansOrderByWithRelationInput[]
    cursor?: course_plansWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Course_plansScalarFieldEnum | Course_plansScalarFieldEnum[]
  }

  /**
   * courses.course_reviews
   */
  export type courses$course_reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_reviews
     */
    select?: course_reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_reviews
     */
    omit?: course_reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_reviewsInclude<ExtArgs> | null
    where?: course_reviewsWhereInput
    orderBy?: course_reviewsOrderByWithRelationInput | course_reviewsOrderByWithRelationInput[]
    cursor?: course_reviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Course_reviewsScalarFieldEnum | Course_reviewsScalarFieldEnum[]
  }

  /**
   * courses.course_videos
   */
  export type courses$course_videosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_videos
     */
    select?: course_videosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_videos
     */
    omit?: course_videosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_videosInclude<ExtArgs> | null
    where?: course_videosWhereInput
    orderBy?: course_videosOrderByWithRelationInput | course_videosOrderByWithRelationInput[]
    cursor?: course_videosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Course_videosScalarFieldEnum | Course_videosScalarFieldEnum[]
  }

  /**
   * courses.enrollments
   */
  export type courses$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    where?: enrollmentsWhereInput
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    cursor?: enrollmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * courses.payments
   */
  export type courses$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * courses without action
   */
  export type coursesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
  }


  /**
   * Model enrollments
   */

  export type AggregateEnrollments = {
    _count: EnrollmentsCountAggregateOutputType | null
    _avg: EnrollmentsAvgAggregateOutputType | null
    _sum: EnrollmentsSumAggregateOutputType | null
    _min: EnrollmentsMinAggregateOutputType | null
    _max: EnrollmentsMaxAggregateOutputType | null
  }

  export type EnrollmentsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    course_id: number | null
    plan_id: number | null
  }

  export type EnrollmentsSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    plan_id: bigint | null
  }

  export type EnrollmentsMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    plan_id: bigint | null
    status: $Enums.enrollment_status | null
    started_at: Date | null
    expires_at: Date | null
  }

  export type EnrollmentsMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    plan_id: bigint | null
    status: $Enums.enrollment_status | null
    started_at: Date | null
    expires_at: Date | null
  }

  export type EnrollmentsCountAggregateOutputType = {
    id: number
    user_id: number
    course_id: number
    plan_id: number
    status: number
    started_at: number
    expires_at: number
    _all: number
  }


  export type EnrollmentsAvgAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    plan_id?: true
  }

  export type EnrollmentsSumAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    plan_id?: true
  }

  export type EnrollmentsMinAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    plan_id?: true
    status?: true
    started_at?: true
    expires_at?: true
  }

  export type EnrollmentsMaxAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    plan_id?: true
    status?: true
    started_at?: true
    expires_at?: true
  }

  export type EnrollmentsCountAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    plan_id?: true
    status?: true
    started_at?: true
    expires_at?: true
    _all?: true
  }

  export type EnrollmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which enrollments to aggregate.
     */
    where?: enrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     */
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: enrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned enrollments
    **/
    _count?: true | EnrollmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnrollmentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnrollmentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnrollmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnrollmentsMaxAggregateInputType
  }

  export type GetEnrollmentsAggregateType<T extends EnrollmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateEnrollments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnrollments[P]>
      : GetScalarType<T[P], AggregateEnrollments[P]>
  }




  export type enrollmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: enrollmentsWhereInput
    orderBy?: enrollmentsOrderByWithAggregationInput | enrollmentsOrderByWithAggregationInput[]
    by: EnrollmentsScalarFieldEnum[] | EnrollmentsScalarFieldEnum
    having?: enrollmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnrollmentsCountAggregateInputType | true
    _avg?: EnrollmentsAvgAggregateInputType
    _sum?: EnrollmentsSumAggregateInputType
    _min?: EnrollmentsMinAggregateInputType
    _max?: EnrollmentsMaxAggregateInputType
  }

  export type EnrollmentsGroupByOutputType = {
    id: bigint
    user_id: bigint | null
    course_id: bigint | null
    plan_id: bigint | null
    status: $Enums.enrollment_status | null
    started_at: Date | null
    expires_at: Date | null
    _count: EnrollmentsCountAggregateOutputType | null
    _avg: EnrollmentsAvgAggregateOutputType | null
    _sum: EnrollmentsSumAggregateOutputType | null
    _min: EnrollmentsMinAggregateOutputType | null
    _max: EnrollmentsMaxAggregateOutputType | null
  }

  type GetEnrollmentsGroupByPayload<T extends enrollmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EnrollmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnrollmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnrollmentsGroupByOutputType[P]>
            : GetScalarType<T[P], EnrollmentsGroupByOutputType[P]>
        }
      >
    >


  export type enrollmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    plan_id?: boolean
    status?: boolean
    started_at?: boolean
    expires_at?: boolean
    courses?: boolean | enrollments$coursesArgs<ExtArgs>
    course_plans?: boolean | enrollments$course_plansArgs<ExtArgs>
    users?: boolean | enrollments$usersArgs<ExtArgs>
  }, ExtArgs["result"]["enrollments"]>

  export type enrollmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    plan_id?: boolean
    status?: boolean
    started_at?: boolean
    expires_at?: boolean
    courses?: boolean | enrollments$coursesArgs<ExtArgs>
    course_plans?: boolean | enrollments$course_plansArgs<ExtArgs>
    users?: boolean | enrollments$usersArgs<ExtArgs>
  }, ExtArgs["result"]["enrollments"]>

  export type enrollmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    plan_id?: boolean
    status?: boolean
    started_at?: boolean
    expires_at?: boolean
    courses?: boolean | enrollments$coursesArgs<ExtArgs>
    course_plans?: boolean | enrollments$course_plansArgs<ExtArgs>
    users?: boolean | enrollments$usersArgs<ExtArgs>
  }, ExtArgs["result"]["enrollments"]>

  export type enrollmentsSelectScalar = {
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    plan_id?: boolean
    status?: boolean
    started_at?: boolean
    expires_at?: boolean
  }

  export type enrollmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "course_id" | "plan_id" | "status" | "started_at" | "expires_at", ExtArgs["result"]["enrollments"]>
  export type enrollmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | enrollments$coursesArgs<ExtArgs>
    course_plans?: boolean | enrollments$course_plansArgs<ExtArgs>
    users?: boolean | enrollments$usersArgs<ExtArgs>
  }
  export type enrollmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | enrollments$coursesArgs<ExtArgs>
    course_plans?: boolean | enrollments$course_plansArgs<ExtArgs>
    users?: boolean | enrollments$usersArgs<ExtArgs>
  }
  export type enrollmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | enrollments$coursesArgs<ExtArgs>
    course_plans?: boolean | enrollments$course_plansArgs<ExtArgs>
    users?: boolean | enrollments$usersArgs<ExtArgs>
  }

  export type $enrollmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "enrollments"
    objects: {
      courses: Prisma.$coursesPayload<ExtArgs> | null
      course_plans: Prisma.$course_plansPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint | null
      course_id: bigint | null
      plan_id: bigint | null
      status: $Enums.enrollment_status | null
      started_at: Date | null
      expires_at: Date | null
    }, ExtArgs["result"]["enrollments"]>
    composites: {}
  }

  type enrollmentsGetPayload<S extends boolean | null | undefined | enrollmentsDefaultArgs> = $Result.GetResult<Prisma.$enrollmentsPayload, S>

  type enrollmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<enrollmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EnrollmentsCountAggregateInputType | true
    }

  export interface enrollmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['enrollments'], meta: { name: 'enrollments' } }
    /**
     * Find zero or one Enrollments that matches the filter.
     * @param {enrollmentsFindUniqueArgs} args - Arguments to find a Enrollments
     * @example
     * // Get one Enrollments
     * const enrollments = await prisma.enrollments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends enrollmentsFindUniqueArgs>(args: SelectSubset<T, enrollmentsFindUniqueArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Enrollments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {enrollmentsFindUniqueOrThrowArgs} args - Arguments to find a Enrollments
     * @example
     * // Get one Enrollments
     * const enrollments = await prisma.enrollments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends enrollmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, enrollmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsFindFirstArgs} args - Arguments to find a Enrollments
     * @example
     * // Get one Enrollments
     * const enrollments = await prisma.enrollments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends enrollmentsFindFirstArgs>(args?: SelectSubset<T, enrollmentsFindFirstArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Enrollments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsFindFirstOrThrowArgs} args - Arguments to find a Enrollments
     * @example
     * // Get one Enrollments
     * const enrollments = await prisma.enrollments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends enrollmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, enrollmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Enrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Enrollments
     * const enrollments = await prisma.enrollments.findMany()
     * 
     * // Get first 10 Enrollments
     * const enrollments = await prisma.enrollments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const enrollmentsWithIdOnly = await prisma.enrollments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends enrollmentsFindManyArgs>(args?: SelectSubset<T, enrollmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Enrollments.
     * @param {enrollmentsCreateArgs} args - Arguments to create a Enrollments.
     * @example
     * // Create one Enrollments
     * const Enrollments = await prisma.enrollments.create({
     *   data: {
     *     // ... data to create a Enrollments
     *   }
     * })
     * 
     */
    create<T extends enrollmentsCreateArgs>(args: SelectSubset<T, enrollmentsCreateArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Enrollments.
     * @param {enrollmentsCreateManyArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollments = await prisma.enrollments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends enrollmentsCreateManyArgs>(args?: SelectSubset<T, enrollmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Enrollments and returns the data saved in the database.
     * @param {enrollmentsCreateManyAndReturnArgs} args - Arguments to create many Enrollments.
     * @example
     * // Create many Enrollments
     * const enrollments = await prisma.enrollments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Enrollments and only return the `id`
     * const enrollmentsWithIdOnly = await prisma.enrollments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends enrollmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, enrollmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Enrollments.
     * @param {enrollmentsDeleteArgs} args - Arguments to delete one Enrollments.
     * @example
     * // Delete one Enrollments
     * const Enrollments = await prisma.enrollments.delete({
     *   where: {
     *     // ... filter to delete one Enrollments
     *   }
     * })
     * 
     */
    delete<T extends enrollmentsDeleteArgs>(args: SelectSubset<T, enrollmentsDeleteArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Enrollments.
     * @param {enrollmentsUpdateArgs} args - Arguments to update one Enrollments.
     * @example
     * // Update one Enrollments
     * const enrollments = await prisma.enrollments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends enrollmentsUpdateArgs>(args: SelectSubset<T, enrollmentsUpdateArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Enrollments.
     * @param {enrollmentsDeleteManyArgs} args - Arguments to filter Enrollments to delete.
     * @example
     * // Delete a few Enrollments
     * const { count } = await prisma.enrollments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends enrollmentsDeleteManyArgs>(args?: SelectSubset<T, enrollmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Enrollments
     * const enrollments = await prisma.enrollments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends enrollmentsUpdateManyArgs>(args: SelectSubset<T, enrollmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Enrollments and returns the data updated in the database.
     * @param {enrollmentsUpdateManyAndReturnArgs} args - Arguments to update many Enrollments.
     * @example
     * // Update many Enrollments
     * const enrollments = await prisma.enrollments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Enrollments and only return the `id`
     * const enrollmentsWithIdOnly = await prisma.enrollments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends enrollmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, enrollmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Enrollments.
     * @param {enrollmentsUpsertArgs} args - Arguments to update or create a Enrollments.
     * @example
     * // Update or create a Enrollments
     * const enrollments = await prisma.enrollments.upsert({
     *   create: {
     *     // ... data to create a Enrollments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Enrollments we want to update
     *   }
     * })
     */
    upsert<T extends enrollmentsUpsertArgs>(args: SelectSubset<T, enrollmentsUpsertArgs<ExtArgs>>): Prisma__enrollmentsClient<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsCountArgs} args - Arguments to filter Enrollments to count.
     * @example
     * // Count the number of Enrollments
     * const count = await prisma.enrollments.count({
     *   where: {
     *     // ... the filter for the Enrollments we want to count
     *   }
     * })
    **/
    count<T extends enrollmentsCountArgs>(
      args?: Subset<T, enrollmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnrollmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnrollmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnrollmentsAggregateArgs>(args: Subset<T, EnrollmentsAggregateArgs>): Prisma.PrismaPromise<GetEnrollmentsAggregateType<T>>

    /**
     * Group by Enrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {enrollmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends enrollmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: enrollmentsGroupByArgs['orderBy'] }
        : { orderBy?: enrollmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, enrollmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnrollmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the enrollments model
   */
  readonly fields: enrollmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for enrollments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__enrollmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends enrollments$coursesArgs<ExtArgs> = {}>(args?: Subset<T, enrollments$coursesArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    course_plans<T extends enrollments$course_plansArgs<ExtArgs> = {}>(args?: Subset<T, enrollments$course_plansArgs<ExtArgs>>): Prisma__course_plansClient<$Result.GetResult<Prisma.$course_plansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends enrollments$usersArgs<ExtArgs> = {}>(args?: Subset<T, enrollments$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the enrollments model
   */
  interface enrollmentsFieldRefs {
    readonly id: FieldRef<"enrollments", 'BigInt'>
    readonly user_id: FieldRef<"enrollments", 'BigInt'>
    readonly course_id: FieldRef<"enrollments", 'BigInt'>
    readonly plan_id: FieldRef<"enrollments", 'BigInt'>
    readonly status: FieldRef<"enrollments", 'enrollment_status'>
    readonly started_at: FieldRef<"enrollments", 'DateTime'>
    readonly expires_at: FieldRef<"enrollments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * enrollments findUnique
   */
  export type enrollmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which enrollments to fetch.
     */
    where: enrollmentsWhereUniqueInput
  }

  /**
   * enrollments findUniqueOrThrow
   */
  export type enrollmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which enrollments to fetch.
     */
    where: enrollmentsWhereUniqueInput
  }

  /**
   * enrollments findFirst
   */
  export type enrollmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which enrollments to fetch.
     */
    where?: enrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     */
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for enrollments.
     */
    cursor?: enrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of enrollments.
     */
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * enrollments findFirstOrThrow
   */
  export type enrollmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which enrollments to fetch.
     */
    where?: enrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     */
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for enrollments.
     */
    cursor?: enrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of enrollments.
     */
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * enrollments findMany
   */
  export type enrollmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter, which enrollments to fetch.
     */
    where?: enrollmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of enrollments to fetch.
     */
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing enrollments.
     */
    cursor?: enrollmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` enrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` enrollments.
     */
    skip?: number
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * enrollments create
   */
  export type enrollmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a enrollments.
     */
    data?: XOR<enrollmentsCreateInput, enrollmentsUncheckedCreateInput>
  }

  /**
   * enrollments createMany
   */
  export type enrollmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many enrollments.
     */
    data: enrollmentsCreateManyInput | enrollmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * enrollments createManyAndReturn
   */
  export type enrollmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * The data used to create many enrollments.
     */
    data: enrollmentsCreateManyInput | enrollmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * enrollments update
   */
  export type enrollmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a enrollments.
     */
    data: XOR<enrollmentsUpdateInput, enrollmentsUncheckedUpdateInput>
    /**
     * Choose, which enrollments to update.
     */
    where: enrollmentsWhereUniqueInput
  }

  /**
   * enrollments updateMany
   */
  export type enrollmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update enrollments.
     */
    data: XOR<enrollmentsUpdateManyMutationInput, enrollmentsUncheckedUpdateManyInput>
    /**
     * Filter which enrollments to update
     */
    where?: enrollmentsWhereInput
    /**
     * Limit how many enrollments to update.
     */
    limit?: number
  }

  /**
   * enrollments updateManyAndReturn
   */
  export type enrollmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * The data used to update enrollments.
     */
    data: XOR<enrollmentsUpdateManyMutationInput, enrollmentsUncheckedUpdateManyInput>
    /**
     * Filter which enrollments to update
     */
    where?: enrollmentsWhereInput
    /**
     * Limit how many enrollments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * enrollments upsert
   */
  export type enrollmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the enrollments to update in case it exists.
     */
    where: enrollmentsWhereUniqueInput
    /**
     * In case the enrollments found by the `where` argument doesn't exist, create a new enrollments with this data.
     */
    create: XOR<enrollmentsCreateInput, enrollmentsUncheckedCreateInput>
    /**
     * In case the enrollments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<enrollmentsUpdateInput, enrollmentsUncheckedUpdateInput>
  }

  /**
   * enrollments delete
   */
  export type enrollmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    /**
     * Filter which enrollments to delete.
     */
    where: enrollmentsWhereUniqueInput
  }

  /**
   * enrollments deleteMany
   */
  export type enrollmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which enrollments to delete
     */
    where?: enrollmentsWhereInput
    /**
     * Limit how many enrollments to delete.
     */
    limit?: number
  }

  /**
   * enrollments.courses
   */
  export type enrollments$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    where?: coursesWhereInput
  }

  /**
   * enrollments.course_plans
   */
  export type enrollments$course_plansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_plans
     */
    select?: course_plansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_plans
     */
    omit?: course_plansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_plansInclude<ExtArgs> | null
    where?: course_plansWhereInput
  }

  /**
   * enrollments.users
   */
  export type enrollments$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * enrollments without action
   */
  export type enrollmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
  }


  /**
   * Model google_ads
   */

  export type AggregateGoogle_ads = {
    _count: Google_adsCountAggregateOutputType | null
    _avg: Google_adsAvgAggregateOutputType | null
    _sum: Google_adsSumAggregateOutputType | null
    _min: Google_adsMinAggregateOutputType | null
    _max: Google_adsMaxAggregateOutputType | null
  }

  export type Google_adsAvgAggregateOutputType = {
    id: number | null
  }

  export type Google_adsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Google_adsMinAggregateOutputType = {
    id: bigint | null
    placement: string | null
    ad_code: string | null
    created_at: Date | null
  }

  export type Google_adsMaxAggregateOutputType = {
    id: bigint | null
    placement: string | null
    ad_code: string | null
    created_at: Date | null
  }

  export type Google_adsCountAggregateOutputType = {
    id: number
    placement: number
    ad_code: number
    created_at: number
    _all: number
  }


  export type Google_adsAvgAggregateInputType = {
    id?: true
  }

  export type Google_adsSumAggregateInputType = {
    id?: true
  }

  export type Google_adsMinAggregateInputType = {
    id?: true
    placement?: true
    ad_code?: true
    created_at?: true
  }

  export type Google_adsMaxAggregateInputType = {
    id?: true
    placement?: true
    ad_code?: true
    created_at?: true
  }

  export type Google_adsCountAggregateInputType = {
    id?: true
    placement?: true
    ad_code?: true
    created_at?: true
    _all?: true
  }

  export type Google_adsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which google_ads to aggregate.
     */
    where?: google_adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of google_ads to fetch.
     */
    orderBy?: google_adsOrderByWithRelationInput | google_adsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: google_adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` google_ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` google_ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned google_ads
    **/
    _count?: true | Google_adsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Google_adsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Google_adsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Google_adsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Google_adsMaxAggregateInputType
  }

  export type GetGoogle_adsAggregateType<T extends Google_adsAggregateArgs> = {
        [P in keyof T & keyof AggregateGoogle_ads]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoogle_ads[P]>
      : GetScalarType<T[P], AggregateGoogle_ads[P]>
  }




  export type google_adsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: google_adsWhereInput
    orderBy?: google_adsOrderByWithAggregationInput | google_adsOrderByWithAggregationInput[]
    by: Google_adsScalarFieldEnum[] | Google_adsScalarFieldEnum
    having?: google_adsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Google_adsCountAggregateInputType | true
    _avg?: Google_adsAvgAggregateInputType
    _sum?: Google_adsSumAggregateInputType
    _min?: Google_adsMinAggregateInputType
    _max?: Google_adsMaxAggregateInputType
  }

  export type Google_adsGroupByOutputType = {
    id: bigint
    placement: string
    ad_code: string
    created_at: Date | null
    _count: Google_adsCountAggregateOutputType | null
    _avg: Google_adsAvgAggregateOutputType | null
    _sum: Google_adsSumAggregateOutputType | null
    _min: Google_adsMinAggregateOutputType | null
    _max: Google_adsMaxAggregateOutputType | null
  }

  type GetGoogle_adsGroupByPayload<T extends google_adsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Google_adsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Google_adsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Google_adsGroupByOutputType[P]>
            : GetScalarType<T[P], Google_adsGroupByOutputType[P]>
        }
      >
    >


  export type google_adsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placement?: boolean
    ad_code?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["google_ads"]>

  export type google_adsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placement?: boolean
    ad_code?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["google_ads"]>

  export type google_adsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    placement?: boolean
    ad_code?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["google_ads"]>

  export type google_adsSelectScalar = {
    id?: boolean
    placement?: boolean
    ad_code?: boolean
    created_at?: boolean
  }

  export type google_adsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "placement" | "ad_code" | "created_at", ExtArgs["result"]["google_ads"]>

  export type $google_adsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "google_ads"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      placement: string
      ad_code: string
      created_at: Date | null
    }, ExtArgs["result"]["google_ads"]>
    composites: {}
  }

  type google_adsGetPayload<S extends boolean | null | undefined | google_adsDefaultArgs> = $Result.GetResult<Prisma.$google_adsPayload, S>

  type google_adsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<google_adsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Google_adsCountAggregateInputType | true
    }

  export interface google_adsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['google_ads'], meta: { name: 'google_ads' } }
    /**
     * Find zero or one Google_ads that matches the filter.
     * @param {google_adsFindUniqueArgs} args - Arguments to find a Google_ads
     * @example
     * // Get one Google_ads
     * const google_ads = await prisma.google_ads.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends google_adsFindUniqueArgs>(args: SelectSubset<T, google_adsFindUniqueArgs<ExtArgs>>): Prisma__google_adsClient<$Result.GetResult<Prisma.$google_adsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Google_ads that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {google_adsFindUniqueOrThrowArgs} args - Arguments to find a Google_ads
     * @example
     * // Get one Google_ads
     * const google_ads = await prisma.google_ads.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends google_adsFindUniqueOrThrowArgs>(args: SelectSubset<T, google_adsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__google_adsClient<$Result.GetResult<Prisma.$google_adsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Google_ads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_adsFindFirstArgs} args - Arguments to find a Google_ads
     * @example
     * // Get one Google_ads
     * const google_ads = await prisma.google_ads.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends google_adsFindFirstArgs>(args?: SelectSubset<T, google_adsFindFirstArgs<ExtArgs>>): Prisma__google_adsClient<$Result.GetResult<Prisma.$google_adsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Google_ads that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_adsFindFirstOrThrowArgs} args - Arguments to find a Google_ads
     * @example
     * // Get one Google_ads
     * const google_ads = await prisma.google_ads.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends google_adsFindFirstOrThrowArgs>(args?: SelectSubset<T, google_adsFindFirstOrThrowArgs<ExtArgs>>): Prisma__google_adsClient<$Result.GetResult<Prisma.$google_adsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Google_ads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_adsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Google_ads
     * const google_ads = await prisma.google_ads.findMany()
     * 
     * // Get first 10 Google_ads
     * const google_ads = await prisma.google_ads.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const google_adsWithIdOnly = await prisma.google_ads.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends google_adsFindManyArgs>(args?: SelectSubset<T, google_adsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$google_adsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Google_ads.
     * @param {google_adsCreateArgs} args - Arguments to create a Google_ads.
     * @example
     * // Create one Google_ads
     * const Google_ads = await prisma.google_ads.create({
     *   data: {
     *     // ... data to create a Google_ads
     *   }
     * })
     * 
     */
    create<T extends google_adsCreateArgs>(args: SelectSubset<T, google_adsCreateArgs<ExtArgs>>): Prisma__google_adsClient<$Result.GetResult<Prisma.$google_adsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Google_ads.
     * @param {google_adsCreateManyArgs} args - Arguments to create many Google_ads.
     * @example
     * // Create many Google_ads
     * const google_ads = await prisma.google_ads.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends google_adsCreateManyArgs>(args?: SelectSubset<T, google_adsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Google_ads and returns the data saved in the database.
     * @param {google_adsCreateManyAndReturnArgs} args - Arguments to create many Google_ads.
     * @example
     * // Create many Google_ads
     * const google_ads = await prisma.google_ads.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Google_ads and only return the `id`
     * const google_adsWithIdOnly = await prisma.google_ads.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends google_adsCreateManyAndReturnArgs>(args?: SelectSubset<T, google_adsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$google_adsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Google_ads.
     * @param {google_adsDeleteArgs} args - Arguments to delete one Google_ads.
     * @example
     * // Delete one Google_ads
     * const Google_ads = await prisma.google_ads.delete({
     *   where: {
     *     // ... filter to delete one Google_ads
     *   }
     * })
     * 
     */
    delete<T extends google_adsDeleteArgs>(args: SelectSubset<T, google_adsDeleteArgs<ExtArgs>>): Prisma__google_adsClient<$Result.GetResult<Prisma.$google_adsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Google_ads.
     * @param {google_adsUpdateArgs} args - Arguments to update one Google_ads.
     * @example
     * // Update one Google_ads
     * const google_ads = await prisma.google_ads.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends google_adsUpdateArgs>(args: SelectSubset<T, google_adsUpdateArgs<ExtArgs>>): Prisma__google_adsClient<$Result.GetResult<Prisma.$google_adsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Google_ads.
     * @param {google_adsDeleteManyArgs} args - Arguments to filter Google_ads to delete.
     * @example
     * // Delete a few Google_ads
     * const { count } = await prisma.google_ads.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends google_adsDeleteManyArgs>(args?: SelectSubset<T, google_adsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Google_ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_adsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Google_ads
     * const google_ads = await prisma.google_ads.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends google_adsUpdateManyArgs>(args: SelectSubset<T, google_adsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Google_ads and returns the data updated in the database.
     * @param {google_adsUpdateManyAndReturnArgs} args - Arguments to update many Google_ads.
     * @example
     * // Update many Google_ads
     * const google_ads = await prisma.google_ads.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Google_ads and only return the `id`
     * const google_adsWithIdOnly = await prisma.google_ads.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends google_adsUpdateManyAndReturnArgs>(args: SelectSubset<T, google_adsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$google_adsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Google_ads.
     * @param {google_adsUpsertArgs} args - Arguments to update or create a Google_ads.
     * @example
     * // Update or create a Google_ads
     * const google_ads = await prisma.google_ads.upsert({
     *   create: {
     *     // ... data to create a Google_ads
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Google_ads we want to update
     *   }
     * })
     */
    upsert<T extends google_adsUpsertArgs>(args: SelectSubset<T, google_adsUpsertArgs<ExtArgs>>): Prisma__google_adsClient<$Result.GetResult<Prisma.$google_adsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Google_ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_adsCountArgs} args - Arguments to filter Google_ads to count.
     * @example
     * // Count the number of Google_ads
     * const count = await prisma.google_ads.count({
     *   where: {
     *     // ... the filter for the Google_ads we want to count
     *   }
     * })
    **/
    count<T extends google_adsCountArgs>(
      args?: Subset<T, google_adsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Google_adsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Google_ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Google_adsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Google_adsAggregateArgs>(args: Subset<T, Google_adsAggregateArgs>): Prisma.PrismaPromise<GetGoogle_adsAggregateType<T>>

    /**
     * Group by Google_ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {google_adsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends google_adsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: google_adsGroupByArgs['orderBy'] }
        : { orderBy?: google_adsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, google_adsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoogle_adsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the google_ads model
   */
  readonly fields: google_adsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for google_ads.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__google_adsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the google_ads model
   */
  interface google_adsFieldRefs {
    readonly id: FieldRef<"google_ads", 'BigInt'>
    readonly placement: FieldRef<"google_ads", 'String'>
    readonly ad_code: FieldRef<"google_ads", 'String'>
    readonly created_at: FieldRef<"google_ads", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * google_ads findUnique
   */
  export type google_adsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_ads
     */
    select?: google_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the google_ads
     */
    omit?: google_adsOmit<ExtArgs> | null
    /**
     * Filter, which google_ads to fetch.
     */
    where: google_adsWhereUniqueInput
  }

  /**
   * google_ads findUniqueOrThrow
   */
  export type google_adsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_ads
     */
    select?: google_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the google_ads
     */
    omit?: google_adsOmit<ExtArgs> | null
    /**
     * Filter, which google_ads to fetch.
     */
    where: google_adsWhereUniqueInput
  }

  /**
   * google_ads findFirst
   */
  export type google_adsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_ads
     */
    select?: google_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the google_ads
     */
    omit?: google_adsOmit<ExtArgs> | null
    /**
     * Filter, which google_ads to fetch.
     */
    where?: google_adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of google_ads to fetch.
     */
    orderBy?: google_adsOrderByWithRelationInput | google_adsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for google_ads.
     */
    cursor?: google_adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` google_ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` google_ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of google_ads.
     */
    distinct?: Google_adsScalarFieldEnum | Google_adsScalarFieldEnum[]
  }

  /**
   * google_ads findFirstOrThrow
   */
  export type google_adsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_ads
     */
    select?: google_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the google_ads
     */
    omit?: google_adsOmit<ExtArgs> | null
    /**
     * Filter, which google_ads to fetch.
     */
    where?: google_adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of google_ads to fetch.
     */
    orderBy?: google_adsOrderByWithRelationInput | google_adsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for google_ads.
     */
    cursor?: google_adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` google_ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` google_ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of google_ads.
     */
    distinct?: Google_adsScalarFieldEnum | Google_adsScalarFieldEnum[]
  }

  /**
   * google_ads findMany
   */
  export type google_adsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_ads
     */
    select?: google_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the google_ads
     */
    omit?: google_adsOmit<ExtArgs> | null
    /**
     * Filter, which google_ads to fetch.
     */
    where?: google_adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of google_ads to fetch.
     */
    orderBy?: google_adsOrderByWithRelationInput | google_adsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing google_ads.
     */
    cursor?: google_adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` google_ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` google_ads.
     */
    skip?: number
    distinct?: Google_adsScalarFieldEnum | Google_adsScalarFieldEnum[]
  }

  /**
   * google_ads create
   */
  export type google_adsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_ads
     */
    select?: google_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the google_ads
     */
    omit?: google_adsOmit<ExtArgs> | null
    /**
     * The data needed to create a google_ads.
     */
    data: XOR<google_adsCreateInput, google_adsUncheckedCreateInput>
  }

  /**
   * google_ads createMany
   */
  export type google_adsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many google_ads.
     */
    data: google_adsCreateManyInput | google_adsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * google_ads createManyAndReturn
   */
  export type google_adsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_ads
     */
    select?: google_adsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the google_ads
     */
    omit?: google_adsOmit<ExtArgs> | null
    /**
     * The data used to create many google_ads.
     */
    data: google_adsCreateManyInput | google_adsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * google_ads update
   */
  export type google_adsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_ads
     */
    select?: google_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the google_ads
     */
    omit?: google_adsOmit<ExtArgs> | null
    /**
     * The data needed to update a google_ads.
     */
    data: XOR<google_adsUpdateInput, google_adsUncheckedUpdateInput>
    /**
     * Choose, which google_ads to update.
     */
    where: google_adsWhereUniqueInput
  }

  /**
   * google_ads updateMany
   */
  export type google_adsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update google_ads.
     */
    data: XOR<google_adsUpdateManyMutationInput, google_adsUncheckedUpdateManyInput>
    /**
     * Filter which google_ads to update
     */
    where?: google_adsWhereInput
    /**
     * Limit how many google_ads to update.
     */
    limit?: number
  }

  /**
   * google_ads updateManyAndReturn
   */
  export type google_adsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_ads
     */
    select?: google_adsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the google_ads
     */
    omit?: google_adsOmit<ExtArgs> | null
    /**
     * The data used to update google_ads.
     */
    data: XOR<google_adsUpdateManyMutationInput, google_adsUncheckedUpdateManyInput>
    /**
     * Filter which google_ads to update
     */
    where?: google_adsWhereInput
    /**
     * Limit how many google_ads to update.
     */
    limit?: number
  }

  /**
   * google_ads upsert
   */
  export type google_adsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_ads
     */
    select?: google_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the google_ads
     */
    omit?: google_adsOmit<ExtArgs> | null
    /**
     * The filter to search for the google_ads to update in case it exists.
     */
    where: google_adsWhereUniqueInput
    /**
     * In case the google_ads found by the `where` argument doesn't exist, create a new google_ads with this data.
     */
    create: XOR<google_adsCreateInput, google_adsUncheckedCreateInput>
    /**
     * In case the google_ads was found with the provided `where` argument, update it with this data.
     */
    update: XOR<google_adsUpdateInput, google_adsUncheckedUpdateInput>
  }

  /**
   * google_ads delete
   */
  export type google_adsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_ads
     */
    select?: google_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the google_ads
     */
    omit?: google_adsOmit<ExtArgs> | null
    /**
     * Filter which google_ads to delete.
     */
    where: google_adsWhereUniqueInput
  }

  /**
   * google_ads deleteMany
   */
  export type google_adsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which google_ads to delete
     */
    where?: google_adsWhereInput
    /**
     * Limit how many google_ads to delete.
     */
    limit?: number
  }

  /**
   * google_ads without action
   */
  export type google_adsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the google_ads
     */
    select?: google_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the google_ads
     */
    omit?: google_adsOmit<ExtArgs> | null
  }


  /**
   * Model mock_attempts
   */

  export type AggregateMock_attempts = {
    _count: Mock_attemptsCountAggregateOutputType | null
    _avg: Mock_attemptsAvgAggregateOutputType | null
    _sum: Mock_attemptsSumAggregateOutputType | null
    _min: Mock_attemptsMinAggregateOutputType | null
    _max: Mock_attemptsMaxAggregateOutputType | null
  }

  export type Mock_attemptsAvgAggregateOutputType = {
    id: number | null
    test_id: number | null
    user_id: number | null
    score: number | null
  }

  export type Mock_attemptsSumAggregateOutputType = {
    id: bigint | null
    test_id: bigint | null
    user_id: bigint | null
    score: number | null
  }

  export type Mock_attemptsMinAggregateOutputType = {
    id: bigint | null
    test_id: bigint | null
    user_id: bigint | null
    score: number | null
    started_at: Date | null
    completed_at: Date | null
  }

  export type Mock_attemptsMaxAggregateOutputType = {
    id: bigint | null
    test_id: bigint | null
    user_id: bigint | null
    score: number | null
    started_at: Date | null
    completed_at: Date | null
  }

  export type Mock_attemptsCountAggregateOutputType = {
    id: number
    test_id: number
    user_id: number
    answers: number
    score: number
    started_at: number
    completed_at: number
    _all: number
  }


  export type Mock_attemptsAvgAggregateInputType = {
    id?: true
    test_id?: true
    user_id?: true
    score?: true
  }

  export type Mock_attemptsSumAggregateInputType = {
    id?: true
    test_id?: true
    user_id?: true
    score?: true
  }

  export type Mock_attemptsMinAggregateInputType = {
    id?: true
    test_id?: true
    user_id?: true
    score?: true
    started_at?: true
    completed_at?: true
  }

  export type Mock_attemptsMaxAggregateInputType = {
    id?: true
    test_id?: true
    user_id?: true
    score?: true
    started_at?: true
    completed_at?: true
  }

  export type Mock_attemptsCountAggregateInputType = {
    id?: true
    test_id?: true
    user_id?: true
    answers?: true
    score?: true
    started_at?: true
    completed_at?: true
    _all?: true
  }

  export type Mock_attemptsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mock_attempts to aggregate.
     */
    where?: mock_attemptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_attempts to fetch.
     */
    orderBy?: mock_attemptsOrderByWithRelationInput | mock_attemptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mock_attemptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_attempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_attempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mock_attempts
    **/
    _count?: true | Mock_attemptsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Mock_attemptsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Mock_attemptsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mock_attemptsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mock_attemptsMaxAggregateInputType
  }

  export type GetMock_attemptsAggregateType<T extends Mock_attemptsAggregateArgs> = {
        [P in keyof T & keyof AggregateMock_attempts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMock_attempts[P]>
      : GetScalarType<T[P], AggregateMock_attempts[P]>
  }




  export type mock_attemptsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mock_attemptsWhereInput
    orderBy?: mock_attemptsOrderByWithAggregationInput | mock_attemptsOrderByWithAggregationInput[]
    by: Mock_attemptsScalarFieldEnum[] | Mock_attemptsScalarFieldEnum
    having?: mock_attemptsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mock_attemptsCountAggregateInputType | true
    _avg?: Mock_attemptsAvgAggregateInputType
    _sum?: Mock_attemptsSumAggregateInputType
    _min?: Mock_attemptsMinAggregateInputType
    _max?: Mock_attemptsMaxAggregateInputType
  }

  export type Mock_attemptsGroupByOutputType = {
    id: bigint
    test_id: bigint | null
    user_id: bigint | null
    answers: JsonValue
    score: number | null
    started_at: Date | null
    completed_at: Date | null
    _count: Mock_attemptsCountAggregateOutputType | null
    _avg: Mock_attemptsAvgAggregateOutputType | null
    _sum: Mock_attemptsSumAggregateOutputType | null
    _min: Mock_attemptsMinAggregateOutputType | null
    _max: Mock_attemptsMaxAggregateOutputType | null
  }

  type GetMock_attemptsGroupByPayload<T extends mock_attemptsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mock_attemptsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mock_attemptsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mock_attemptsGroupByOutputType[P]>
            : GetScalarType<T[P], Mock_attemptsGroupByOutputType[P]>
        }
      >
    >


  export type mock_attemptsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    test_id?: boolean
    user_id?: boolean
    answers?: boolean
    score?: boolean
    started_at?: boolean
    completed_at?: boolean
    mock_tests?: boolean | mock_attempts$mock_testsArgs<ExtArgs>
    users?: boolean | mock_attempts$usersArgs<ExtArgs>
  }, ExtArgs["result"]["mock_attempts"]>

  export type mock_attemptsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    test_id?: boolean
    user_id?: boolean
    answers?: boolean
    score?: boolean
    started_at?: boolean
    completed_at?: boolean
    mock_tests?: boolean | mock_attempts$mock_testsArgs<ExtArgs>
    users?: boolean | mock_attempts$usersArgs<ExtArgs>
  }, ExtArgs["result"]["mock_attempts"]>

  export type mock_attemptsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    test_id?: boolean
    user_id?: boolean
    answers?: boolean
    score?: boolean
    started_at?: boolean
    completed_at?: boolean
    mock_tests?: boolean | mock_attempts$mock_testsArgs<ExtArgs>
    users?: boolean | mock_attempts$usersArgs<ExtArgs>
  }, ExtArgs["result"]["mock_attempts"]>

  export type mock_attemptsSelectScalar = {
    id?: boolean
    test_id?: boolean
    user_id?: boolean
    answers?: boolean
    score?: boolean
    started_at?: boolean
    completed_at?: boolean
  }

  export type mock_attemptsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "test_id" | "user_id" | "answers" | "score" | "started_at" | "completed_at", ExtArgs["result"]["mock_attempts"]>
  export type mock_attemptsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mock_tests?: boolean | mock_attempts$mock_testsArgs<ExtArgs>
    users?: boolean | mock_attempts$usersArgs<ExtArgs>
  }
  export type mock_attemptsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mock_tests?: boolean | mock_attempts$mock_testsArgs<ExtArgs>
    users?: boolean | mock_attempts$usersArgs<ExtArgs>
  }
  export type mock_attemptsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mock_tests?: boolean | mock_attempts$mock_testsArgs<ExtArgs>
    users?: boolean | mock_attempts$usersArgs<ExtArgs>
  }

  export type $mock_attemptsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mock_attempts"
    objects: {
      mock_tests: Prisma.$mock_testsPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      test_id: bigint | null
      user_id: bigint | null
      answers: Prisma.JsonValue
      score: number | null
      started_at: Date | null
      completed_at: Date | null
    }, ExtArgs["result"]["mock_attempts"]>
    composites: {}
  }

  type mock_attemptsGetPayload<S extends boolean | null | undefined | mock_attemptsDefaultArgs> = $Result.GetResult<Prisma.$mock_attemptsPayload, S>

  type mock_attemptsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mock_attemptsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Mock_attemptsCountAggregateInputType | true
    }

  export interface mock_attemptsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mock_attempts'], meta: { name: 'mock_attempts' } }
    /**
     * Find zero or one Mock_attempts that matches the filter.
     * @param {mock_attemptsFindUniqueArgs} args - Arguments to find a Mock_attempts
     * @example
     * // Get one Mock_attempts
     * const mock_attempts = await prisma.mock_attempts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mock_attemptsFindUniqueArgs>(args: SelectSubset<T, mock_attemptsFindUniqueArgs<ExtArgs>>): Prisma__mock_attemptsClient<$Result.GetResult<Prisma.$mock_attemptsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mock_attempts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mock_attemptsFindUniqueOrThrowArgs} args - Arguments to find a Mock_attempts
     * @example
     * // Get one Mock_attempts
     * const mock_attempts = await prisma.mock_attempts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mock_attemptsFindUniqueOrThrowArgs>(args: SelectSubset<T, mock_attemptsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mock_attemptsClient<$Result.GetResult<Prisma.$mock_attemptsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mock_attempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_attemptsFindFirstArgs} args - Arguments to find a Mock_attempts
     * @example
     * // Get one Mock_attempts
     * const mock_attempts = await prisma.mock_attempts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mock_attemptsFindFirstArgs>(args?: SelectSubset<T, mock_attemptsFindFirstArgs<ExtArgs>>): Prisma__mock_attemptsClient<$Result.GetResult<Prisma.$mock_attemptsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mock_attempts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_attemptsFindFirstOrThrowArgs} args - Arguments to find a Mock_attempts
     * @example
     * // Get one Mock_attempts
     * const mock_attempts = await prisma.mock_attempts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mock_attemptsFindFirstOrThrowArgs>(args?: SelectSubset<T, mock_attemptsFindFirstOrThrowArgs<ExtArgs>>): Prisma__mock_attemptsClient<$Result.GetResult<Prisma.$mock_attemptsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mock_attempts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_attemptsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mock_attempts
     * const mock_attempts = await prisma.mock_attempts.findMany()
     * 
     * // Get first 10 Mock_attempts
     * const mock_attempts = await prisma.mock_attempts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mock_attemptsWithIdOnly = await prisma.mock_attempts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mock_attemptsFindManyArgs>(args?: SelectSubset<T, mock_attemptsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_attemptsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mock_attempts.
     * @param {mock_attemptsCreateArgs} args - Arguments to create a Mock_attempts.
     * @example
     * // Create one Mock_attempts
     * const Mock_attempts = await prisma.mock_attempts.create({
     *   data: {
     *     // ... data to create a Mock_attempts
     *   }
     * })
     * 
     */
    create<T extends mock_attemptsCreateArgs>(args: SelectSubset<T, mock_attemptsCreateArgs<ExtArgs>>): Prisma__mock_attemptsClient<$Result.GetResult<Prisma.$mock_attemptsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mock_attempts.
     * @param {mock_attemptsCreateManyArgs} args - Arguments to create many Mock_attempts.
     * @example
     * // Create many Mock_attempts
     * const mock_attempts = await prisma.mock_attempts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mock_attemptsCreateManyArgs>(args?: SelectSubset<T, mock_attemptsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mock_attempts and returns the data saved in the database.
     * @param {mock_attemptsCreateManyAndReturnArgs} args - Arguments to create many Mock_attempts.
     * @example
     * // Create many Mock_attempts
     * const mock_attempts = await prisma.mock_attempts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mock_attempts and only return the `id`
     * const mock_attemptsWithIdOnly = await prisma.mock_attempts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mock_attemptsCreateManyAndReturnArgs>(args?: SelectSubset<T, mock_attemptsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_attemptsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mock_attempts.
     * @param {mock_attemptsDeleteArgs} args - Arguments to delete one Mock_attempts.
     * @example
     * // Delete one Mock_attempts
     * const Mock_attempts = await prisma.mock_attempts.delete({
     *   where: {
     *     // ... filter to delete one Mock_attempts
     *   }
     * })
     * 
     */
    delete<T extends mock_attemptsDeleteArgs>(args: SelectSubset<T, mock_attemptsDeleteArgs<ExtArgs>>): Prisma__mock_attemptsClient<$Result.GetResult<Prisma.$mock_attemptsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mock_attempts.
     * @param {mock_attemptsUpdateArgs} args - Arguments to update one Mock_attempts.
     * @example
     * // Update one Mock_attempts
     * const mock_attempts = await prisma.mock_attempts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mock_attemptsUpdateArgs>(args: SelectSubset<T, mock_attemptsUpdateArgs<ExtArgs>>): Prisma__mock_attemptsClient<$Result.GetResult<Prisma.$mock_attemptsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mock_attempts.
     * @param {mock_attemptsDeleteManyArgs} args - Arguments to filter Mock_attempts to delete.
     * @example
     * // Delete a few Mock_attempts
     * const { count } = await prisma.mock_attempts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mock_attemptsDeleteManyArgs>(args?: SelectSubset<T, mock_attemptsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mock_attempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_attemptsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mock_attempts
     * const mock_attempts = await prisma.mock_attempts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mock_attemptsUpdateManyArgs>(args: SelectSubset<T, mock_attemptsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mock_attempts and returns the data updated in the database.
     * @param {mock_attemptsUpdateManyAndReturnArgs} args - Arguments to update many Mock_attempts.
     * @example
     * // Update many Mock_attempts
     * const mock_attempts = await prisma.mock_attempts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mock_attempts and only return the `id`
     * const mock_attemptsWithIdOnly = await prisma.mock_attempts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mock_attemptsUpdateManyAndReturnArgs>(args: SelectSubset<T, mock_attemptsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_attemptsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mock_attempts.
     * @param {mock_attemptsUpsertArgs} args - Arguments to update or create a Mock_attempts.
     * @example
     * // Update or create a Mock_attempts
     * const mock_attempts = await prisma.mock_attempts.upsert({
     *   create: {
     *     // ... data to create a Mock_attempts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mock_attempts we want to update
     *   }
     * })
     */
    upsert<T extends mock_attemptsUpsertArgs>(args: SelectSubset<T, mock_attemptsUpsertArgs<ExtArgs>>): Prisma__mock_attemptsClient<$Result.GetResult<Prisma.$mock_attemptsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mock_attempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_attemptsCountArgs} args - Arguments to filter Mock_attempts to count.
     * @example
     * // Count the number of Mock_attempts
     * const count = await prisma.mock_attempts.count({
     *   where: {
     *     // ... the filter for the Mock_attempts we want to count
     *   }
     * })
    **/
    count<T extends mock_attemptsCountArgs>(
      args?: Subset<T, mock_attemptsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mock_attemptsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mock_attempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mock_attemptsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mock_attemptsAggregateArgs>(args: Subset<T, Mock_attemptsAggregateArgs>): Prisma.PrismaPromise<GetMock_attemptsAggregateType<T>>

    /**
     * Group by Mock_attempts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_attemptsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mock_attemptsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mock_attemptsGroupByArgs['orderBy'] }
        : { orderBy?: mock_attemptsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mock_attemptsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMock_attemptsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mock_attempts model
   */
  readonly fields: mock_attemptsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mock_attempts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mock_attemptsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mock_tests<T extends mock_attempts$mock_testsArgs<ExtArgs> = {}>(args?: Subset<T, mock_attempts$mock_testsArgs<ExtArgs>>): Prisma__mock_testsClient<$Result.GetResult<Prisma.$mock_testsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends mock_attempts$usersArgs<ExtArgs> = {}>(args?: Subset<T, mock_attempts$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mock_attempts model
   */
  interface mock_attemptsFieldRefs {
    readonly id: FieldRef<"mock_attempts", 'BigInt'>
    readonly test_id: FieldRef<"mock_attempts", 'BigInt'>
    readonly user_id: FieldRef<"mock_attempts", 'BigInt'>
    readonly answers: FieldRef<"mock_attempts", 'Json'>
    readonly score: FieldRef<"mock_attempts", 'Int'>
    readonly started_at: FieldRef<"mock_attempts", 'DateTime'>
    readonly completed_at: FieldRef<"mock_attempts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * mock_attempts findUnique
   */
  export type mock_attemptsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_attempts
     */
    select?: mock_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_attempts
     */
    omit?: mock_attemptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_attemptsInclude<ExtArgs> | null
    /**
     * Filter, which mock_attempts to fetch.
     */
    where: mock_attemptsWhereUniqueInput
  }

  /**
   * mock_attempts findUniqueOrThrow
   */
  export type mock_attemptsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_attempts
     */
    select?: mock_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_attempts
     */
    omit?: mock_attemptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_attemptsInclude<ExtArgs> | null
    /**
     * Filter, which mock_attempts to fetch.
     */
    where: mock_attemptsWhereUniqueInput
  }

  /**
   * mock_attempts findFirst
   */
  export type mock_attemptsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_attempts
     */
    select?: mock_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_attempts
     */
    omit?: mock_attemptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_attemptsInclude<ExtArgs> | null
    /**
     * Filter, which mock_attempts to fetch.
     */
    where?: mock_attemptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_attempts to fetch.
     */
    orderBy?: mock_attemptsOrderByWithRelationInput | mock_attemptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mock_attempts.
     */
    cursor?: mock_attemptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_attempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_attempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mock_attempts.
     */
    distinct?: Mock_attemptsScalarFieldEnum | Mock_attemptsScalarFieldEnum[]
  }

  /**
   * mock_attempts findFirstOrThrow
   */
  export type mock_attemptsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_attempts
     */
    select?: mock_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_attempts
     */
    omit?: mock_attemptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_attemptsInclude<ExtArgs> | null
    /**
     * Filter, which mock_attempts to fetch.
     */
    where?: mock_attemptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_attempts to fetch.
     */
    orderBy?: mock_attemptsOrderByWithRelationInput | mock_attemptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mock_attempts.
     */
    cursor?: mock_attemptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_attempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_attempts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mock_attempts.
     */
    distinct?: Mock_attemptsScalarFieldEnum | Mock_attemptsScalarFieldEnum[]
  }

  /**
   * mock_attempts findMany
   */
  export type mock_attemptsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_attempts
     */
    select?: mock_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_attempts
     */
    omit?: mock_attemptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_attemptsInclude<ExtArgs> | null
    /**
     * Filter, which mock_attempts to fetch.
     */
    where?: mock_attemptsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_attempts to fetch.
     */
    orderBy?: mock_attemptsOrderByWithRelationInput | mock_attemptsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mock_attempts.
     */
    cursor?: mock_attemptsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_attempts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_attempts.
     */
    skip?: number
    distinct?: Mock_attemptsScalarFieldEnum | Mock_attemptsScalarFieldEnum[]
  }

  /**
   * mock_attempts create
   */
  export type mock_attemptsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_attempts
     */
    select?: mock_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_attempts
     */
    omit?: mock_attemptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_attemptsInclude<ExtArgs> | null
    /**
     * The data needed to create a mock_attempts.
     */
    data: XOR<mock_attemptsCreateInput, mock_attemptsUncheckedCreateInput>
  }

  /**
   * mock_attempts createMany
   */
  export type mock_attemptsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mock_attempts.
     */
    data: mock_attemptsCreateManyInput | mock_attemptsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mock_attempts createManyAndReturn
   */
  export type mock_attemptsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_attempts
     */
    select?: mock_attemptsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mock_attempts
     */
    omit?: mock_attemptsOmit<ExtArgs> | null
    /**
     * The data used to create many mock_attempts.
     */
    data: mock_attemptsCreateManyInput | mock_attemptsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_attemptsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * mock_attempts update
   */
  export type mock_attemptsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_attempts
     */
    select?: mock_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_attempts
     */
    omit?: mock_attemptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_attemptsInclude<ExtArgs> | null
    /**
     * The data needed to update a mock_attempts.
     */
    data: XOR<mock_attemptsUpdateInput, mock_attemptsUncheckedUpdateInput>
    /**
     * Choose, which mock_attempts to update.
     */
    where: mock_attemptsWhereUniqueInput
  }

  /**
   * mock_attempts updateMany
   */
  export type mock_attemptsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mock_attempts.
     */
    data: XOR<mock_attemptsUpdateManyMutationInput, mock_attemptsUncheckedUpdateManyInput>
    /**
     * Filter which mock_attempts to update
     */
    where?: mock_attemptsWhereInput
    /**
     * Limit how many mock_attempts to update.
     */
    limit?: number
  }

  /**
   * mock_attempts updateManyAndReturn
   */
  export type mock_attemptsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_attempts
     */
    select?: mock_attemptsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mock_attempts
     */
    omit?: mock_attemptsOmit<ExtArgs> | null
    /**
     * The data used to update mock_attempts.
     */
    data: XOR<mock_attemptsUpdateManyMutationInput, mock_attemptsUncheckedUpdateManyInput>
    /**
     * Filter which mock_attempts to update
     */
    where?: mock_attemptsWhereInput
    /**
     * Limit how many mock_attempts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_attemptsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * mock_attempts upsert
   */
  export type mock_attemptsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_attempts
     */
    select?: mock_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_attempts
     */
    omit?: mock_attemptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_attemptsInclude<ExtArgs> | null
    /**
     * The filter to search for the mock_attempts to update in case it exists.
     */
    where: mock_attemptsWhereUniqueInput
    /**
     * In case the mock_attempts found by the `where` argument doesn't exist, create a new mock_attempts with this data.
     */
    create: XOR<mock_attemptsCreateInput, mock_attemptsUncheckedCreateInput>
    /**
     * In case the mock_attempts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mock_attemptsUpdateInput, mock_attemptsUncheckedUpdateInput>
  }

  /**
   * mock_attempts delete
   */
  export type mock_attemptsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_attempts
     */
    select?: mock_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_attempts
     */
    omit?: mock_attemptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_attemptsInclude<ExtArgs> | null
    /**
     * Filter which mock_attempts to delete.
     */
    where: mock_attemptsWhereUniqueInput
  }

  /**
   * mock_attempts deleteMany
   */
  export type mock_attemptsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mock_attempts to delete
     */
    where?: mock_attemptsWhereInput
    /**
     * Limit how many mock_attempts to delete.
     */
    limit?: number
  }

  /**
   * mock_attempts.mock_tests
   */
  export type mock_attempts$mock_testsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_tests
     */
    select?: mock_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_tests
     */
    omit?: mock_testsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_testsInclude<ExtArgs> | null
    where?: mock_testsWhereInput
  }

  /**
   * mock_attempts.users
   */
  export type mock_attempts$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * mock_attempts without action
   */
  export type mock_attemptsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_attempts
     */
    select?: mock_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_attempts
     */
    omit?: mock_attemptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_attemptsInclude<ExtArgs> | null
  }


  /**
   * Model mock_categories
   */

  export type AggregateMock_categories = {
    _count: Mock_categoriesCountAggregateOutputType | null
    _avg: Mock_categoriesAvgAggregateOutputType | null
    _sum: Mock_categoriesSumAggregateOutputType | null
    _min: Mock_categoriesMinAggregateOutputType | null
    _max: Mock_categoriesMaxAggregateOutputType | null
  }

  export type Mock_categoriesAvgAggregateOutputType = {
    id: number | null
  }

  export type Mock_categoriesSumAggregateOutputType = {
    id: bigint | null
  }

  export type Mock_categoriesMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    description: string | null
  }

  export type Mock_categoriesMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    description: string | null
  }

  export type Mock_categoriesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type Mock_categoriesAvgAggregateInputType = {
    id?: true
  }

  export type Mock_categoriesSumAggregateInputType = {
    id?: true
  }

  export type Mock_categoriesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type Mock_categoriesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type Mock_categoriesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type Mock_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mock_categories to aggregate.
     */
    where?: mock_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_categories to fetch.
     */
    orderBy?: mock_categoriesOrderByWithRelationInput | mock_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mock_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mock_categories
    **/
    _count?: true | Mock_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Mock_categoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Mock_categoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mock_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mock_categoriesMaxAggregateInputType
  }

  export type GetMock_categoriesAggregateType<T extends Mock_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateMock_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMock_categories[P]>
      : GetScalarType<T[P], AggregateMock_categories[P]>
  }




  export type mock_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mock_categoriesWhereInput
    orderBy?: mock_categoriesOrderByWithAggregationInput | mock_categoriesOrderByWithAggregationInput[]
    by: Mock_categoriesScalarFieldEnum[] | Mock_categoriesScalarFieldEnum
    having?: mock_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mock_categoriesCountAggregateInputType | true
    _avg?: Mock_categoriesAvgAggregateInputType
    _sum?: Mock_categoriesSumAggregateInputType
    _min?: Mock_categoriesMinAggregateInputType
    _max?: Mock_categoriesMaxAggregateInputType
  }

  export type Mock_categoriesGroupByOutputType = {
    id: bigint
    name: string
    description: string | null
    _count: Mock_categoriesCountAggregateOutputType | null
    _avg: Mock_categoriesAvgAggregateOutputType | null
    _sum: Mock_categoriesSumAggregateOutputType | null
    _min: Mock_categoriesMinAggregateOutputType | null
    _max: Mock_categoriesMaxAggregateOutputType | null
  }

  type GetMock_categoriesGroupByPayload<T extends mock_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mock_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mock_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mock_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Mock_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type mock_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    mock_series?: boolean | mock_categories$mock_seriesArgs<ExtArgs>
    _count?: boolean | Mock_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mock_categories"]>

  export type mock_categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["mock_categories"]>

  export type mock_categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
  }, ExtArgs["result"]["mock_categories"]>

  export type mock_categoriesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type mock_categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description", ExtArgs["result"]["mock_categories"]>
  export type mock_categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mock_series?: boolean | mock_categories$mock_seriesArgs<ExtArgs>
    _count?: boolean | Mock_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type mock_categoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type mock_categoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $mock_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mock_categories"
    objects: {
      mock_series: Prisma.$mock_seriesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      description: string | null
    }, ExtArgs["result"]["mock_categories"]>
    composites: {}
  }

  type mock_categoriesGetPayload<S extends boolean | null | undefined | mock_categoriesDefaultArgs> = $Result.GetResult<Prisma.$mock_categoriesPayload, S>

  type mock_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mock_categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Mock_categoriesCountAggregateInputType | true
    }

  export interface mock_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mock_categories'], meta: { name: 'mock_categories' } }
    /**
     * Find zero or one Mock_categories that matches the filter.
     * @param {mock_categoriesFindUniqueArgs} args - Arguments to find a Mock_categories
     * @example
     * // Get one Mock_categories
     * const mock_categories = await prisma.mock_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mock_categoriesFindUniqueArgs>(args: SelectSubset<T, mock_categoriesFindUniqueArgs<ExtArgs>>): Prisma__mock_categoriesClient<$Result.GetResult<Prisma.$mock_categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mock_categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mock_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Mock_categories
     * @example
     * // Get one Mock_categories
     * const mock_categories = await prisma.mock_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mock_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, mock_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mock_categoriesClient<$Result.GetResult<Prisma.$mock_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mock_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_categoriesFindFirstArgs} args - Arguments to find a Mock_categories
     * @example
     * // Get one Mock_categories
     * const mock_categories = await prisma.mock_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mock_categoriesFindFirstArgs>(args?: SelectSubset<T, mock_categoriesFindFirstArgs<ExtArgs>>): Prisma__mock_categoriesClient<$Result.GetResult<Prisma.$mock_categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mock_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_categoriesFindFirstOrThrowArgs} args - Arguments to find a Mock_categories
     * @example
     * // Get one Mock_categories
     * const mock_categories = await prisma.mock_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mock_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, mock_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__mock_categoriesClient<$Result.GetResult<Prisma.$mock_categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mock_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mock_categories
     * const mock_categories = await prisma.mock_categories.findMany()
     * 
     * // Get first 10 Mock_categories
     * const mock_categories = await prisma.mock_categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mock_categoriesWithIdOnly = await prisma.mock_categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mock_categoriesFindManyArgs>(args?: SelectSubset<T, mock_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mock_categories.
     * @param {mock_categoriesCreateArgs} args - Arguments to create a Mock_categories.
     * @example
     * // Create one Mock_categories
     * const Mock_categories = await prisma.mock_categories.create({
     *   data: {
     *     // ... data to create a Mock_categories
     *   }
     * })
     * 
     */
    create<T extends mock_categoriesCreateArgs>(args: SelectSubset<T, mock_categoriesCreateArgs<ExtArgs>>): Prisma__mock_categoriesClient<$Result.GetResult<Prisma.$mock_categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mock_categories.
     * @param {mock_categoriesCreateManyArgs} args - Arguments to create many Mock_categories.
     * @example
     * // Create many Mock_categories
     * const mock_categories = await prisma.mock_categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mock_categoriesCreateManyArgs>(args?: SelectSubset<T, mock_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mock_categories and returns the data saved in the database.
     * @param {mock_categoriesCreateManyAndReturnArgs} args - Arguments to create many Mock_categories.
     * @example
     * // Create many Mock_categories
     * const mock_categories = await prisma.mock_categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mock_categories and only return the `id`
     * const mock_categoriesWithIdOnly = await prisma.mock_categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mock_categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, mock_categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_categoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mock_categories.
     * @param {mock_categoriesDeleteArgs} args - Arguments to delete one Mock_categories.
     * @example
     * // Delete one Mock_categories
     * const Mock_categories = await prisma.mock_categories.delete({
     *   where: {
     *     // ... filter to delete one Mock_categories
     *   }
     * })
     * 
     */
    delete<T extends mock_categoriesDeleteArgs>(args: SelectSubset<T, mock_categoriesDeleteArgs<ExtArgs>>): Prisma__mock_categoriesClient<$Result.GetResult<Prisma.$mock_categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mock_categories.
     * @param {mock_categoriesUpdateArgs} args - Arguments to update one Mock_categories.
     * @example
     * // Update one Mock_categories
     * const mock_categories = await prisma.mock_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mock_categoriesUpdateArgs>(args: SelectSubset<T, mock_categoriesUpdateArgs<ExtArgs>>): Prisma__mock_categoriesClient<$Result.GetResult<Prisma.$mock_categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mock_categories.
     * @param {mock_categoriesDeleteManyArgs} args - Arguments to filter Mock_categories to delete.
     * @example
     * // Delete a few Mock_categories
     * const { count } = await prisma.mock_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mock_categoriesDeleteManyArgs>(args?: SelectSubset<T, mock_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mock_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mock_categories
     * const mock_categories = await prisma.mock_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mock_categoriesUpdateManyArgs>(args: SelectSubset<T, mock_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mock_categories and returns the data updated in the database.
     * @param {mock_categoriesUpdateManyAndReturnArgs} args - Arguments to update many Mock_categories.
     * @example
     * // Update many Mock_categories
     * const mock_categories = await prisma.mock_categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mock_categories and only return the `id`
     * const mock_categoriesWithIdOnly = await prisma.mock_categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mock_categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, mock_categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_categoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mock_categories.
     * @param {mock_categoriesUpsertArgs} args - Arguments to update or create a Mock_categories.
     * @example
     * // Update or create a Mock_categories
     * const mock_categories = await prisma.mock_categories.upsert({
     *   create: {
     *     // ... data to create a Mock_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mock_categories we want to update
     *   }
     * })
     */
    upsert<T extends mock_categoriesUpsertArgs>(args: SelectSubset<T, mock_categoriesUpsertArgs<ExtArgs>>): Prisma__mock_categoriesClient<$Result.GetResult<Prisma.$mock_categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mock_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_categoriesCountArgs} args - Arguments to filter Mock_categories to count.
     * @example
     * // Count the number of Mock_categories
     * const count = await prisma.mock_categories.count({
     *   where: {
     *     // ... the filter for the Mock_categories we want to count
     *   }
     * })
    **/
    count<T extends mock_categoriesCountArgs>(
      args?: Subset<T, mock_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mock_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mock_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mock_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mock_categoriesAggregateArgs>(args: Subset<T, Mock_categoriesAggregateArgs>): Prisma.PrismaPromise<GetMock_categoriesAggregateType<T>>

    /**
     * Group by Mock_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mock_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mock_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: mock_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mock_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMock_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mock_categories model
   */
  readonly fields: mock_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mock_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mock_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mock_series<T extends mock_categories$mock_seriesArgs<ExtArgs> = {}>(args?: Subset<T, mock_categories$mock_seriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_seriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mock_categories model
   */
  interface mock_categoriesFieldRefs {
    readonly id: FieldRef<"mock_categories", 'BigInt'>
    readonly name: FieldRef<"mock_categories", 'String'>
    readonly description: FieldRef<"mock_categories", 'String'>
  }
    

  // Custom InputTypes
  /**
   * mock_categories findUnique
   */
  export type mock_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_categories
     */
    select?: mock_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_categories
     */
    omit?: mock_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which mock_categories to fetch.
     */
    where: mock_categoriesWhereUniqueInput
  }

  /**
   * mock_categories findUniqueOrThrow
   */
  export type mock_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_categories
     */
    select?: mock_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_categories
     */
    omit?: mock_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which mock_categories to fetch.
     */
    where: mock_categoriesWhereUniqueInput
  }

  /**
   * mock_categories findFirst
   */
  export type mock_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_categories
     */
    select?: mock_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_categories
     */
    omit?: mock_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which mock_categories to fetch.
     */
    where?: mock_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_categories to fetch.
     */
    orderBy?: mock_categoriesOrderByWithRelationInput | mock_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mock_categories.
     */
    cursor?: mock_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mock_categories.
     */
    distinct?: Mock_categoriesScalarFieldEnum | Mock_categoriesScalarFieldEnum[]
  }

  /**
   * mock_categories findFirstOrThrow
   */
  export type mock_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_categories
     */
    select?: mock_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_categories
     */
    omit?: mock_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which mock_categories to fetch.
     */
    where?: mock_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_categories to fetch.
     */
    orderBy?: mock_categoriesOrderByWithRelationInput | mock_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mock_categories.
     */
    cursor?: mock_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mock_categories.
     */
    distinct?: Mock_categoriesScalarFieldEnum | Mock_categoriesScalarFieldEnum[]
  }

  /**
   * mock_categories findMany
   */
  export type mock_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_categories
     */
    select?: mock_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_categories
     */
    omit?: mock_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which mock_categories to fetch.
     */
    where?: mock_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_categories to fetch.
     */
    orderBy?: mock_categoriesOrderByWithRelationInput | mock_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mock_categories.
     */
    cursor?: mock_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_categories.
     */
    skip?: number
    distinct?: Mock_categoriesScalarFieldEnum | Mock_categoriesScalarFieldEnum[]
  }

  /**
   * mock_categories create
   */
  export type mock_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_categories
     */
    select?: mock_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_categories
     */
    omit?: mock_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a mock_categories.
     */
    data: XOR<mock_categoriesCreateInput, mock_categoriesUncheckedCreateInput>
  }

  /**
   * mock_categories createMany
   */
  export type mock_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mock_categories.
     */
    data: mock_categoriesCreateManyInput | mock_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mock_categories createManyAndReturn
   */
  export type mock_categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_categories
     */
    select?: mock_categoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mock_categories
     */
    omit?: mock_categoriesOmit<ExtArgs> | null
    /**
     * The data used to create many mock_categories.
     */
    data: mock_categoriesCreateManyInput | mock_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mock_categories update
   */
  export type mock_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_categories
     */
    select?: mock_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_categories
     */
    omit?: mock_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a mock_categories.
     */
    data: XOR<mock_categoriesUpdateInput, mock_categoriesUncheckedUpdateInput>
    /**
     * Choose, which mock_categories to update.
     */
    where: mock_categoriesWhereUniqueInput
  }

  /**
   * mock_categories updateMany
   */
  export type mock_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mock_categories.
     */
    data: XOR<mock_categoriesUpdateManyMutationInput, mock_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which mock_categories to update
     */
    where?: mock_categoriesWhereInput
    /**
     * Limit how many mock_categories to update.
     */
    limit?: number
  }

  /**
   * mock_categories updateManyAndReturn
   */
  export type mock_categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_categories
     */
    select?: mock_categoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mock_categories
     */
    omit?: mock_categoriesOmit<ExtArgs> | null
    /**
     * The data used to update mock_categories.
     */
    data: XOR<mock_categoriesUpdateManyMutationInput, mock_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which mock_categories to update
     */
    where?: mock_categoriesWhereInput
    /**
     * Limit how many mock_categories to update.
     */
    limit?: number
  }

  /**
   * mock_categories upsert
   */
  export type mock_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_categories
     */
    select?: mock_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_categories
     */
    omit?: mock_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the mock_categories to update in case it exists.
     */
    where: mock_categoriesWhereUniqueInput
    /**
     * In case the mock_categories found by the `where` argument doesn't exist, create a new mock_categories with this data.
     */
    create: XOR<mock_categoriesCreateInput, mock_categoriesUncheckedCreateInput>
    /**
     * In case the mock_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mock_categoriesUpdateInput, mock_categoriesUncheckedUpdateInput>
  }

  /**
   * mock_categories delete
   */
  export type mock_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_categories
     */
    select?: mock_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_categories
     */
    omit?: mock_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_categoriesInclude<ExtArgs> | null
    /**
     * Filter which mock_categories to delete.
     */
    where: mock_categoriesWhereUniqueInput
  }

  /**
   * mock_categories deleteMany
   */
  export type mock_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mock_categories to delete
     */
    where?: mock_categoriesWhereInput
    /**
     * Limit how many mock_categories to delete.
     */
    limit?: number
  }

  /**
   * mock_categories.mock_series
   */
  export type mock_categories$mock_seriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_series
     */
    select?: mock_seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_series
     */
    omit?: mock_seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_seriesInclude<ExtArgs> | null
    where?: mock_seriesWhereInput
    orderBy?: mock_seriesOrderByWithRelationInput | mock_seriesOrderByWithRelationInput[]
    cursor?: mock_seriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Mock_seriesScalarFieldEnum | Mock_seriesScalarFieldEnum[]
  }

  /**
   * mock_categories without action
   */
  export type mock_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_categories
     */
    select?: mock_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_categories
     */
    omit?: mock_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_categoriesInclude<ExtArgs> | null
  }


  /**
   * Model mock_questions
   */

  export type AggregateMock_questions = {
    _count: Mock_questionsCountAggregateOutputType | null
    _avg: Mock_questionsAvgAggregateOutputType | null
    _sum: Mock_questionsSumAggregateOutputType | null
    _min: Mock_questionsMinAggregateOutputType | null
    _max: Mock_questionsMaxAggregateOutputType | null
  }

  export type Mock_questionsAvgAggregateOutputType = {
    id: number | null
    test_id: number | null
    marks: number | null
  }

  export type Mock_questionsSumAggregateOutputType = {
    id: bigint | null
    test_id: bigint | null
    marks: number | null
  }

  export type Mock_questionsMinAggregateOutputType = {
    id: bigint | null
    test_id: bigint | null
    question_text: string | null
    question_type: $Enums.question_type | null
    correct_answer: string | null
    marks: number | null
  }

  export type Mock_questionsMaxAggregateOutputType = {
    id: bigint | null
    test_id: bigint | null
    question_text: string | null
    question_type: $Enums.question_type | null
    correct_answer: string | null
    marks: number | null
  }

  export type Mock_questionsCountAggregateOutputType = {
    id: number
    test_id: number
    question_text: number
    question_type: number
    options: number
    correct_answer: number
    marks: number
    _all: number
  }


  export type Mock_questionsAvgAggregateInputType = {
    id?: true
    test_id?: true
    marks?: true
  }

  export type Mock_questionsSumAggregateInputType = {
    id?: true
    test_id?: true
    marks?: true
  }

  export type Mock_questionsMinAggregateInputType = {
    id?: true
    test_id?: true
    question_text?: true
    question_type?: true
    correct_answer?: true
    marks?: true
  }

  export type Mock_questionsMaxAggregateInputType = {
    id?: true
    test_id?: true
    question_text?: true
    question_type?: true
    correct_answer?: true
    marks?: true
  }

  export type Mock_questionsCountAggregateInputType = {
    id?: true
    test_id?: true
    question_text?: true
    question_type?: true
    options?: true
    correct_answer?: true
    marks?: true
    _all?: true
  }

  export type Mock_questionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mock_questions to aggregate.
     */
    where?: mock_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_questions to fetch.
     */
    orderBy?: mock_questionsOrderByWithRelationInput | mock_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mock_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mock_questions
    **/
    _count?: true | Mock_questionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Mock_questionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Mock_questionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mock_questionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mock_questionsMaxAggregateInputType
  }

  export type GetMock_questionsAggregateType<T extends Mock_questionsAggregateArgs> = {
        [P in keyof T & keyof AggregateMock_questions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMock_questions[P]>
      : GetScalarType<T[P], AggregateMock_questions[P]>
  }




  export type mock_questionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mock_questionsWhereInput
    orderBy?: mock_questionsOrderByWithAggregationInput | mock_questionsOrderByWithAggregationInput[]
    by: Mock_questionsScalarFieldEnum[] | Mock_questionsScalarFieldEnum
    having?: mock_questionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mock_questionsCountAggregateInputType | true
    _avg?: Mock_questionsAvgAggregateInputType
    _sum?: Mock_questionsSumAggregateInputType
    _min?: Mock_questionsMinAggregateInputType
    _max?: Mock_questionsMaxAggregateInputType
  }

  export type Mock_questionsGroupByOutputType = {
    id: bigint
    test_id: bigint | null
    question_text: string
    question_type: $Enums.question_type | null
    options: JsonValue | null
    correct_answer: string
    marks: number | null
    _count: Mock_questionsCountAggregateOutputType | null
    _avg: Mock_questionsAvgAggregateOutputType | null
    _sum: Mock_questionsSumAggregateOutputType | null
    _min: Mock_questionsMinAggregateOutputType | null
    _max: Mock_questionsMaxAggregateOutputType | null
  }

  type GetMock_questionsGroupByPayload<T extends mock_questionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mock_questionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mock_questionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mock_questionsGroupByOutputType[P]>
            : GetScalarType<T[P], Mock_questionsGroupByOutputType[P]>
        }
      >
    >


  export type mock_questionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    test_id?: boolean
    question_text?: boolean
    question_type?: boolean
    options?: boolean
    correct_answer?: boolean
    marks?: boolean
    mock_tests?: boolean | mock_questions$mock_testsArgs<ExtArgs>
  }, ExtArgs["result"]["mock_questions"]>

  export type mock_questionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    test_id?: boolean
    question_text?: boolean
    question_type?: boolean
    options?: boolean
    correct_answer?: boolean
    marks?: boolean
    mock_tests?: boolean | mock_questions$mock_testsArgs<ExtArgs>
  }, ExtArgs["result"]["mock_questions"]>

  export type mock_questionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    test_id?: boolean
    question_text?: boolean
    question_type?: boolean
    options?: boolean
    correct_answer?: boolean
    marks?: boolean
    mock_tests?: boolean | mock_questions$mock_testsArgs<ExtArgs>
  }, ExtArgs["result"]["mock_questions"]>

  export type mock_questionsSelectScalar = {
    id?: boolean
    test_id?: boolean
    question_text?: boolean
    question_type?: boolean
    options?: boolean
    correct_answer?: boolean
    marks?: boolean
  }

  export type mock_questionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "test_id" | "question_text" | "question_type" | "options" | "correct_answer" | "marks", ExtArgs["result"]["mock_questions"]>
  export type mock_questionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mock_tests?: boolean | mock_questions$mock_testsArgs<ExtArgs>
  }
  export type mock_questionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mock_tests?: boolean | mock_questions$mock_testsArgs<ExtArgs>
  }
  export type mock_questionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mock_tests?: boolean | mock_questions$mock_testsArgs<ExtArgs>
  }

  export type $mock_questionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mock_questions"
    objects: {
      mock_tests: Prisma.$mock_testsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      test_id: bigint | null
      question_text: string
      question_type: $Enums.question_type | null
      options: Prisma.JsonValue | null
      correct_answer: string
      marks: number | null
    }, ExtArgs["result"]["mock_questions"]>
    composites: {}
  }

  type mock_questionsGetPayload<S extends boolean | null | undefined | mock_questionsDefaultArgs> = $Result.GetResult<Prisma.$mock_questionsPayload, S>

  type mock_questionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mock_questionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Mock_questionsCountAggregateInputType | true
    }

  export interface mock_questionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mock_questions'], meta: { name: 'mock_questions' } }
    /**
     * Find zero or one Mock_questions that matches the filter.
     * @param {mock_questionsFindUniqueArgs} args - Arguments to find a Mock_questions
     * @example
     * // Get one Mock_questions
     * const mock_questions = await prisma.mock_questions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mock_questionsFindUniqueArgs>(args: SelectSubset<T, mock_questionsFindUniqueArgs<ExtArgs>>): Prisma__mock_questionsClient<$Result.GetResult<Prisma.$mock_questionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mock_questions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mock_questionsFindUniqueOrThrowArgs} args - Arguments to find a Mock_questions
     * @example
     * // Get one Mock_questions
     * const mock_questions = await prisma.mock_questions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mock_questionsFindUniqueOrThrowArgs>(args: SelectSubset<T, mock_questionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mock_questionsClient<$Result.GetResult<Prisma.$mock_questionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mock_questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_questionsFindFirstArgs} args - Arguments to find a Mock_questions
     * @example
     * // Get one Mock_questions
     * const mock_questions = await prisma.mock_questions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mock_questionsFindFirstArgs>(args?: SelectSubset<T, mock_questionsFindFirstArgs<ExtArgs>>): Prisma__mock_questionsClient<$Result.GetResult<Prisma.$mock_questionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mock_questions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_questionsFindFirstOrThrowArgs} args - Arguments to find a Mock_questions
     * @example
     * // Get one Mock_questions
     * const mock_questions = await prisma.mock_questions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mock_questionsFindFirstOrThrowArgs>(args?: SelectSubset<T, mock_questionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__mock_questionsClient<$Result.GetResult<Prisma.$mock_questionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mock_questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_questionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mock_questions
     * const mock_questions = await prisma.mock_questions.findMany()
     * 
     * // Get first 10 Mock_questions
     * const mock_questions = await prisma.mock_questions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mock_questionsWithIdOnly = await prisma.mock_questions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mock_questionsFindManyArgs>(args?: SelectSubset<T, mock_questionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_questionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mock_questions.
     * @param {mock_questionsCreateArgs} args - Arguments to create a Mock_questions.
     * @example
     * // Create one Mock_questions
     * const Mock_questions = await prisma.mock_questions.create({
     *   data: {
     *     // ... data to create a Mock_questions
     *   }
     * })
     * 
     */
    create<T extends mock_questionsCreateArgs>(args: SelectSubset<T, mock_questionsCreateArgs<ExtArgs>>): Prisma__mock_questionsClient<$Result.GetResult<Prisma.$mock_questionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mock_questions.
     * @param {mock_questionsCreateManyArgs} args - Arguments to create many Mock_questions.
     * @example
     * // Create many Mock_questions
     * const mock_questions = await prisma.mock_questions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mock_questionsCreateManyArgs>(args?: SelectSubset<T, mock_questionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mock_questions and returns the data saved in the database.
     * @param {mock_questionsCreateManyAndReturnArgs} args - Arguments to create many Mock_questions.
     * @example
     * // Create many Mock_questions
     * const mock_questions = await prisma.mock_questions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mock_questions and only return the `id`
     * const mock_questionsWithIdOnly = await prisma.mock_questions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mock_questionsCreateManyAndReturnArgs>(args?: SelectSubset<T, mock_questionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_questionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mock_questions.
     * @param {mock_questionsDeleteArgs} args - Arguments to delete one Mock_questions.
     * @example
     * // Delete one Mock_questions
     * const Mock_questions = await prisma.mock_questions.delete({
     *   where: {
     *     // ... filter to delete one Mock_questions
     *   }
     * })
     * 
     */
    delete<T extends mock_questionsDeleteArgs>(args: SelectSubset<T, mock_questionsDeleteArgs<ExtArgs>>): Prisma__mock_questionsClient<$Result.GetResult<Prisma.$mock_questionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mock_questions.
     * @param {mock_questionsUpdateArgs} args - Arguments to update one Mock_questions.
     * @example
     * // Update one Mock_questions
     * const mock_questions = await prisma.mock_questions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mock_questionsUpdateArgs>(args: SelectSubset<T, mock_questionsUpdateArgs<ExtArgs>>): Prisma__mock_questionsClient<$Result.GetResult<Prisma.$mock_questionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mock_questions.
     * @param {mock_questionsDeleteManyArgs} args - Arguments to filter Mock_questions to delete.
     * @example
     * // Delete a few Mock_questions
     * const { count } = await prisma.mock_questions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mock_questionsDeleteManyArgs>(args?: SelectSubset<T, mock_questionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mock_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_questionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mock_questions
     * const mock_questions = await prisma.mock_questions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mock_questionsUpdateManyArgs>(args: SelectSubset<T, mock_questionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mock_questions and returns the data updated in the database.
     * @param {mock_questionsUpdateManyAndReturnArgs} args - Arguments to update many Mock_questions.
     * @example
     * // Update many Mock_questions
     * const mock_questions = await prisma.mock_questions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mock_questions and only return the `id`
     * const mock_questionsWithIdOnly = await prisma.mock_questions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mock_questionsUpdateManyAndReturnArgs>(args: SelectSubset<T, mock_questionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_questionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mock_questions.
     * @param {mock_questionsUpsertArgs} args - Arguments to update or create a Mock_questions.
     * @example
     * // Update or create a Mock_questions
     * const mock_questions = await prisma.mock_questions.upsert({
     *   create: {
     *     // ... data to create a Mock_questions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mock_questions we want to update
     *   }
     * })
     */
    upsert<T extends mock_questionsUpsertArgs>(args: SelectSubset<T, mock_questionsUpsertArgs<ExtArgs>>): Prisma__mock_questionsClient<$Result.GetResult<Prisma.$mock_questionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mock_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_questionsCountArgs} args - Arguments to filter Mock_questions to count.
     * @example
     * // Count the number of Mock_questions
     * const count = await prisma.mock_questions.count({
     *   where: {
     *     // ... the filter for the Mock_questions we want to count
     *   }
     * })
    **/
    count<T extends mock_questionsCountArgs>(
      args?: Subset<T, mock_questionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mock_questionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mock_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mock_questionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mock_questionsAggregateArgs>(args: Subset<T, Mock_questionsAggregateArgs>): Prisma.PrismaPromise<GetMock_questionsAggregateType<T>>

    /**
     * Group by Mock_questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_questionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mock_questionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mock_questionsGroupByArgs['orderBy'] }
        : { orderBy?: mock_questionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mock_questionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMock_questionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mock_questions model
   */
  readonly fields: mock_questionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mock_questions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mock_questionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mock_tests<T extends mock_questions$mock_testsArgs<ExtArgs> = {}>(args?: Subset<T, mock_questions$mock_testsArgs<ExtArgs>>): Prisma__mock_testsClient<$Result.GetResult<Prisma.$mock_testsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mock_questions model
   */
  interface mock_questionsFieldRefs {
    readonly id: FieldRef<"mock_questions", 'BigInt'>
    readonly test_id: FieldRef<"mock_questions", 'BigInt'>
    readonly question_text: FieldRef<"mock_questions", 'String'>
    readonly question_type: FieldRef<"mock_questions", 'question_type'>
    readonly options: FieldRef<"mock_questions", 'Json'>
    readonly correct_answer: FieldRef<"mock_questions", 'String'>
    readonly marks: FieldRef<"mock_questions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * mock_questions findUnique
   */
  export type mock_questionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_questions
     */
    select?: mock_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_questions
     */
    omit?: mock_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_questionsInclude<ExtArgs> | null
    /**
     * Filter, which mock_questions to fetch.
     */
    where: mock_questionsWhereUniqueInput
  }

  /**
   * mock_questions findUniqueOrThrow
   */
  export type mock_questionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_questions
     */
    select?: mock_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_questions
     */
    omit?: mock_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_questionsInclude<ExtArgs> | null
    /**
     * Filter, which mock_questions to fetch.
     */
    where: mock_questionsWhereUniqueInput
  }

  /**
   * mock_questions findFirst
   */
  export type mock_questionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_questions
     */
    select?: mock_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_questions
     */
    omit?: mock_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_questionsInclude<ExtArgs> | null
    /**
     * Filter, which mock_questions to fetch.
     */
    where?: mock_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_questions to fetch.
     */
    orderBy?: mock_questionsOrderByWithRelationInput | mock_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mock_questions.
     */
    cursor?: mock_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mock_questions.
     */
    distinct?: Mock_questionsScalarFieldEnum | Mock_questionsScalarFieldEnum[]
  }

  /**
   * mock_questions findFirstOrThrow
   */
  export type mock_questionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_questions
     */
    select?: mock_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_questions
     */
    omit?: mock_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_questionsInclude<ExtArgs> | null
    /**
     * Filter, which mock_questions to fetch.
     */
    where?: mock_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_questions to fetch.
     */
    orderBy?: mock_questionsOrderByWithRelationInput | mock_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mock_questions.
     */
    cursor?: mock_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mock_questions.
     */
    distinct?: Mock_questionsScalarFieldEnum | Mock_questionsScalarFieldEnum[]
  }

  /**
   * mock_questions findMany
   */
  export type mock_questionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_questions
     */
    select?: mock_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_questions
     */
    omit?: mock_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_questionsInclude<ExtArgs> | null
    /**
     * Filter, which mock_questions to fetch.
     */
    where?: mock_questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_questions to fetch.
     */
    orderBy?: mock_questionsOrderByWithRelationInput | mock_questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mock_questions.
     */
    cursor?: mock_questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_questions.
     */
    skip?: number
    distinct?: Mock_questionsScalarFieldEnum | Mock_questionsScalarFieldEnum[]
  }

  /**
   * mock_questions create
   */
  export type mock_questionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_questions
     */
    select?: mock_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_questions
     */
    omit?: mock_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_questionsInclude<ExtArgs> | null
    /**
     * The data needed to create a mock_questions.
     */
    data: XOR<mock_questionsCreateInput, mock_questionsUncheckedCreateInput>
  }

  /**
   * mock_questions createMany
   */
  export type mock_questionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mock_questions.
     */
    data: mock_questionsCreateManyInput | mock_questionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mock_questions createManyAndReturn
   */
  export type mock_questionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_questions
     */
    select?: mock_questionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mock_questions
     */
    omit?: mock_questionsOmit<ExtArgs> | null
    /**
     * The data used to create many mock_questions.
     */
    data: mock_questionsCreateManyInput | mock_questionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_questionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * mock_questions update
   */
  export type mock_questionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_questions
     */
    select?: mock_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_questions
     */
    omit?: mock_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_questionsInclude<ExtArgs> | null
    /**
     * The data needed to update a mock_questions.
     */
    data: XOR<mock_questionsUpdateInput, mock_questionsUncheckedUpdateInput>
    /**
     * Choose, which mock_questions to update.
     */
    where: mock_questionsWhereUniqueInput
  }

  /**
   * mock_questions updateMany
   */
  export type mock_questionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mock_questions.
     */
    data: XOR<mock_questionsUpdateManyMutationInput, mock_questionsUncheckedUpdateManyInput>
    /**
     * Filter which mock_questions to update
     */
    where?: mock_questionsWhereInput
    /**
     * Limit how many mock_questions to update.
     */
    limit?: number
  }

  /**
   * mock_questions updateManyAndReturn
   */
  export type mock_questionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_questions
     */
    select?: mock_questionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mock_questions
     */
    omit?: mock_questionsOmit<ExtArgs> | null
    /**
     * The data used to update mock_questions.
     */
    data: XOR<mock_questionsUpdateManyMutationInput, mock_questionsUncheckedUpdateManyInput>
    /**
     * Filter which mock_questions to update
     */
    where?: mock_questionsWhereInput
    /**
     * Limit how many mock_questions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_questionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * mock_questions upsert
   */
  export type mock_questionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_questions
     */
    select?: mock_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_questions
     */
    omit?: mock_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_questionsInclude<ExtArgs> | null
    /**
     * The filter to search for the mock_questions to update in case it exists.
     */
    where: mock_questionsWhereUniqueInput
    /**
     * In case the mock_questions found by the `where` argument doesn't exist, create a new mock_questions with this data.
     */
    create: XOR<mock_questionsCreateInput, mock_questionsUncheckedCreateInput>
    /**
     * In case the mock_questions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mock_questionsUpdateInput, mock_questionsUncheckedUpdateInput>
  }

  /**
   * mock_questions delete
   */
  export type mock_questionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_questions
     */
    select?: mock_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_questions
     */
    omit?: mock_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_questionsInclude<ExtArgs> | null
    /**
     * Filter which mock_questions to delete.
     */
    where: mock_questionsWhereUniqueInput
  }

  /**
   * mock_questions deleteMany
   */
  export type mock_questionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mock_questions to delete
     */
    where?: mock_questionsWhereInput
    /**
     * Limit how many mock_questions to delete.
     */
    limit?: number
  }

  /**
   * mock_questions.mock_tests
   */
  export type mock_questions$mock_testsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_tests
     */
    select?: mock_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_tests
     */
    omit?: mock_testsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_testsInclude<ExtArgs> | null
    where?: mock_testsWhereInput
  }

  /**
   * mock_questions without action
   */
  export type mock_questionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_questions
     */
    select?: mock_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_questions
     */
    omit?: mock_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_questionsInclude<ExtArgs> | null
  }


  /**
   * Model mock_series
   */

  export type AggregateMock_series = {
    _count: Mock_seriesCountAggregateOutputType | null
    _avg: Mock_seriesAvgAggregateOutputType | null
    _sum: Mock_seriesSumAggregateOutputType | null
    _min: Mock_seriesMinAggregateOutputType | null
    _max: Mock_seriesMaxAggregateOutputType | null
  }

  export type Mock_seriesAvgAggregateOutputType = {
    id: number | null
    category_id: number | null
    price: Decimal | null
  }

  export type Mock_seriesSumAggregateOutputType = {
    id: bigint | null
    category_id: bigint | null
    price: Decimal | null
  }

  export type Mock_seriesMinAggregateOutputType = {
    id: bigint | null
    category_id: bigint | null
    title: string | null
    description: string | null
    created_at: Date | null
    price: Decimal | null
  }

  export type Mock_seriesMaxAggregateOutputType = {
    id: bigint | null
    category_id: bigint | null
    title: string | null
    description: string | null
    created_at: Date | null
    price: Decimal | null
  }

  export type Mock_seriesCountAggregateOutputType = {
    id: number
    category_id: number
    title: number
    description: number
    created_at: number
    price: number
    _all: number
  }


  export type Mock_seriesAvgAggregateInputType = {
    id?: true
    category_id?: true
    price?: true
  }

  export type Mock_seriesSumAggregateInputType = {
    id?: true
    category_id?: true
    price?: true
  }

  export type Mock_seriesMinAggregateInputType = {
    id?: true
    category_id?: true
    title?: true
    description?: true
    created_at?: true
    price?: true
  }

  export type Mock_seriesMaxAggregateInputType = {
    id?: true
    category_id?: true
    title?: true
    description?: true
    created_at?: true
    price?: true
  }

  export type Mock_seriesCountAggregateInputType = {
    id?: true
    category_id?: true
    title?: true
    description?: true
    created_at?: true
    price?: true
    _all?: true
  }

  export type Mock_seriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mock_series to aggregate.
     */
    where?: mock_seriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_series to fetch.
     */
    orderBy?: mock_seriesOrderByWithRelationInput | mock_seriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mock_seriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mock_series
    **/
    _count?: true | Mock_seriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Mock_seriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Mock_seriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mock_seriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mock_seriesMaxAggregateInputType
  }

  export type GetMock_seriesAggregateType<T extends Mock_seriesAggregateArgs> = {
        [P in keyof T & keyof AggregateMock_series]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMock_series[P]>
      : GetScalarType<T[P], AggregateMock_series[P]>
  }




  export type mock_seriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mock_seriesWhereInput
    orderBy?: mock_seriesOrderByWithAggregationInput | mock_seriesOrderByWithAggregationInput[]
    by: Mock_seriesScalarFieldEnum[] | Mock_seriesScalarFieldEnum
    having?: mock_seriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mock_seriesCountAggregateInputType | true
    _avg?: Mock_seriesAvgAggregateInputType
    _sum?: Mock_seriesSumAggregateInputType
    _min?: Mock_seriesMinAggregateInputType
    _max?: Mock_seriesMaxAggregateInputType
  }

  export type Mock_seriesGroupByOutputType = {
    id: bigint
    category_id: bigint | null
    title: string
    description: string | null
    created_at: Date | null
    price: Decimal | null
    _count: Mock_seriesCountAggregateOutputType | null
    _avg: Mock_seriesAvgAggregateOutputType | null
    _sum: Mock_seriesSumAggregateOutputType | null
    _min: Mock_seriesMinAggregateOutputType | null
    _max: Mock_seriesMaxAggregateOutputType | null
  }

  type GetMock_seriesGroupByPayload<T extends mock_seriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mock_seriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mock_seriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mock_seriesGroupByOutputType[P]>
            : GetScalarType<T[P], Mock_seriesGroupByOutputType[P]>
        }
      >
    >


  export type mock_seriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_id?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
    price?: boolean
    mock_categories?: boolean | mock_series$mock_categoriesArgs<ExtArgs>
    mock_tests?: boolean | mock_series$mock_testsArgs<ExtArgs>
    payments?: boolean | mock_series$paymentsArgs<ExtArgs>
    _count?: boolean | Mock_seriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mock_series"]>

  export type mock_seriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_id?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
    price?: boolean
    mock_categories?: boolean | mock_series$mock_categoriesArgs<ExtArgs>
  }, ExtArgs["result"]["mock_series"]>

  export type mock_seriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_id?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
    price?: boolean
    mock_categories?: boolean | mock_series$mock_categoriesArgs<ExtArgs>
  }, ExtArgs["result"]["mock_series"]>

  export type mock_seriesSelectScalar = {
    id?: boolean
    category_id?: boolean
    title?: boolean
    description?: boolean
    created_at?: boolean
    price?: boolean
  }

  export type mock_seriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category_id" | "title" | "description" | "created_at" | "price", ExtArgs["result"]["mock_series"]>
  export type mock_seriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mock_categories?: boolean | mock_series$mock_categoriesArgs<ExtArgs>
    mock_tests?: boolean | mock_series$mock_testsArgs<ExtArgs>
    payments?: boolean | mock_series$paymentsArgs<ExtArgs>
    _count?: boolean | Mock_seriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type mock_seriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mock_categories?: boolean | mock_series$mock_categoriesArgs<ExtArgs>
  }
  export type mock_seriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mock_categories?: boolean | mock_series$mock_categoriesArgs<ExtArgs>
  }

  export type $mock_seriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mock_series"
    objects: {
      mock_categories: Prisma.$mock_categoriesPayload<ExtArgs> | null
      mock_tests: Prisma.$mock_testsPayload<ExtArgs>[]
      payments: Prisma.$paymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      category_id: bigint | null
      title: string
      description: string | null
      created_at: Date | null
      price: Prisma.Decimal | null
    }, ExtArgs["result"]["mock_series"]>
    composites: {}
  }

  type mock_seriesGetPayload<S extends boolean | null | undefined | mock_seriesDefaultArgs> = $Result.GetResult<Prisma.$mock_seriesPayload, S>

  type mock_seriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mock_seriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Mock_seriesCountAggregateInputType | true
    }

  export interface mock_seriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mock_series'], meta: { name: 'mock_series' } }
    /**
     * Find zero or one Mock_series that matches the filter.
     * @param {mock_seriesFindUniqueArgs} args - Arguments to find a Mock_series
     * @example
     * // Get one Mock_series
     * const mock_series = await prisma.mock_series.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mock_seriesFindUniqueArgs>(args: SelectSubset<T, mock_seriesFindUniqueArgs<ExtArgs>>): Prisma__mock_seriesClient<$Result.GetResult<Prisma.$mock_seriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mock_series that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mock_seriesFindUniqueOrThrowArgs} args - Arguments to find a Mock_series
     * @example
     * // Get one Mock_series
     * const mock_series = await prisma.mock_series.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mock_seriesFindUniqueOrThrowArgs>(args: SelectSubset<T, mock_seriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mock_seriesClient<$Result.GetResult<Prisma.$mock_seriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mock_series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_seriesFindFirstArgs} args - Arguments to find a Mock_series
     * @example
     * // Get one Mock_series
     * const mock_series = await prisma.mock_series.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mock_seriesFindFirstArgs>(args?: SelectSubset<T, mock_seriesFindFirstArgs<ExtArgs>>): Prisma__mock_seriesClient<$Result.GetResult<Prisma.$mock_seriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mock_series that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_seriesFindFirstOrThrowArgs} args - Arguments to find a Mock_series
     * @example
     * // Get one Mock_series
     * const mock_series = await prisma.mock_series.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mock_seriesFindFirstOrThrowArgs>(args?: SelectSubset<T, mock_seriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__mock_seriesClient<$Result.GetResult<Prisma.$mock_seriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mock_series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_seriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mock_series
     * const mock_series = await prisma.mock_series.findMany()
     * 
     * // Get first 10 Mock_series
     * const mock_series = await prisma.mock_series.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mock_seriesWithIdOnly = await prisma.mock_series.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mock_seriesFindManyArgs>(args?: SelectSubset<T, mock_seriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_seriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mock_series.
     * @param {mock_seriesCreateArgs} args - Arguments to create a Mock_series.
     * @example
     * // Create one Mock_series
     * const Mock_series = await prisma.mock_series.create({
     *   data: {
     *     // ... data to create a Mock_series
     *   }
     * })
     * 
     */
    create<T extends mock_seriesCreateArgs>(args: SelectSubset<T, mock_seriesCreateArgs<ExtArgs>>): Prisma__mock_seriesClient<$Result.GetResult<Prisma.$mock_seriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mock_series.
     * @param {mock_seriesCreateManyArgs} args - Arguments to create many Mock_series.
     * @example
     * // Create many Mock_series
     * const mock_series = await prisma.mock_series.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mock_seriesCreateManyArgs>(args?: SelectSubset<T, mock_seriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mock_series and returns the data saved in the database.
     * @param {mock_seriesCreateManyAndReturnArgs} args - Arguments to create many Mock_series.
     * @example
     * // Create many Mock_series
     * const mock_series = await prisma.mock_series.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mock_series and only return the `id`
     * const mock_seriesWithIdOnly = await prisma.mock_series.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mock_seriesCreateManyAndReturnArgs>(args?: SelectSubset<T, mock_seriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_seriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mock_series.
     * @param {mock_seriesDeleteArgs} args - Arguments to delete one Mock_series.
     * @example
     * // Delete one Mock_series
     * const Mock_series = await prisma.mock_series.delete({
     *   where: {
     *     // ... filter to delete one Mock_series
     *   }
     * })
     * 
     */
    delete<T extends mock_seriesDeleteArgs>(args: SelectSubset<T, mock_seriesDeleteArgs<ExtArgs>>): Prisma__mock_seriesClient<$Result.GetResult<Prisma.$mock_seriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mock_series.
     * @param {mock_seriesUpdateArgs} args - Arguments to update one Mock_series.
     * @example
     * // Update one Mock_series
     * const mock_series = await prisma.mock_series.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mock_seriesUpdateArgs>(args: SelectSubset<T, mock_seriesUpdateArgs<ExtArgs>>): Prisma__mock_seriesClient<$Result.GetResult<Prisma.$mock_seriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mock_series.
     * @param {mock_seriesDeleteManyArgs} args - Arguments to filter Mock_series to delete.
     * @example
     * // Delete a few Mock_series
     * const { count } = await prisma.mock_series.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mock_seriesDeleteManyArgs>(args?: SelectSubset<T, mock_seriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mock_series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_seriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mock_series
     * const mock_series = await prisma.mock_series.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mock_seriesUpdateManyArgs>(args: SelectSubset<T, mock_seriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mock_series and returns the data updated in the database.
     * @param {mock_seriesUpdateManyAndReturnArgs} args - Arguments to update many Mock_series.
     * @example
     * // Update many Mock_series
     * const mock_series = await prisma.mock_series.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mock_series and only return the `id`
     * const mock_seriesWithIdOnly = await prisma.mock_series.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mock_seriesUpdateManyAndReturnArgs>(args: SelectSubset<T, mock_seriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_seriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mock_series.
     * @param {mock_seriesUpsertArgs} args - Arguments to update or create a Mock_series.
     * @example
     * // Update or create a Mock_series
     * const mock_series = await prisma.mock_series.upsert({
     *   create: {
     *     // ... data to create a Mock_series
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mock_series we want to update
     *   }
     * })
     */
    upsert<T extends mock_seriesUpsertArgs>(args: SelectSubset<T, mock_seriesUpsertArgs<ExtArgs>>): Prisma__mock_seriesClient<$Result.GetResult<Prisma.$mock_seriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mock_series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_seriesCountArgs} args - Arguments to filter Mock_series to count.
     * @example
     * // Count the number of Mock_series
     * const count = await prisma.mock_series.count({
     *   where: {
     *     // ... the filter for the Mock_series we want to count
     *   }
     * })
    **/
    count<T extends mock_seriesCountArgs>(
      args?: Subset<T, mock_seriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mock_seriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mock_series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mock_seriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mock_seriesAggregateArgs>(args: Subset<T, Mock_seriesAggregateArgs>): Prisma.PrismaPromise<GetMock_seriesAggregateType<T>>

    /**
     * Group by Mock_series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_seriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mock_seriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mock_seriesGroupByArgs['orderBy'] }
        : { orderBy?: mock_seriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mock_seriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMock_seriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mock_series model
   */
  readonly fields: mock_seriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mock_series.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mock_seriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mock_categories<T extends mock_series$mock_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, mock_series$mock_categoriesArgs<ExtArgs>>): Prisma__mock_categoriesClient<$Result.GetResult<Prisma.$mock_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mock_tests<T extends mock_series$mock_testsArgs<ExtArgs> = {}>(args?: Subset<T, mock_series$mock_testsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_testsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends mock_series$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, mock_series$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mock_series model
   */
  interface mock_seriesFieldRefs {
    readonly id: FieldRef<"mock_series", 'BigInt'>
    readonly category_id: FieldRef<"mock_series", 'BigInt'>
    readonly title: FieldRef<"mock_series", 'String'>
    readonly description: FieldRef<"mock_series", 'String'>
    readonly created_at: FieldRef<"mock_series", 'DateTime'>
    readonly price: FieldRef<"mock_series", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * mock_series findUnique
   */
  export type mock_seriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_series
     */
    select?: mock_seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_series
     */
    omit?: mock_seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_seriesInclude<ExtArgs> | null
    /**
     * Filter, which mock_series to fetch.
     */
    where: mock_seriesWhereUniqueInput
  }

  /**
   * mock_series findUniqueOrThrow
   */
  export type mock_seriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_series
     */
    select?: mock_seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_series
     */
    omit?: mock_seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_seriesInclude<ExtArgs> | null
    /**
     * Filter, which mock_series to fetch.
     */
    where: mock_seriesWhereUniqueInput
  }

  /**
   * mock_series findFirst
   */
  export type mock_seriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_series
     */
    select?: mock_seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_series
     */
    omit?: mock_seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_seriesInclude<ExtArgs> | null
    /**
     * Filter, which mock_series to fetch.
     */
    where?: mock_seriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_series to fetch.
     */
    orderBy?: mock_seriesOrderByWithRelationInput | mock_seriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mock_series.
     */
    cursor?: mock_seriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mock_series.
     */
    distinct?: Mock_seriesScalarFieldEnum | Mock_seriesScalarFieldEnum[]
  }

  /**
   * mock_series findFirstOrThrow
   */
  export type mock_seriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_series
     */
    select?: mock_seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_series
     */
    omit?: mock_seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_seriesInclude<ExtArgs> | null
    /**
     * Filter, which mock_series to fetch.
     */
    where?: mock_seriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_series to fetch.
     */
    orderBy?: mock_seriesOrderByWithRelationInput | mock_seriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mock_series.
     */
    cursor?: mock_seriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mock_series.
     */
    distinct?: Mock_seriesScalarFieldEnum | Mock_seriesScalarFieldEnum[]
  }

  /**
   * mock_series findMany
   */
  export type mock_seriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_series
     */
    select?: mock_seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_series
     */
    omit?: mock_seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_seriesInclude<ExtArgs> | null
    /**
     * Filter, which mock_series to fetch.
     */
    where?: mock_seriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_series to fetch.
     */
    orderBy?: mock_seriesOrderByWithRelationInput | mock_seriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mock_series.
     */
    cursor?: mock_seriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_series.
     */
    skip?: number
    distinct?: Mock_seriesScalarFieldEnum | Mock_seriesScalarFieldEnum[]
  }

  /**
   * mock_series create
   */
  export type mock_seriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_series
     */
    select?: mock_seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_series
     */
    omit?: mock_seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_seriesInclude<ExtArgs> | null
    /**
     * The data needed to create a mock_series.
     */
    data: XOR<mock_seriesCreateInput, mock_seriesUncheckedCreateInput>
  }

  /**
   * mock_series createMany
   */
  export type mock_seriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mock_series.
     */
    data: mock_seriesCreateManyInput | mock_seriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mock_series createManyAndReturn
   */
  export type mock_seriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_series
     */
    select?: mock_seriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mock_series
     */
    omit?: mock_seriesOmit<ExtArgs> | null
    /**
     * The data used to create many mock_series.
     */
    data: mock_seriesCreateManyInput | mock_seriesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_seriesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * mock_series update
   */
  export type mock_seriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_series
     */
    select?: mock_seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_series
     */
    omit?: mock_seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_seriesInclude<ExtArgs> | null
    /**
     * The data needed to update a mock_series.
     */
    data: XOR<mock_seriesUpdateInput, mock_seriesUncheckedUpdateInput>
    /**
     * Choose, which mock_series to update.
     */
    where: mock_seriesWhereUniqueInput
  }

  /**
   * mock_series updateMany
   */
  export type mock_seriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mock_series.
     */
    data: XOR<mock_seriesUpdateManyMutationInput, mock_seriesUncheckedUpdateManyInput>
    /**
     * Filter which mock_series to update
     */
    where?: mock_seriesWhereInput
    /**
     * Limit how many mock_series to update.
     */
    limit?: number
  }

  /**
   * mock_series updateManyAndReturn
   */
  export type mock_seriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_series
     */
    select?: mock_seriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mock_series
     */
    omit?: mock_seriesOmit<ExtArgs> | null
    /**
     * The data used to update mock_series.
     */
    data: XOR<mock_seriesUpdateManyMutationInput, mock_seriesUncheckedUpdateManyInput>
    /**
     * Filter which mock_series to update
     */
    where?: mock_seriesWhereInput
    /**
     * Limit how many mock_series to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_seriesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * mock_series upsert
   */
  export type mock_seriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_series
     */
    select?: mock_seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_series
     */
    omit?: mock_seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_seriesInclude<ExtArgs> | null
    /**
     * The filter to search for the mock_series to update in case it exists.
     */
    where: mock_seriesWhereUniqueInput
    /**
     * In case the mock_series found by the `where` argument doesn't exist, create a new mock_series with this data.
     */
    create: XOR<mock_seriesCreateInput, mock_seriesUncheckedCreateInput>
    /**
     * In case the mock_series was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mock_seriesUpdateInput, mock_seriesUncheckedUpdateInput>
  }

  /**
   * mock_series delete
   */
  export type mock_seriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_series
     */
    select?: mock_seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_series
     */
    omit?: mock_seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_seriesInclude<ExtArgs> | null
    /**
     * Filter which mock_series to delete.
     */
    where: mock_seriesWhereUniqueInput
  }

  /**
   * mock_series deleteMany
   */
  export type mock_seriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mock_series to delete
     */
    where?: mock_seriesWhereInput
    /**
     * Limit how many mock_series to delete.
     */
    limit?: number
  }

  /**
   * mock_series.mock_categories
   */
  export type mock_series$mock_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_categories
     */
    select?: mock_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_categories
     */
    omit?: mock_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_categoriesInclude<ExtArgs> | null
    where?: mock_categoriesWhereInput
  }

  /**
   * mock_series.mock_tests
   */
  export type mock_series$mock_testsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_tests
     */
    select?: mock_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_tests
     */
    omit?: mock_testsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_testsInclude<ExtArgs> | null
    where?: mock_testsWhereInput
    orderBy?: mock_testsOrderByWithRelationInput | mock_testsOrderByWithRelationInput[]
    cursor?: mock_testsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Mock_testsScalarFieldEnum | Mock_testsScalarFieldEnum[]
  }

  /**
   * mock_series.payments
   */
  export type mock_series$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * mock_series without action
   */
  export type mock_seriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_series
     */
    select?: mock_seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_series
     */
    omit?: mock_seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_seriesInclude<ExtArgs> | null
  }


  /**
   * Model mock_tests
   */

  export type AggregateMock_tests = {
    _count: Mock_testsCountAggregateOutputType | null
    _avg: Mock_testsAvgAggregateOutputType | null
    _sum: Mock_testsSumAggregateOutputType | null
    _min: Mock_testsMinAggregateOutputType | null
    _max: Mock_testsMaxAggregateOutputType | null
  }

  export type Mock_testsAvgAggregateOutputType = {
    id: number | null
    series_id: number | null
    duration_minutes: number | null
    total_marks: number | null
  }

  export type Mock_testsSumAggregateOutputType = {
    id: bigint | null
    series_id: bigint | null
    duration_minutes: number | null
    total_marks: number | null
  }

  export type Mock_testsMinAggregateOutputType = {
    id: bigint | null
    series_id: bigint | null
    title: string | null
    description: string | null
    duration_minutes: number | null
    total_marks: number | null
    created_at: Date | null
    is_free: boolean | null
  }

  export type Mock_testsMaxAggregateOutputType = {
    id: bigint | null
    series_id: bigint | null
    title: string | null
    description: string | null
    duration_minutes: number | null
    total_marks: number | null
    created_at: Date | null
    is_free: boolean | null
  }

  export type Mock_testsCountAggregateOutputType = {
    id: number
    series_id: number
    title: number
    description: number
    duration_minutes: number
    total_marks: number
    created_at: number
    is_free: number
    _all: number
  }


  export type Mock_testsAvgAggregateInputType = {
    id?: true
    series_id?: true
    duration_minutes?: true
    total_marks?: true
  }

  export type Mock_testsSumAggregateInputType = {
    id?: true
    series_id?: true
    duration_minutes?: true
    total_marks?: true
  }

  export type Mock_testsMinAggregateInputType = {
    id?: true
    series_id?: true
    title?: true
    description?: true
    duration_minutes?: true
    total_marks?: true
    created_at?: true
    is_free?: true
  }

  export type Mock_testsMaxAggregateInputType = {
    id?: true
    series_id?: true
    title?: true
    description?: true
    duration_minutes?: true
    total_marks?: true
    created_at?: true
    is_free?: true
  }

  export type Mock_testsCountAggregateInputType = {
    id?: true
    series_id?: true
    title?: true
    description?: true
    duration_minutes?: true
    total_marks?: true
    created_at?: true
    is_free?: true
    _all?: true
  }

  export type Mock_testsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mock_tests to aggregate.
     */
    where?: mock_testsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_tests to fetch.
     */
    orderBy?: mock_testsOrderByWithRelationInput | mock_testsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mock_testsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mock_tests
    **/
    _count?: true | Mock_testsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Mock_testsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Mock_testsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mock_testsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mock_testsMaxAggregateInputType
  }

  export type GetMock_testsAggregateType<T extends Mock_testsAggregateArgs> = {
        [P in keyof T & keyof AggregateMock_tests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMock_tests[P]>
      : GetScalarType<T[P], AggregateMock_tests[P]>
  }




  export type mock_testsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mock_testsWhereInput
    orderBy?: mock_testsOrderByWithAggregationInput | mock_testsOrderByWithAggregationInput[]
    by: Mock_testsScalarFieldEnum[] | Mock_testsScalarFieldEnum
    having?: mock_testsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mock_testsCountAggregateInputType | true
    _avg?: Mock_testsAvgAggregateInputType
    _sum?: Mock_testsSumAggregateInputType
    _min?: Mock_testsMinAggregateInputType
    _max?: Mock_testsMaxAggregateInputType
  }

  export type Mock_testsGroupByOutputType = {
    id: bigint
    series_id: bigint | null
    title: string
    description: string | null
    duration_minutes: number
    total_marks: number
    created_at: Date | null
    is_free: boolean | null
    _count: Mock_testsCountAggregateOutputType | null
    _avg: Mock_testsAvgAggregateOutputType | null
    _sum: Mock_testsSumAggregateOutputType | null
    _min: Mock_testsMinAggregateOutputType | null
    _max: Mock_testsMaxAggregateOutputType | null
  }

  type GetMock_testsGroupByPayload<T extends mock_testsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mock_testsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mock_testsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mock_testsGroupByOutputType[P]>
            : GetScalarType<T[P], Mock_testsGroupByOutputType[P]>
        }
      >
    >


  export type mock_testsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    series_id?: boolean
    title?: boolean
    description?: boolean
    duration_minutes?: boolean
    total_marks?: boolean
    created_at?: boolean
    is_free?: boolean
    mock_attempts?: boolean | mock_tests$mock_attemptsArgs<ExtArgs>
    mock_questions?: boolean | mock_tests$mock_questionsArgs<ExtArgs>
    mock_series?: boolean | mock_tests$mock_seriesArgs<ExtArgs>
    _count?: boolean | Mock_testsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mock_tests"]>

  export type mock_testsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    series_id?: boolean
    title?: boolean
    description?: boolean
    duration_minutes?: boolean
    total_marks?: boolean
    created_at?: boolean
    is_free?: boolean
    mock_series?: boolean | mock_tests$mock_seriesArgs<ExtArgs>
  }, ExtArgs["result"]["mock_tests"]>

  export type mock_testsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    series_id?: boolean
    title?: boolean
    description?: boolean
    duration_minutes?: boolean
    total_marks?: boolean
    created_at?: boolean
    is_free?: boolean
    mock_series?: boolean | mock_tests$mock_seriesArgs<ExtArgs>
  }, ExtArgs["result"]["mock_tests"]>

  export type mock_testsSelectScalar = {
    id?: boolean
    series_id?: boolean
    title?: boolean
    description?: boolean
    duration_minutes?: boolean
    total_marks?: boolean
    created_at?: boolean
    is_free?: boolean
  }

  export type mock_testsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "series_id" | "title" | "description" | "duration_minutes" | "total_marks" | "created_at" | "is_free", ExtArgs["result"]["mock_tests"]>
  export type mock_testsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mock_attempts?: boolean | mock_tests$mock_attemptsArgs<ExtArgs>
    mock_questions?: boolean | mock_tests$mock_questionsArgs<ExtArgs>
    mock_series?: boolean | mock_tests$mock_seriesArgs<ExtArgs>
    _count?: boolean | Mock_testsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type mock_testsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mock_series?: boolean | mock_tests$mock_seriesArgs<ExtArgs>
  }
  export type mock_testsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mock_series?: boolean | mock_tests$mock_seriesArgs<ExtArgs>
  }

  export type $mock_testsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mock_tests"
    objects: {
      mock_attempts: Prisma.$mock_attemptsPayload<ExtArgs>[]
      mock_questions: Prisma.$mock_questionsPayload<ExtArgs>[]
      mock_series: Prisma.$mock_seriesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      series_id: bigint | null
      title: string
      description: string | null
      duration_minutes: number
      total_marks: number
      created_at: Date | null
      is_free: boolean | null
    }, ExtArgs["result"]["mock_tests"]>
    composites: {}
  }

  type mock_testsGetPayload<S extends boolean | null | undefined | mock_testsDefaultArgs> = $Result.GetResult<Prisma.$mock_testsPayload, S>

  type mock_testsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mock_testsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Mock_testsCountAggregateInputType | true
    }

  export interface mock_testsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mock_tests'], meta: { name: 'mock_tests' } }
    /**
     * Find zero or one Mock_tests that matches the filter.
     * @param {mock_testsFindUniqueArgs} args - Arguments to find a Mock_tests
     * @example
     * // Get one Mock_tests
     * const mock_tests = await prisma.mock_tests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mock_testsFindUniqueArgs>(args: SelectSubset<T, mock_testsFindUniqueArgs<ExtArgs>>): Prisma__mock_testsClient<$Result.GetResult<Prisma.$mock_testsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mock_tests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mock_testsFindUniqueOrThrowArgs} args - Arguments to find a Mock_tests
     * @example
     * // Get one Mock_tests
     * const mock_tests = await prisma.mock_tests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mock_testsFindUniqueOrThrowArgs>(args: SelectSubset<T, mock_testsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mock_testsClient<$Result.GetResult<Prisma.$mock_testsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mock_tests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_testsFindFirstArgs} args - Arguments to find a Mock_tests
     * @example
     * // Get one Mock_tests
     * const mock_tests = await prisma.mock_tests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mock_testsFindFirstArgs>(args?: SelectSubset<T, mock_testsFindFirstArgs<ExtArgs>>): Prisma__mock_testsClient<$Result.GetResult<Prisma.$mock_testsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mock_tests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_testsFindFirstOrThrowArgs} args - Arguments to find a Mock_tests
     * @example
     * // Get one Mock_tests
     * const mock_tests = await prisma.mock_tests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mock_testsFindFirstOrThrowArgs>(args?: SelectSubset<T, mock_testsFindFirstOrThrowArgs<ExtArgs>>): Prisma__mock_testsClient<$Result.GetResult<Prisma.$mock_testsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mock_tests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_testsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mock_tests
     * const mock_tests = await prisma.mock_tests.findMany()
     * 
     * // Get first 10 Mock_tests
     * const mock_tests = await prisma.mock_tests.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mock_testsWithIdOnly = await prisma.mock_tests.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mock_testsFindManyArgs>(args?: SelectSubset<T, mock_testsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_testsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mock_tests.
     * @param {mock_testsCreateArgs} args - Arguments to create a Mock_tests.
     * @example
     * // Create one Mock_tests
     * const Mock_tests = await prisma.mock_tests.create({
     *   data: {
     *     // ... data to create a Mock_tests
     *   }
     * })
     * 
     */
    create<T extends mock_testsCreateArgs>(args: SelectSubset<T, mock_testsCreateArgs<ExtArgs>>): Prisma__mock_testsClient<$Result.GetResult<Prisma.$mock_testsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mock_tests.
     * @param {mock_testsCreateManyArgs} args - Arguments to create many Mock_tests.
     * @example
     * // Create many Mock_tests
     * const mock_tests = await prisma.mock_tests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mock_testsCreateManyArgs>(args?: SelectSubset<T, mock_testsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mock_tests and returns the data saved in the database.
     * @param {mock_testsCreateManyAndReturnArgs} args - Arguments to create many Mock_tests.
     * @example
     * // Create many Mock_tests
     * const mock_tests = await prisma.mock_tests.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mock_tests and only return the `id`
     * const mock_testsWithIdOnly = await prisma.mock_tests.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mock_testsCreateManyAndReturnArgs>(args?: SelectSubset<T, mock_testsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_testsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mock_tests.
     * @param {mock_testsDeleteArgs} args - Arguments to delete one Mock_tests.
     * @example
     * // Delete one Mock_tests
     * const Mock_tests = await prisma.mock_tests.delete({
     *   where: {
     *     // ... filter to delete one Mock_tests
     *   }
     * })
     * 
     */
    delete<T extends mock_testsDeleteArgs>(args: SelectSubset<T, mock_testsDeleteArgs<ExtArgs>>): Prisma__mock_testsClient<$Result.GetResult<Prisma.$mock_testsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mock_tests.
     * @param {mock_testsUpdateArgs} args - Arguments to update one Mock_tests.
     * @example
     * // Update one Mock_tests
     * const mock_tests = await prisma.mock_tests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mock_testsUpdateArgs>(args: SelectSubset<T, mock_testsUpdateArgs<ExtArgs>>): Prisma__mock_testsClient<$Result.GetResult<Prisma.$mock_testsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mock_tests.
     * @param {mock_testsDeleteManyArgs} args - Arguments to filter Mock_tests to delete.
     * @example
     * // Delete a few Mock_tests
     * const { count } = await prisma.mock_tests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mock_testsDeleteManyArgs>(args?: SelectSubset<T, mock_testsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mock_tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_testsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mock_tests
     * const mock_tests = await prisma.mock_tests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mock_testsUpdateManyArgs>(args: SelectSubset<T, mock_testsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mock_tests and returns the data updated in the database.
     * @param {mock_testsUpdateManyAndReturnArgs} args - Arguments to update many Mock_tests.
     * @example
     * // Update many Mock_tests
     * const mock_tests = await prisma.mock_tests.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mock_tests and only return the `id`
     * const mock_testsWithIdOnly = await prisma.mock_tests.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mock_testsUpdateManyAndReturnArgs>(args: SelectSubset<T, mock_testsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_testsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mock_tests.
     * @param {mock_testsUpsertArgs} args - Arguments to update or create a Mock_tests.
     * @example
     * // Update or create a Mock_tests
     * const mock_tests = await prisma.mock_tests.upsert({
     *   create: {
     *     // ... data to create a Mock_tests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mock_tests we want to update
     *   }
     * })
     */
    upsert<T extends mock_testsUpsertArgs>(args: SelectSubset<T, mock_testsUpsertArgs<ExtArgs>>): Prisma__mock_testsClient<$Result.GetResult<Prisma.$mock_testsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mock_tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_testsCountArgs} args - Arguments to filter Mock_tests to count.
     * @example
     * // Count the number of Mock_tests
     * const count = await prisma.mock_tests.count({
     *   where: {
     *     // ... the filter for the Mock_tests we want to count
     *   }
     * })
    **/
    count<T extends mock_testsCountArgs>(
      args?: Subset<T, mock_testsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mock_testsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mock_tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mock_testsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mock_testsAggregateArgs>(args: Subset<T, Mock_testsAggregateArgs>): Prisma.PrismaPromise<GetMock_testsAggregateType<T>>

    /**
     * Group by Mock_tests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mock_testsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mock_testsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mock_testsGroupByArgs['orderBy'] }
        : { orderBy?: mock_testsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mock_testsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMock_testsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mock_tests model
   */
  readonly fields: mock_testsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mock_tests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mock_testsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mock_attempts<T extends mock_tests$mock_attemptsArgs<ExtArgs> = {}>(args?: Subset<T, mock_tests$mock_attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_attemptsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mock_questions<T extends mock_tests$mock_questionsArgs<ExtArgs> = {}>(args?: Subset<T, mock_tests$mock_questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_questionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mock_series<T extends mock_tests$mock_seriesArgs<ExtArgs> = {}>(args?: Subset<T, mock_tests$mock_seriesArgs<ExtArgs>>): Prisma__mock_seriesClient<$Result.GetResult<Prisma.$mock_seriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mock_tests model
   */
  interface mock_testsFieldRefs {
    readonly id: FieldRef<"mock_tests", 'BigInt'>
    readonly series_id: FieldRef<"mock_tests", 'BigInt'>
    readonly title: FieldRef<"mock_tests", 'String'>
    readonly description: FieldRef<"mock_tests", 'String'>
    readonly duration_minutes: FieldRef<"mock_tests", 'Int'>
    readonly total_marks: FieldRef<"mock_tests", 'Int'>
    readonly created_at: FieldRef<"mock_tests", 'DateTime'>
    readonly is_free: FieldRef<"mock_tests", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * mock_tests findUnique
   */
  export type mock_testsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_tests
     */
    select?: mock_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_tests
     */
    omit?: mock_testsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_testsInclude<ExtArgs> | null
    /**
     * Filter, which mock_tests to fetch.
     */
    where: mock_testsWhereUniqueInput
  }

  /**
   * mock_tests findUniqueOrThrow
   */
  export type mock_testsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_tests
     */
    select?: mock_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_tests
     */
    omit?: mock_testsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_testsInclude<ExtArgs> | null
    /**
     * Filter, which mock_tests to fetch.
     */
    where: mock_testsWhereUniqueInput
  }

  /**
   * mock_tests findFirst
   */
  export type mock_testsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_tests
     */
    select?: mock_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_tests
     */
    omit?: mock_testsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_testsInclude<ExtArgs> | null
    /**
     * Filter, which mock_tests to fetch.
     */
    where?: mock_testsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_tests to fetch.
     */
    orderBy?: mock_testsOrderByWithRelationInput | mock_testsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mock_tests.
     */
    cursor?: mock_testsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mock_tests.
     */
    distinct?: Mock_testsScalarFieldEnum | Mock_testsScalarFieldEnum[]
  }

  /**
   * mock_tests findFirstOrThrow
   */
  export type mock_testsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_tests
     */
    select?: mock_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_tests
     */
    omit?: mock_testsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_testsInclude<ExtArgs> | null
    /**
     * Filter, which mock_tests to fetch.
     */
    where?: mock_testsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_tests to fetch.
     */
    orderBy?: mock_testsOrderByWithRelationInput | mock_testsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mock_tests.
     */
    cursor?: mock_testsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_tests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mock_tests.
     */
    distinct?: Mock_testsScalarFieldEnum | Mock_testsScalarFieldEnum[]
  }

  /**
   * mock_tests findMany
   */
  export type mock_testsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_tests
     */
    select?: mock_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_tests
     */
    omit?: mock_testsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_testsInclude<ExtArgs> | null
    /**
     * Filter, which mock_tests to fetch.
     */
    where?: mock_testsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mock_tests to fetch.
     */
    orderBy?: mock_testsOrderByWithRelationInput | mock_testsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mock_tests.
     */
    cursor?: mock_testsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mock_tests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mock_tests.
     */
    skip?: number
    distinct?: Mock_testsScalarFieldEnum | Mock_testsScalarFieldEnum[]
  }

  /**
   * mock_tests create
   */
  export type mock_testsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_tests
     */
    select?: mock_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_tests
     */
    omit?: mock_testsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_testsInclude<ExtArgs> | null
    /**
     * The data needed to create a mock_tests.
     */
    data: XOR<mock_testsCreateInput, mock_testsUncheckedCreateInput>
  }

  /**
   * mock_tests createMany
   */
  export type mock_testsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mock_tests.
     */
    data: mock_testsCreateManyInput | mock_testsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mock_tests createManyAndReturn
   */
  export type mock_testsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_tests
     */
    select?: mock_testsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mock_tests
     */
    omit?: mock_testsOmit<ExtArgs> | null
    /**
     * The data used to create many mock_tests.
     */
    data: mock_testsCreateManyInput | mock_testsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_testsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * mock_tests update
   */
  export type mock_testsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_tests
     */
    select?: mock_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_tests
     */
    omit?: mock_testsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_testsInclude<ExtArgs> | null
    /**
     * The data needed to update a mock_tests.
     */
    data: XOR<mock_testsUpdateInput, mock_testsUncheckedUpdateInput>
    /**
     * Choose, which mock_tests to update.
     */
    where: mock_testsWhereUniqueInput
  }

  /**
   * mock_tests updateMany
   */
  export type mock_testsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mock_tests.
     */
    data: XOR<mock_testsUpdateManyMutationInput, mock_testsUncheckedUpdateManyInput>
    /**
     * Filter which mock_tests to update
     */
    where?: mock_testsWhereInput
    /**
     * Limit how many mock_tests to update.
     */
    limit?: number
  }

  /**
   * mock_tests updateManyAndReturn
   */
  export type mock_testsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_tests
     */
    select?: mock_testsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mock_tests
     */
    omit?: mock_testsOmit<ExtArgs> | null
    /**
     * The data used to update mock_tests.
     */
    data: XOR<mock_testsUpdateManyMutationInput, mock_testsUncheckedUpdateManyInput>
    /**
     * Filter which mock_tests to update
     */
    where?: mock_testsWhereInput
    /**
     * Limit how many mock_tests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_testsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * mock_tests upsert
   */
  export type mock_testsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_tests
     */
    select?: mock_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_tests
     */
    omit?: mock_testsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_testsInclude<ExtArgs> | null
    /**
     * The filter to search for the mock_tests to update in case it exists.
     */
    where: mock_testsWhereUniqueInput
    /**
     * In case the mock_tests found by the `where` argument doesn't exist, create a new mock_tests with this data.
     */
    create: XOR<mock_testsCreateInput, mock_testsUncheckedCreateInput>
    /**
     * In case the mock_tests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mock_testsUpdateInput, mock_testsUncheckedUpdateInput>
  }

  /**
   * mock_tests delete
   */
  export type mock_testsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_tests
     */
    select?: mock_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_tests
     */
    omit?: mock_testsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_testsInclude<ExtArgs> | null
    /**
     * Filter which mock_tests to delete.
     */
    where: mock_testsWhereUniqueInput
  }

  /**
   * mock_tests deleteMany
   */
  export type mock_testsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mock_tests to delete
     */
    where?: mock_testsWhereInput
    /**
     * Limit how many mock_tests to delete.
     */
    limit?: number
  }

  /**
   * mock_tests.mock_attempts
   */
  export type mock_tests$mock_attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_attempts
     */
    select?: mock_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_attempts
     */
    omit?: mock_attemptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_attemptsInclude<ExtArgs> | null
    where?: mock_attemptsWhereInput
    orderBy?: mock_attemptsOrderByWithRelationInput | mock_attemptsOrderByWithRelationInput[]
    cursor?: mock_attemptsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Mock_attemptsScalarFieldEnum | Mock_attemptsScalarFieldEnum[]
  }

  /**
   * mock_tests.mock_questions
   */
  export type mock_tests$mock_questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_questions
     */
    select?: mock_questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_questions
     */
    omit?: mock_questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_questionsInclude<ExtArgs> | null
    where?: mock_questionsWhereInput
    orderBy?: mock_questionsOrderByWithRelationInput | mock_questionsOrderByWithRelationInput[]
    cursor?: mock_questionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Mock_questionsScalarFieldEnum | Mock_questionsScalarFieldEnum[]
  }

  /**
   * mock_tests.mock_series
   */
  export type mock_tests$mock_seriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_series
     */
    select?: mock_seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_series
     */
    omit?: mock_seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_seriesInclude<ExtArgs> | null
    where?: mock_seriesWhereInput
  }

  /**
   * mock_tests without action
   */
  export type mock_testsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_tests
     */
    select?: mock_testsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_tests
     */
    omit?: mock_testsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_testsInclude<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    course_id: number | null
    amount: Decimal | null
    mock_series_id: number | null
  }

  export type PaymentsSumAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    amount: Decimal | null
    mock_series_id: bigint | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    amount: Decimal | null
    payment_method: string | null
    status: $Enums.payment_status | null
    transaction_id: string | null
    created_at: Date | null
    mock_series_id: bigint | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: bigint | null
    user_id: bigint | null
    course_id: bigint | null
    amount: Decimal | null
    payment_method: string | null
    status: $Enums.payment_status | null
    transaction_id: string | null
    created_at: Date | null
    mock_series_id: bigint | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    user_id: number
    course_id: number
    amount: number
    payment_method: number
    status: number
    transaction_id: number
    created_at: number
    mock_series_id: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    amount?: true
    mock_series_id?: true
  }

  export type PaymentsSumAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    amount?: true
    mock_series_id?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    amount?: true
    payment_method?: true
    status?: true
    transaction_id?: true
    created_at?: true
    mock_series_id?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    amount?: true
    payment_method?: true
    status?: true
    transaction_id?: true
    created_at?: true
    mock_series_id?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    user_id?: true
    course_id?: true
    amount?: true
    payment_method?: true
    status?: true
    transaction_id?: true
    created_at?: true
    mock_series_id?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: bigint
    user_id: bigint | null
    course_id: bigint | null
    amount: Decimal
    payment_method: string
    status: $Enums.payment_status | null
    transaction_id: string | null
    created_at: Date | null
    mock_series_id: bigint | null
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    amount?: boolean
    payment_method?: boolean
    status?: boolean
    transaction_id?: boolean
    created_at?: boolean
    mock_series_id?: boolean
    courses?: boolean | payments$coursesArgs<ExtArgs>
    mock_series?: boolean | payments$mock_seriesArgs<ExtArgs>
    users?: boolean | payments$usersArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    amount?: boolean
    payment_method?: boolean
    status?: boolean
    transaction_id?: boolean
    created_at?: boolean
    mock_series_id?: boolean
    courses?: boolean | payments$coursesArgs<ExtArgs>
    mock_series?: boolean | payments$mock_seriesArgs<ExtArgs>
    users?: boolean | payments$usersArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    amount?: boolean
    payment_method?: boolean
    status?: boolean
    transaction_id?: boolean
    created_at?: boolean
    mock_series_id?: boolean
    courses?: boolean | payments$coursesArgs<ExtArgs>
    mock_series?: boolean | payments$mock_seriesArgs<ExtArgs>
    users?: boolean | payments$usersArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectScalar = {
    id?: boolean
    user_id?: boolean
    course_id?: boolean
    amount?: boolean
    payment_method?: boolean
    status?: boolean
    transaction_id?: boolean
    created_at?: boolean
    mock_series_id?: boolean
  }

  export type paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "course_id" | "amount" | "payment_method" | "status" | "transaction_id" | "created_at" | "mock_series_id", ExtArgs["result"]["payments"]>
  export type paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | payments$coursesArgs<ExtArgs>
    mock_series?: boolean | payments$mock_seriesArgs<ExtArgs>
    users?: boolean | payments$usersArgs<ExtArgs>
  }
  export type paymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | payments$coursesArgs<ExtArgs>
    mock_series?: boolean | payments$mock_seriesArgs<ExtArgs>
    users?: boolean | payments$usersArgs<ExtArgs>
  }
  export type paymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courses?: boolean | payments$coursesArgs<ExtArgs>
    mock_series?: boolean | payments$mock_seriesArgs<ExtArgs>
    users?: boolean | payments$usersArgs<ExtArgs>
  }

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {
      courses: Prisma.$coursesPayload<ExtArgs> | null
      mock_series: Prisma.$mock_seriesPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      user_id: bigint | null
      course_id: bigint | null
      amount: Prisma.Decimal
      payment_method: string
      status: $Enums.payment_status | null
      transaction_id: string | null
      created_at: Date | null
      mock_series_id: bigint | null
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {paymentsUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, paymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courses<T extends payments$coursesArgs<ExtArgs> = {}>(args?: Subset<T, payments$coursesArgs<ExtArgs>>): Prisma__coursesClient<$Result.GetResult<Prisma.$coursesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mock_series<T extends payments$mock_seriesArgs<ExtArgs> = {}>(args?: Subset<T, payments$mock_seriesArgs<ExtArgs>>): Prisma__mock_seriesClient<$Result.GetResult<Prisma.$mock_seriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends payments$usersArgs<ExtArgs> = {}>(args?: Subset<T, payments$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */
  interface paymentsFieldRefs {
    readonly id: FieldRef<"payments", 'BigInt'>
    readonly user_id: FieldRef<"payments", 'BigInt'>
    readonly course_id: FieldRef<"payments", 'BigInt'>
    readonly amount: FieldRef<"payments", 'Decimal'>
    readonly payment_method: FieldRef<"payments", 'String'>
    readonly status: FieldRef<"payments", 'payment_status'>
    readonly transaction_id: FieldRef<"payments", 'String'>
    readonly created_at: FieldRef<"payments", 'DateTime'>
    readonly mock_series_id: FieldRef<"payments", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments createManyAndReturn
   */
  export type paymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payments updateManyAndReturn
   */
  export type paymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payments.courses
   */
  export type payments$coursesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the courses
     */
    select?: coursesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the courses
     */
    omit?: coursesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: coursesInclude<ExtArgs> | null
    where?: coursesWhereInput
  }

  /**
   * payments.mock_series
   */
  export type payments$mock_seriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_series
     */
    select?: mock_seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_series
     */
    omit?: mock_seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_seriesInclude<ExtArgs> | null
    where?: mock_seriesWhereInput
  }

  /**
   * payments.users
   */
  export type payments$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
  }


  /**
   * Model post_tags
   */

  export type AggregatePost_tags = {
    _count: Post_tagsCountAggregateOutputType | null
    _avg: Post_tagsAvgAggregateOutputType | null
    _sum: Post_tagsSumAggregateOutputType | null
    _min: Post_tagsMinAggregateOutputType | null
    _max: Post_tagsMaxAggregateOutputType | null
  }

  export type Post_tagsAvgAggregateOutputType = {
    post_id: number | null
    tag_id: number | null
  }

  export type Post_tagsSumAggregateOutputType = {
    post_id: bigint | null
    tag_id: bigint | null
  }

  export type Post_tagsMinAggregateOutputType = {
    post_id: bigint | null
    tag_id: bigint | null
  }

  export type Post_tagsMaxAggregateOutputType = {
    post_id: bigint | null
    tag_id: bigint | null
  }

  export type Post_tagsCountAggregateOutputType = {
    post_id: number
    tag_id: number
    _all: number
  }


  export type Post_tagsAvgAggregateInputType = {
    post_id?: true
    tag_id?: true
  }

  export type Post_tagsSumAggregateInputType = {
    post_id?: true
    tag_id?: true
  }

  export type Post_tagsMinAggregateInputType = {
    post_id?: true
    tag_id?: true
  }

  export type Post_tagsMaxAggregateInputType = {
    post_id?: true
    tag_id?: true
  }

  export type Post_tagsCountAggregateInputType = {
    post_id?: true
    tag_id?: true
    _all?: true
  }

  export type Post_tagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which post_tags to aggregate.
     */
    where?: post_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of post_tags to fetch.
     */
    orderBy?: post_tagsOrderByWithRelationInput | post_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: post_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` post_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` post_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned post_tags
    **/
    _count?: true | Post_tagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Post_tagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Post_tagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Post_tagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Post_tagsMaxAggregateInputType
  }

  export type GetPost_tagsAggregateType<T extends Post_tagsAggregateArgs> = {
        [P in keyof T & keyof AggregatePost_tags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost_tags[P]>
      : GetScalarType<T[P], AggregatePost_tags[P]>
  }




  export type post_tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: post_tagsWhereInput
    orderBy?: post_tagsOrderByWithAggregationInput | post_tagsOrderByWithAggregationInput[]
    by: Post_tagsScalarFieldEnum[] | Post_tagsScalarFieldEnum
    having?: post_tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Post_tagsCountAggregateInputType | true
    _avg?: Post_tagsAvgAggregateInputType
    _sum?: Post_tagsSumAggregateInputType
    _min?: Post_tagsMinAggregateInputType
    _max?: Post_tagsMaxAggregateInputType
  }

  export type Post_tagsGroupByOutputType = {
    post_id: bigint
    tag_id: bigint
    _count: Post_tagsCountAggregateOutputType | null
    _avg: Post_tagsAvgAggregateOutputType | null
    _sum: Post_tagsSumAggregateOutputType | null
    _min: Post_tagsMinAggregateOutputType | null
    _max: Post_tagsMaxAggregateOutputType | null
  }

  type GetPost_tagsGroupByPayload<T extends post_tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Post_tagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Post_tagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Post_tagsGroupByOutputType[P]>
            : GetScalarType<T[P], Post_tagsGroupByOutputType[P]>
        }
      >
    >


  export type post_tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    post_id?: boolean
    tag_id?: boolean
    posts?: boolean | postsDefaultArgs<ExtArgs>
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post_tags"]>

  export type post_tagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    post_id?: boolean
    tag_id?: boolean
    posts?: boolean | postsDefaultArgs<ExtArgs>
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post_tags"]>

  export type post_tagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    post_id?: boolean
    tag_id?: boolean
    posts?: boolean | postsDefaultArgs<ExtArgs>
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post_tags"]>

  export type post_tagsSelectScalar = {
    post_id?: boolean
    tag_id?: boolean
  }

  export type post_tagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"post_id" | "tag_id", ExtArgs["result"]["post_tags"]>
  export type post_tagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | postsDefaultArgs<ExtArgs>
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }
  export type post_tagsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | postsDefaultArgs<ExtArgs>
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }
  export type post_tagsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | postsDefaultArgs<ExtArgs>
    tags?: boolean | tagsDefaultArgs<ExtArgs>
  }

  export type $post_tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "post_tags"
    objects: {
      posts: Prisma.$postsPayload<ExtArgs>
      tags: Prisma.$tagsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      post_id: bigint
      tag_id: bigint
    }, ExtArgs["result"]["post_tags"]>
    composites: {}
  }

  type post_tagsGetPayload<S extends boolean | null | undefined | post_tagsDefaultArgs> = $Result.GetResult<Prisma.$post_tagsPayload, S>

  type post_tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<post_tagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Post_tagsCountAggregateInputType | true
    }

  export interface post_tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['post_tags'], meta: { name: 'post_tags' } }
    /**
     * Find zero or one Post_tags that matches the filter.
     * @param {post_tagsFindUniqueArgs} args - Arguments to find a Post_tags
     * @example
     * // Get one Post_tags
     * const post_tags = await prisma.post_tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends post_tagsFindUniqueArgs>(args: SelectSubset<T, post_tagsFindUniqueArgs<ExtArgs>>): Prisma__post_tagsClient<$Result.GetResult<Prisma.$post_tagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post_tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {post_tagsFindUniqueOrThrowArgs} args - Arguments to find a Post_tags
     * @example
     * // Get one Post_tags
     * const post_tags = await prisma.post_tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends post_tagsFindUniqueOrThrowArgs>(args: SelectSubset<T, post_tagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__post_tagsClient<$Result.GetResult<Prisma.$post_tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_tagsFindFirstArgs} args - Arguments to find a Post_tags
     * @example
     * // Get one Post_tags
     * const post_tags = await prisma.post_tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends post_tagsFindFirstArgs>(args?: SelectSubset<T, post_tagsFindFirstArgs<ExtArgs>>): Prisma__post_tagsClient<$Result.GetResult<Prisma.$post_tagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post_tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_tagsFindFirstOrThrowArgs} args - Arguments to find a Post_tags
     * @example
     * // Get one Post_tags
     * const post_tags = await prisma.post_tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends post_tagsFindFirstOrThrowArgs>(args?: SelectSubset<T, post_tagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__post_tagsClient<$Result.GetResult<Prisma.$post_tagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Post_tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_tagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Post_tags
     * const post_tags = await prisma.post_tags.findMany()
     * 
     * // Get first 10 Post_tags
     * const post_tags = await prisma.post_tags.findMany({ take: 10 })
     * 
     * // Only select the `post_id`
     * const post_tagsWithPost_idOnly = await prisma.post_tags.findMany({ select: { post_id: true } })
     * 
     */
    findMany<T extends post_tagsFindManyArgs>(args?: SelectSubset<T, post_tagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$post_tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post_tags.
     * @param {post_tagsCreateArgs} args - Arguments to create a Post_tags.
     * @example
     * // Create one Post_tags
     * const Post_tags = await prisma.post_tags.create({
     *   data: {
     *     // ... data to create a Post_tags
     *   }
     * })
     * 
     */
    create<T extends post_tagsCreateArgs>(args: SelectSubset<T, post_tagsCreateArgs<ExtArgs>>): Prisma__post_tagsClient<$Result.GetResult<Prisma.$post_tagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Post_tags.
     * @param {post_tagsCreateManyArgs} args - Arguments to create many Post_tags.
     * @example
     * // Create many Post_tags
     * const post_tags = await prisma.post_tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends post_tagsCreateManyArgs>(args?: SelectSubset<T, post_tagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Post_tags and returns the data saved in the database.
     * @param {post_tagsCreateManyAndReturnArgs} args - Arguments to create many Post_tags.
     * @example
     * // Create many Post_tags
     * const post_tags = await prisma.post_tags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Post_tags and only return the `post_id`
     * const post_tagsWithPost_idOnly = await prisma.post_tags.createManyAndReturn({
     *   select: { post_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends post_tagsCreateManyAndReturnArgs>(args?: SelectSubset<T, post_tagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$post_tagsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post_tags.
     * @param {post_tagsDeleteArgs} args - Arguments to delete one Post_tags.
     * @example
     * // Delete one Post_tags
     * const Post_tags = await prisma.post_tags.delete({
     *   where: {
     *     // ... filter to delete one Post_tags
     *   }
     * })
     * 
     */
    delete<T extends post_tagsDeleteArgs>(args: SelectSubset<T, post_tagsDeleteArgs<ExtArgs>>): Prisma__post_tagsClient<$Result.GetResult<Prisma.$post_tagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post_tags.
     * @param {post_tagsUpdateArgs} args - Arguments to update one Post_tags.
     * @example
     * // Update one Post_tags
     * const post_tags = await prisma.post_tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends post_tagsUpdateArgs>(args: SelectSubset<T, post_tagsUpdateArgs<ExtArgs>>): Prisma__post_tagsClient<$Result.GetResult<Prisma.$post_tagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Post_tags.
     * @param {post_tagsDeleteManyArgs} args - Arguments to filter Post_tags to delete.
     * @example
     * // Delete a few Post_tags
     * const { count } = await prisma.post_tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends post_tagsDeleteManyArgs>(args?: SelectSubset<T, post_tagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Post_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Post_tags
     * const post_tags = await prisma.post_tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends post_tagsUpdateManyArgs>(args: SelectSubset<T, post_tagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Post_tags and returns the data updated in the database.
     * @param {post_tagsUpdateManyAndReturnArgs} args - Arguments to update many Post_tags.
     * @example
     * // Update many Post_tags
     * const post_tags = await prisma.post_tags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Post_tags and only return the `post_id`
     * const post_tagsWithPost_idOnly = await prisma.post_tags.updateManyAndReturn({
     *   select: { post_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends post_tagsUpdateManyAndReturnArgs>(args: SelectSubset<T, post_tagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$post_tagsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post_tags.
     * @param {post_tagsUpsertArgs} args - Arguments to update or create a Post_tags.
     * @example
     * // Update or create a Post_tags
     * const post_tags = await prisma.post_tags.upsert({
     *   create: {
     *     // ... data to create a Post_tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post_tags we want to update
     *   }
     * })
     */
    upsert<T extends post_tagsUpsertArgs>(args: SelectSubset<T, post_tagsUpsertArgs<ExtArgs>>): Prisma__post_tagsClient<$Result.GetResult<Prisma.$post_tagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Post_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_tagsCountArgs} args - Arguments to filter Post_tags to count.
     * @example
     * // Count the number of Post_tags
     * const count = await prisma.post_tags.count({
     *   where: {
     *     // ... the filter for the Post_tags we want to count
     *   }
     * })
    **/
    count<T extends post_tagsCountArgs>(
      args?: Subset<T, post_tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Post_tagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Post_tagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Post_tagsAggregateArgs>(args: Subset<T, Post_tagsAggregateArgs>): Prisma.PrismaPromise<GetPost_tagsAggregateType<T>>

    /**
     * Group by Post_tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends post_tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: post_tagsGroupByArgs['orderBy'] }
        : { orderBy?: post_tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, post_tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPost_tagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the post_tags model
   */
  readonly fields: post_tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for post_tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__post_tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends postsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, postsDefaultArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tags<T extends tagsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, tagsDefaultArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the post_tags model
   */
  interface post_tagsFieldRefs {
    readonly post_id: FieldRef<"post_tags", 'BigInt'>
    readonly tag_id: FieldRef<"post_tags", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * post_tags findUnique
   */
  export type post_tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_tags
     */
    select?: post_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_tags
     */
    omit?: post_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_tagsInclude<ExtArgs> | null
    /**
     * Filter, which post_tags to fetch.
     */
    where: post_tagsWhereUniqueInput
  }

  /**
   * post_tags findUniqueOrThrow
   */
  export type post_tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_tags
     */
    select?: post_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_tags
     */
    omit?: post_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_tagsInclude<ExtArgs> | null
    /**
     * Filter, which post_tags to fetch.
     */
    where: post_tagsWhereUniqueInput
  }

  /**
   * post_tags findFirst
   */
  export type post_tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_tags
     */
    select?: post_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_tags
     */
    omit?: post_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_tagsInclude<ExtArgs> | null
    /**
     * Filter, which post_tags to fetch.
     */
    where?: post_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of post_tags to fetch.
     */
    orderBy?: post_tagsOrderByWithRelationInput | post_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for post_tags.
     */
    cursor?: post_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` post_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` post_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of post_tags.
     */
    distinct?: Post_tagsScalarFieldEnum | Post_tagsScalarFieldEnum[]
  }

  /**
   * post_tags findFirstOrThrow
   */
  export type post_tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_tags
     */
    select?: post_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_tags
     */
    omit?: post_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_tagsInclude<ExtArgs> | null
    /**
     * Filter, which post_tags to fetch.
     */
    where?: post_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of post_tags to fetch.
     */
    orderBy?: post_tagsOrderByWithRelationInput | post_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for post_tags.
     */
    cursor?: post_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` post_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` post_tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of post_tags.
     */
    distinct?: Post_tagsScalarFieldEnum | Post_tagsScalarFieldEnum[]
  }

  /**
   * post_tags findMany
   */
  export type post_tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_tags
     */
    select?: post_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_tags
     */
    omit?: post_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_tagsInclude<ExtArgs> | null
    /**
     * Filter, which post_tags to fetch.
     */
    where?: post_tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of post_tags to fetch.
     */
    orderBy?: post_tagsOrderByWithRelationInput | post_tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing post_tags.
     */
    cursor?: post_tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` post_tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` post_tags.
     */
    skip?: number
    distinct?: Post_tagsScalarFieldEnum | Post_tagsScalarFieldEnum[]
  }

  /**
   * post_tags create
   */
  export type post_tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_tags
     */
    select?: post_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_tags
     */
    omit?: post_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a post_tags.
     */
    data: XOR<post_tagsCreateInput, post_tagsUncheckedCreateInput>
  }

  /**
   * post_tags createMany
   */
  export type post_tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many post_tags.
     */
    data: post_tagsCreateManyInput | post_tagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * post_tags createManyAndReturn
   */
  export type post_tagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_tags
     */
    select?: post_tagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the post_tags
     */
    omit?: post_tagsOmit<ExtArgs> | null
    /**
     * The data used to create many post_tags.
     */
    data: post_tagsCreateManyInput | post_tagsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_tagsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * post_tags update
   */
  export type post_tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_tags
     */
    select?: post_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_tags
     */
    omit?: post_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a post_tags.
     */
    data: XOR<post_tagsUpdateInput, post_tagsUncheckedUpdateInput>
    /**
     * Choose, which post_tags to update.
     */
    where: post_tagsWhereUniqueInput
  }

  /**
   * post_tags updateMany
   */
  export type post_tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update post_tags.
     */
    data: XOR<post_tagsUpdateManyMutationInput, post_tagsUncheckedUpdateManyInput>
    /**
     * Filter which post_tags to update
     */
    where?: post_tagsWhereInput
    /**
     * Limit how many post_tags to update.
     */
    limit?: number
  }

  /**
   * post_tags updateManyAndReturn
   */
  export type post_tagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_tags
     */
    select?: post_tagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the post_tags
     */
    omit?: post_tagsOmit<ExtArgs> | null
    /**
     * The data used to update post_tags.
     */
    data: XOR<post_tagsUpdateManyMutationInput, post_tagsUncheckedUpdateManyInput>
    /**
     * Filter which post_tags to update
     */
    where?: post_tagsWhereInput
    /**
     * Limit how many post_tags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_tagsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * post_tags upsert
   */
  export type post_tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_tags
     */
    select?: post_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_tags
     */
    omit?: post_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the post_tags to update in case it exists.
     */
    where: post_tagsWhereUniqueInput
    /**
     * In case the post_tags found by the `where` argument doesn't exist, create a new post_tags with this data.
     */
    create: XOR<post_tagsCreateInput, post_tagsUncheckedCreateInput>
    /**
     * In case the post_tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<post_tagsUpdateInput, post_tagsUncheckedUpdateInput>
  }

  /**
   * post_tags delete
   */
  export type post_tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_tags
     */
    select?: post_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_tags
     */
    omit?: post_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_tagsInclude<ExtArgs> | null
    /**
     * Filter which post_tags to delete.
     */
    where: post_tagsWhereUniqueInput
  }

  /**
   * post_tags deleteMany
   */
  export type post_tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which post_tags to delete
     */
    where?: post_tagsWhereInput
    /**
     * Limit how many post_tags to delete.
     */
    limit?: number
  }

  /**
   * post_tags without action
   */
  export type post_tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_tags
     */
    select?: post_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_tags
     */
    omit?: post_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_tagsInclude<ExtArgs> | null
  }


  /**
   * Model post_templates
   */

  export type AggregatePost_templates = {
    _count: Post_templatesCountAggregateOutputType | null
    _avg: Post_templatesAvgAggregateOutputType | null
    _sum: Post_templatesSumAggregateOutputType | null
    _min: Post_templatesMinAggregateOutputType | null
    _max: Post_templatesMaxAggregateOutputType | null
  }

  export type Post_templatesAvgAggregateOutputType = {
    id: number | null
  }

  export type Post_templatesSumAggregateOutputType = {
    id: bigint | null
  }

  export type Post_templatesMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    description: string | null
    created_at: Date | null
  }

  export type Post_templatesMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    description: string | null
    created_at: Date | null
  }

  export type Post_templatesCountAggregateOutputType = {
    id: number
    name: number
    description: number
    structure: number
    created_at: number
    _all: number
  }


  export type Post_templatesAvgAggregateInputType = {
    id?: true
  }

  export type Post_templatesSumAggregateInputType = {
    id?: true
  }

  export type Post_templatesMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
  }

  export type Post_templatesMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    created_at?: true
  }

  export type Post_templatesCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    structure?: true
    created_at?: true
    _all?: true
  }

  export type Post_templatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which post_templates to aggregate.
     */
    where?: post_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of post_templates to fetch.
     */
    orderBy?: post_templatesOrderByWithRelationInput | post_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: post_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` post_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` post_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned post_templates
    **/
    _count?: true | Post_templatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Post_templatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Post_templatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Post_templatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Post_templatesMaxAggregateInputType
  }

  export type GetPost_templatesAggregateType<T extends Post_templatesAggregateArgs> = {
        [P in keyof T & keyof AggregatePost_templates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost_templates[P]>
      : GetScalarType<T[P], AggregatePost_templates[P]>
  }




  export type post_templatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: post_templatesWhereInput
    orderBy?: post_templatesOrderByWithAggregationInput | post_templatesOrderByWithAggregationInput[]
    by: Post_templatesScalarFieldEnum[] | Post_templatesScalarFieldEnum
    having?: post_templatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Post_templatesCountAggregateInputType | true
    _avg?: Post_templatesAvgAggregateInputType
    _sum?: Post_templatesSumAggregateInputType
    _min?: Post_templatesMinAggregateInputType
    _max?: Post_templatesMaxAggregateInputType
  }

  export type Post_templatesGroupByOutputType = {
    id: bigint
    name: string
    description: string | null
    structure: JsonValue
    created_at: Date | null
    _count: Post_templatesCountAggregateOutputType | null
    _avg: Post_templatesAvgAggregateOutputType | null
    _sum: Post_templatesSumAggregateOutputType | null
    _min: Post_templatesMinAggregateOutputType | null
    _max: Post_templatesMaxAggregateOutputType | null
  }

  type GetPost_templatesGroupByPayload<T extends post_templatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Post_templatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Post_templatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Post_templatesGroupByOutputType[P]>
            : GetScalarType<T[P], Post_templatesGroupByOutputType[P]>
        }
      >
    >


  export type post_templatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    structure?: boolean
    created_at?: boolean
    posts?: boolean | post_templates$postsArgs<ExtArgs>
    _count?: boolean | Post_templatesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post_templates"]>

  export type post_templatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    structure?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["post_templates"]>

  export type post_templatesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    structure?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["post_templates"]>

  export type post_templatesSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    structure?: boolean
    created_at?: boolean
  }

  export type post_templatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "structure" | "created_at", ExtArgs["result"]["post_templates"]>
  export type post_templatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    posts?: boolean | post_templates$postsArgs<ExtArgs>
    _count?: boolean | Post_templatesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type post_templatesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type post_templatesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $post_templatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "post_templates"
    objects: {
      posts: Prisma.$postsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      description: string | null
      structure: Prisma.JsonValue
      created_at: Date | null
    }, ExtArgs["result"]["post_templates"]>
    composites: {}
  }

  type post_templatesGetPayload<S extends boolean | null | undefined | post_templatesDefaultArgs> = $Result.GetResult<Prisma.$post_templatesPayload, S>

  type post_templatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<post_templatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Post_templatesCountAggregateInputType | true
    }

  export interface post_templatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['post_templates'], meta: { name: 'post_templates' } }
    /**
     * Find zero or one Post_templates that matches the filter.
     * @param {post_templatesFindUniqueArgs} args - Arguments to find a Post_templates
     * @example
     * // Get one Post_templates
     * const post_templates = await prisma.post_templates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends post_templatesFindUniqueArgs>(args: SelectSubset<T, post_templatesFindUniqueArgs<ExtArgs>>): Prisma__post_templatesClient<$Result.GetResult<Prisma.$post_templatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post_templates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {post_templatesFindUniqueOrThrowArgs} args - Arguments to find a Post_templates
     * @example
     * // Get one Post_templates
     * const post_templates = await prisma.post_templates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends post_templatesFindUniqueOrThrowArgs>(args: SelectSubset<T, post_templatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__post_templatesClient<$Result.GetResult<Prisma.$post_templatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_templatesFindFirstArgs} args - Arguments to find a Post_templates
     * @example
     * // Get one Post_templates
     * const post_templates = await prisma.post_templates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends post_templatesFindFirstArgs>(args?: SelectSubset<T, post_templatesFindFirstArgs<ExtArgs>>): Prisma__post_templatesClient<$Result.GetResult<Prisma.$post_templatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post_templates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_templatesFindFirstOrThrowArgs} args - Arguments to find a Post_templates
     * @example
     * // Get one Post_templates
     * const post_templates = await prisma.post_templates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends post_templatesFindFirstOrThrowArgs>(args?: SelectSubset<T, post_templatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__post_templatesClient<$Result.GetResult<Prisma.$post_templatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Post_templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_templatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Post_templates
     * const post_templates = await prisma.post_templates.findMany()
     * 
     * // Get first 10 Post_templates
     * const post_templates = await prisma.post_templates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const post_templatesWithIdOnly = await prisma.post_templates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends post_templatesFindManyArgs>(args?: SelectSubset<T, post_templatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$post_templatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post_templates.
     * @param {post_templatesCreateArgs} args - Arguments to create a Post_templates.
     * @example
     * // Create one Post_templates
     * const Post_templates = await prisma.post_templates.create({
     *   data: {
     *     // ... data to create a Post_templates
     *   }
     * })
     * 
     */
    create<T extends post_templatesCreateArgs>(args: SelectSubset<T, post_templatesCreateArgs<ExtArgs>>): Prisma__post_templatesClient<$Result.GetResult<Prisma.$post_templatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Post_templates.
     * @param {post_templatesCreateManyArgs} args - Arguments to create many Post_templates.
     * @example
     * // Create many Post_templates
     * const post_templates = await prisma.post_templates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends post_templatesCreateManyArgs>(args?: SelectSubset<T, post_templatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Post_templates and returns the data saved in the database.
     * @param {post_templatesCreateManyAndReturnArgs} args - Arguments to create many Post_templates.
     * @example
     * // Create many Post_templates
     * const post_templates = await prisma.post_templates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Post_templates and only return the `id`
     * const post_templatesWithIdOnly = await prisma.post_templates.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends post_templatesCreateManyAndReturnArgs>(args?: SelectSubset<T, post_templatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$post_templatesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post_templates.
     * @param {post_templatesDeleteArgs} args - Arguments to delete one Post_templates.
     * @example
     * // Delete one Post_templates
     * const Post_templates = await prisma.post_templates.delete({
     *   where: {
     *     // ... filter to delete one Post_templates
     *   }
     * })
     * 
     */
    delete<T extends post_templatesDeleteArgs>(args: SelectSubset<T, post_templatesDeleteArgs<ExtArgs>>): Prisma__post_templatesClient<$Result.GetResult<Prisma.$post_templatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post_templates.
     * @param {post_templatesUpdateArgs} args - Arguments to update one Post_templates.
     * @example
     * // Update one Post_templates
     * const post_templates = await prisma.post_templates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends post_templatesUpdateArgs>(args: SelectSubset<T, post_templatesUpdateArgs<ExtArgs>>): Prisma__post_templatesClient<$Result.GetResult<Prisma.$post_templatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Post_templates.
     * @param {post_templatesDeleteManyArgs} args - Arguments to filter Post_templates to delete.
     * @example
     * // Delete a few Post_templates
     * const { count } = await prisma.post_templates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends post_templatesDeleteManyArgs>(args?: SelectSubset<T, post_templatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Post_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_templatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Post_templates
     * const post_templates = await prisma.post_templates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends post_templatesUpdateManyArgs>(args: SelectSubset<T, post_templatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Post_templates and returns the data updated in the database.
     * @param {post_templatesUpdateManyAndReturnArgs} args - Arguments to update many Post_templates.
     * @example
     * // Update many Post_templates
     * const post_templates = await prisma.post_templates.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Post_templates and only return the `id`
     * const post_templatesWithIdOnly = await prisma.post_templates.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends post_templatesUpdateManyAndReturnArgs>(args: SelectSubset<T, post_templatesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$post_templatesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post_templates.
     * @param {post_templatesUpsertArgs} args - Arguments to update or create a Post_templates.
     * @example
     * // Update or create a Post_templates
     * const post_templates = await prisma.post_templates.upsert({
     *   create: {
     *     // ... data to create a Post_templates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post_templates we want to update
     *   }
     * })
     */
    upsert<T extends post_templatesUpsertArgs>(args: SelectSubset<T, post_templatesUpsertArgs<ExtArgs>>): Prisma__post_templatesClient<$Result.GetResult<Prisma.$post_templatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Post_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_templatesCountArgs} args - Arguments to filter Post_templates to count.
     * @example
     * // Count the number of Post_templates
     * const count = await prisma.post_templates.count({
     *   where: {
     *     // ... the filter for the Post_templates we want to count
     *   }
     * })
    **/
    count<T extends post_templatesCountArgs>(
      args?: Subset<T, post_templatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Post_templatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Post_templatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Post_templatesAggregateArgs>(args: Subset<T, Post_templatesAggregateArgs>): Prisma.PrismaPromise<GetPost_templatesAggregateType<T>>

    /**
     * Group by Post_templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_templatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends post_templatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: post_templatesGroupByArgs['orderBy'] }
        : { orderBy?: post_templatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, post_templatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPost_templatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the post_templates model
   */
  readonly fields: post_templatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for post_templates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__post_templatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    posts<T extends post_templates$postsArgs<ExtArgs> = {}>(args?: Subset<T, post_templates$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the post_templates model
   */
  interface post_templatesFieldRefs {
    readonly id: FieldRef<"post_templates", 'BigInt'>
    readonly name: FieldRef<"post_templates", 'String'>
    readonly description: FieldRef<"post_templates", 'String'>
    readonly structure: FieldRef<"post_templates", 'Json'>
    readonly created_at: FieldRef<"post_templates", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * post_templates findUnique
   */
  export type post_templatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_templates
     */
    select?: post_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_templates
     */
    omit?: post_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_templatesInclude<ExtArgs> | null
    /**
     * Filter, which post_templates to fetch.
     */
    where: post_templatesWhereUniqueInput
  }

  /**
   * post_templates findUniqueOrThrow
   */
  export type post_templatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_templates
     */
    select?: post_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_templates
     */
    omit?: post_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_templatesInclude<ExtArgs> | null
    /**
     * Filter, which post_templates to fetch.
     */
    where: post_templatesWhereUniqueInput
  }

  /**
   * post_templates findFirst
   */
  export type post_templatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_templates
     */
    select?: post_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_templates
     */
    omit?: post_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_templatesInclude<ExtArgs> | null
    /**
     * Filter, which post_templates to fetch.
     */
    where?: post_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of post_templates to fetch.
     */
    orderBy?: post_templatesOrderByWithRelationInput | post_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for post_templates.
     */
    cursor?: post_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` post_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` post_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of post_templates.
     */
    distinct?: Post_templatesScalarFieldEnum | Post_templatesScalarFieldEnum[]
  }

  /**
   * post_templates findFirstOrThrow
   */
  export type post_templatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_templates
     */
    select?: post_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_templates
     */
    omit?: post_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_templatesInclude<ExtArgs> | null
    /**
     * Filter, which post_templates to fetch.
     */
    where?: post_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of post_templates to fetch.
     */
    orderBy?: post_templatesOrderByWithRelationInput | post_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for post_templates.
     */
    cursor?: post_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` post_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` post_templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of post_templates.
     */
    distinct?: Post_templatesScalarFieldEnum | Post_templatesScalarFieldEnum[]
  }

  /**
   * post_templates findMany
   */
  export type post_templatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_templates
     */
    select?: post_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_templates
     */
    omit?: post_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_templatesInclude<ExtArgs> | null
    /**
     * Filter, which post_templates to fetch.
     */
    where?: post_templatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of post_templates to fetch.
     */
    orderBy?: post_templatesOrderByWithRelationInput | post_templatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing post_templates.
     */
    cursor?: post_templatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` post_templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` post_templates.
     */
    skip?: number
    distinct?: Post_templatesScalarFieldEnum | Post_templatesScalarFieldEnum[]
  }

  /**
   * post_templates create
   */
  export type post_templatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_templates
     */
    select?: post_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_templates
     */
    omit?: post_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_templatesInclude<ExtArgs> | null
    /**
     * The data needed to create a post_templates.
     */
    data: XOR<post_templatesCreateInput, post_templatesUncheckedCreateInput>
  }

  /**
   * post_templates createMany
   */
  export type post_templatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many post_templates.
     */
    data: post_templatesCreateManyInput | post_templatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * post_templates createManyAndReturn
   */
  export type post_templatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_templates
     */
    select?: post_templatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the post_templates
     */
    omit?: post_templatesOmit<ExtArgs> | null
    /**
     * The data used to create many post_templates.
     */
    data: post_templatesCreateManyInput | post_templatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * post_templates update
   */
  export type post_templatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_templates
     */
    select?: post_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_templates
     */
    omit?: post_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_templatesInclude<ExtArgs> | null
    /**
     * The data needed to update a post_templates.
     */
    data: XOR<post_templatesUpdateInput, post_templatesUncheckedUpdateInput>
    /**
     * Choose, which post_templates to update.
     */
    where: post_templatesWhereUniqueInput
  }

  /**
   * post_templates updateMany
   */
  export type post_templatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update post_templates.
     */
    data: XOR<post_templatesUpdateManyMutationInput, post_templatesUncheckedUpdateManyInput>
    /**
     * Filter which post_templates to update
     */
    where?: post_templatesWhereInput
    /**
     * Limit how many post_templates to update.
     */
    limit?: number
  }

  /**
   * post_templates updateManyAndReturn
   */
  export type post_templatesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_templates
     */
    select?: post_templatesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the post_templates
     */
    omit?: post_templatesOmit<ExtArgs> | null
    /**
     * The data used to update post_templates.
     */
    data: XOR<post_templatesUpdateManyMutationInput, post_templatesUncheckedUpdateManyInput>
    /**
     * Filter which post_templates to update
     */
    where?: post_templatesWhereInput
    /**
     * Limit how many post_templates to update.
     */
    limit?: number
  }

  /**
   * post_templates upsert
   */
  export type post_templatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_templates
     */
    select?: post_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_templates
     */
    omit?: post_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_templatesInclude<ExtArgs> | null
    /**
     * The filter to search for the post_templates to update in case it exists.
     */
    where: post_templatesWhereUniqueInput
    /**
     * In case the post_templates found by the `where` argument doesn't exist, create a new post_templates with this data.
     */
    create: XOR<post_templatesCreateInput, post_templatesUncheckedCreateInput>
    /**
     * In case the post_templates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<post_templatesUpdateInput, post_templatesUncheckedUpdateInput>
  }

  /**
   * post_templates delete
   */
  export type post_templatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_templates
     */
    select?: post_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_templates
     */
    omit?: post_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_templatesInclude<ExtArgs> | null
    /**
     * Filter which post_templates to delete.
     */
    where: post_templatesWhereUniqueInput
  }

  /**
   * post_templates deleteMany
   */
  export type post_templatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which post_templates to delete
     */
    where?: post_templatesWhereInput
    /**
     * Limit how many post_templates to delete.
     */
    limit?: number
  }

  /**
   * post_templates.posts
   */
  export type post_templates$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the posts
     */
    omit?: postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    where?: postsWhereInput
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    cursor?: postsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * post_templates without action
   */
  export type post_templatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_templates
     */
    select?: post_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_templates
     */
    omit?: post_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_templatesInclude<ExtArgs> | null
  }


  /**
   * Model posts
   */

  export type AggregatePosts = {
    _count: PostsCountAggregateOutputType | null
    _avg: PostsAvgAggregateOutputType | null
    _sum: PostsSumAggregateOutputType | null
    _min: PostsMinAggregateOutputType | null
    _max: PostsMaxAggregateOutputType | null
  }

  export type PostsAvgAggregateOutputType = {
    id: number | null
    category_id: number | null
    created_by: number | null
    template_id: number | null
  }

  export type PostsSumAggregateOutputType = {
    id: bigint | null
    category_id: bigint | null
    created_by: bigint | null
    template_id: bigint | null
  }

  export type PostsMinAggregateOutputType = {
    id: bigint | null
    category_id: bigint | null
    title: string | null
    slug: string | null
    content: string | null
    external_url: string | null
    thumbnail_url: string | null
    published_at: Date | null
    created_by: bigint | null
    created_at: Date | null
    updated_at: Date | null
    template_id: bigint | null
    content_html: string | null
  }

  export type PostsMaxAggregateOutputType = {
    id: bigint | null
    category_id: bigint | null
    title: string | null
    slug: string | null
    content: string | null
    external_url: string | null
    thumbnail_url: string | null
    published_at: Date | null
    created_by: bigint | null
    created_at: Date | null
    updated_at: Date | null
    template_id: bigint | null
    content_html: string | null
  }

  export type PostsCountAggregateOutputType = {
    id: number
    category_id: number
    title: number
    slug: number
    content: number
    external_url: number
    thumbnail_url: number
    published_at: number
    created_by: number
    created_at: number
    updated_at: number
    template_id: number
    content_json: number
    content_html: number
    _all: number
  }


  export type PostsAvgAggregateInputType = {
    id?: true
    category_id?: true
    created_by?: true
    template_id?: true
  }

  export type PostsSumAggregateInputType = {
    id?: true
    category_id?: true
    created_by?: true
    template_id?: true
  }

  export type PostsMinAggregateInputType = {
    id?: true
    category_id?: true
    title?: true
    slug?: true
    content?: true
    external_url?: true
    thumbnail_url?: true
    published_at?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    template_id?: true
    content_html?: true
  }

  export type PostsMaxAggregateInputType = {
    id?: true
    category_id?: true
    title?: true
    slug?: true
    content?: true
    external_url?: true
    thumbnail_url?: true
    published_at?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    template_id?: true
    content_html?: true
  }

  export type PostsCountAggregateInputType = {
    id?: true
    category_id?: true
    title?: true
    slug?: true
    content?: true
    external_url?: true
    thumbnail_url?: true
    published_at?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    template_id?: true
    content_json?: true
    content_html?: true
    _all?: true
  }

  export type PostsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which posts to aggregate.
     */
    where?: postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned posts
    **/
    _count?: true | PostsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostsMaxAggregateInputType
  }

  export type GetPostsAggregateType<T extends PostsAggregateArgs> = {
        [P in keyof T & keyof AggregatePosts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePosts[P]>
      : GetScalarType<T[P], AggregatePosts[P]>
  }




  export type postsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: postsWhereInput
    orderBy?: postsOrderByWithAggregationInput | postsOrderByWithAggregationInput[]
    by: PostsScalarFieldEnum[] | PostsScalarFieldEnum
    having?: postsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostsCountAggregateInputType | true
    _avg?: PostsAvgAggregateInputType
    _sum?: PostsSumAggregateInputType
    _min?: PostsMinAggregateInputType
    _max?: PostsMaxAggregateInputType
  }

  export type PostsGroupByOutputType = {
    id: bigint
    category_id: bigint | null
    title: string
    slug: string
    content: string
    external_url: string | null
    thumbnail_url: string | null
    published_at: Date | null
    created_by: bigint | null
    created_at: Date | null
    updated_at: Date | null
    template_id: bigint | null
    content_json: JsonValue | null
    content_html: string | null
    _count: PostsCountAggregateOutputType | null
    _avg: PostsAvgAggregateOutputType | null
    _sum: PostsSumAggregateOutputType | null
    _min: PostsMinAggregateOutputType | null
    _max: PostsMaxAggregateOutputType | null
  }

  type GetPostsGroupByPayload<T extends postsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostsGroupByOutputType[P]>
            : GetScalarType<T[P], PostsGroupByOutputType[P]>
        }
      >
    >


  export type postsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    external_url?: boolean
    thumbnail_url?: boolean
    published_at?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    template_id?: boolean
    content_json?: boolean
    content_html?: boolean
    comments?: boolean | posts$commentsArgs<ExtArgs>
    post_tags?: boolean | posts$post_tagsArgs<ExtArgs>
    categories?: boolean | posts$categoriesArgs<ExtArgs>
    users?: boolean | posts$usersArgs<ExtArgs>
    post_templates?: boolean | posts$post_templatesArgs<ExtArgs>
    _count?: boolean | PostsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["posts"]>

  export type postsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    external_url?: boolean
    thumbnail_url?: boolean
    published_at?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    template_id?: boolean
    content_json?: boolean
    content_html?: boolean
    categories?: boolean | posts$categoriesArgs<ExtArgs>
    users?: boolean | posts$usersArgs<ExtArgs>
    post_templates?: boolean | posts$post_templatesArgs<ExtArgs>
  }, ExtArgs["result"]["posts"]>

  export type postsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    external_url?: boolean
    thumbnail_url?: boolean
    published_at?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    template_id?: boolean
    content_json?: boolean
    content_html?: boolean
    categories?: boolean | posts$categoriesArgs<ExtArgs>
    users?: boolean | posts$usersArgs<ExtArgs>
    post_templates?: boolean | posts$post_templatesArgs<ExtArgs>
  }, ExtArgs["result"]["posts"]>

  export type postsSelectScalar = {
    id?: boolean
    category_id?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    external_url?: boolean
    thumbnail_url?: boolean
    published_at?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    template_id?: boolean
    content_json?: boolean
    content_html?: boolean
  }

  export type postsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category_id" | "title" | "slug" | "content" | "external_url" | "thumbnail_url" | "published_at" | "created_by" | "created_at" | "updated_at" | "template_id" | "content_json" | "content_html", ExtArgs["result"]["posts"]>
  export type postsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | posts$commentsArgs<ExtArgs>
    post_tags?: boolean | posts$post_tagsArgs<ExtArgs>
    categories?: boolean | posts$categoriesArgs<ExtArgs>
    users?: boolean | posts$usersArgs<ExtArgs>
    post_templates?: boolean | posts$post_templatesArgs<ExtArgs>
    _count?: boolean | PostsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type postsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | posts$categoriesArgs<ExtArgs>
    users?: boolean | posts$usersArgs<ExtArgs>
    post_templates?: boolean | posts$post_templatesArgs<ExtArgs>
  }
  export type postsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | posts$categoriesArgs<ExtArgs>
    users?: boolean | posts$usersArgs<ExtArgs>
    post_templates?: boolean | posts$post_templatesArgs<ExtArgs>
  }

  export type $postsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "posts"
    objects: {
      comments: Prisma.$commentsPayload<ExtArgs>[]
      post_tags: Prisma.$post_tagsPayload<ExtArgs>[]
      categories: Prisma.$categoriesPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
      post_templates: Prisma.$post_templatesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      category_id: bigint | null
      title: string
      slug: string
      content: string
      external_url: string | null
      thumbnail_url: string | null
      published_at: Date | null
      created_by: bigint | null
      created_at: Date | null
      updated_at: Date | null
      template_id: bigint | null
      content_json: Prisma.JsonValue | null
      content_html: string | null
    }, ExtArgs["result"]["posts"]>
    composites: {}
  }

  type postsGetPayload<S extends boolean | null | undefined | postsDefaultArgs> = $Result.GetResult<Prisma.$postsPayload, S>

  type postsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<postsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostsCountAggregateInputType | true
    }

  export interface postsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['posts'], meta: { name: 'posts' } }
    /**
     * Find zero or one Posts that matches the filter.
     * @param {postsFindUniqueArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends postsFindUniqueArgs>(args: SelectSubset<T, postsFindUniqueArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Posts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {postsFindUniqueOrThrowArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends postsFindUniqueOrThrowArgs>(args: SelectSubset<T, postsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsFindFirstArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends postsFindFirstArgs>(args?: SelectSubset<T, postsFindFirstArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Posts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsFindFirstOrThrowArgs} args - Arguments to find a Posts
     * @example
     * // Get one Posts
     * const posts = await prisma.posts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends postsFindFirstOrThrowArgs>(args?: SelectSubset<T, postsFindFirstOrThrowArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.posts.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.posts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postsWithIdOnly = await prisma.posts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends postsFindManyArgs>(args?: SelectSubset<T, postsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Posts.
     * @param {postsCreateArgs} args - Arguments to create a Posts.
     * @example
     * // Create one Posts
     * const Posts = await prisma.posts.create({
     *   data: {
     *     // ... data to create a Posts
     *   }
     * })
     * 
     */
    create<T extends postsCreateArgs>(args: SelectSubset<T, postsCreateArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {postsCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const posts = await prisma.posts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends postsCreateManyArgs>(args?: SelectSubset<T, postsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {postsCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const posts = await prisma.posts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postsWithIdOnly = await prisma.posts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends postsCreateManyAndReturnArgs>(args?: SelectSubset<T, postsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Posts.
     * @param {postsDeleteArgs} args - Arguments to delete one Posts.
     * @example
     * // Delete one Posts
     * const Posts = await prisma.posts.delete({
     *   where: {
     *     // ... filter to delete one Posts
     *   }
     * })
     * 
     */
    delete<T extends postsDeleteArgs>(args: SelectSubset<T, postsDeleteArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Posts.
     * @param {postsUpdateArgs} args - Arguments to update one Posts.
     * @example
     * // Update one Posts
     * const posts = await prisma.posts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends postsUpdateArgs>(args: SelectSubset<T, postsUpdateArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {postsDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.posts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends postsDeleteManyArgs>(args?: SelectSubset<T, postsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const posts = await prisma.posts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends postsUpdateManyArgs>(args: SelectSubset<T, postsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {postsUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const posts = await prisma.posts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postsWithIdOnly = await prisma.posts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends postsUpdateManyAndReturnArgs>(args: SelectSubset<T, postsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Posts.
     * @param {postsUpsertArgs} args - Arguments to update or create a Posts.
     * @example
     * // Update or create a Posts
     * const posts = await prisma.posts.upsert({
     *   create: {
     *     // ... data to create a Posts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Posts we want to update
     *   }
     * })
     */
    upsert<T extends postsUpsertArgs>(args: SelectSubset<T, postsUpsertArgs<ExtArgs>>): Prisma__postsClient<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.posts.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends postsCountArgs>(
      args?: Subset<T, postsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostsAggregateArgs>(args: Subset<T, PostsAggregateArgs>): Prisma.PrismaPromise<GetPostsAggregateType<T>>

    /**
     * Group by Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends postsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: postsGroupByArgs['orderBy'] }
        : { orderBy?: postsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, postsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the posts model
   */
  readonly fields: postsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for posts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__postsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends posts$commentsArgs<ExtArgs> = {}>(args?: Subset<T, posts$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    post_tags<T extends posts$post_tagsArgs<ExtArgs> = {}>(args?: Subset<T, posts$post_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$post_tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends posts$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, posts$categoriesArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends posts$usersArgs<ExtArgs> = {}>(args?: Subset<T, posts$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    post_templates<T extends posts$post_templatesArgs<ExtArgs> = {}>(args?: Subset<T, posts$post_templatesArgs<ExtArgs>>): Prisma__post_templatesClient<$Result.GetResult<Prisma.$post_templatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the posts model
   */
  interface postsFieldRefs {
    readonly id: FieldRef<"posts", 'BigInt'>
    readonly category_id: FieldRef<"posts", 'BigInt'>
    readonly title: FieldRef<"posts", 'String'>
    readonly slug: FieldRef<"posts", 'String'>
    readonly content: FieldRef<"posts", 'String'>
    readonly external_url: FieldRef<"posts", 'String'>
    readonly thumbnail_url: FieldRef<"posts", 'String'>
    readonly published_at: FieldRef<"posts", 'DateTime'>
    readonly created_by: FieldRef<"posts", 'BigInt'>
    readonly created_at: FieldRef<"posts", 'DateTime'>
    readonly updated_at: FieldRef<"posts", 'DateTime'>
    readonly template_id: FieldRef<"posts", 'BigInt'>
    readonly content_json: FieldRef<"posts", 'Json'>
    readonly content_html: FieldRef<"posts", 'String'>
  }
    

  // Custom InputTypes
  /**
   * posts findUnique
   */
  export type postsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the posts
     */
    omit?: postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter, which posts to fetch.
     */
    where: postsWhereUniqueInput
  }

  /**
   * posts findUniqueOrThrow
   */
  export type postsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the posts
     */
    omit?: postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter, which posts to fetch.
     */
    where: postsWhereUniqueInput
  }

  /**
   * posts findFirst
   */
  export type postsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the posts
     */
    omit?: postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter, which posts to fetch.
     */
    where?: postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for posts.
     */
    cursor?: postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of posts.
     */
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * posts findFirstOrThrow
   */
  export type postsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the posts
     */
    omit?: postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter, which posts to fetch.
     */
    where?: postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for posts.
     */
    cursor?: postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of posts.
     */
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * posts findMany
   */
  export type postsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the posts
     */
    omit?: postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter, which posts to fetch.
     */
    where?: postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing posts.
     */
    cursor?: postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * posts create
   */
  export type postsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the posts
     */
    omit?: postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * The data needed to create a posts.
     */
    data: XOR<postsCreateInput, postsUncheckedCreateInput>
  }

  /**
   * posts createMany
   */
  export type postsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many posts.
     */
    data: postsCreateManyInput | postsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * posts createManyAndReturn
   */
  export type postsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the posts
     */
    omit?: postsOmit<ExtArgs> | null
    /**
     * The data used to create many posts.
     */
    data: postsCreateManyInput | postsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * posts update
   */
  export type postsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the posts
     */
    omit?: postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * The data needed to update a posts.
     */
    data: XOR<postsUpdateInput, postsUncheckedUpdateInput>
    /**
     * Choose, which posts to update.
     */
    where: postsWhereUniqueInput
  }

  /**
   * posts updateMany
   */
  export type postsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update posts.
     */
    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyInput>
    /**
     * Filter which posts to update
     */
    where?: postsWhereInput
    /**
     * Limit how many posts to update.
     */
    limit?: number
  }

  /**
   * posts updateManyAndReturn
   */
  export type postsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the posts
     */
    omit?: postsOmit<ExtArgs> | null
    /**
     * The data used to update posts.
     */
    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyInput>
    /**
     * Filter which posts to update
     */
    where?: postsWhereInput
    /**
     * Limit how many posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * posts upsert
   */
  export type postsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the posts
     */
    omit?: postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * The filter to search for the posts to update in case it exists.
     */
    where: postsWhereUniqueInput
    /**
     * In case the posts found by the `where` argument doesn't exist, create a new posts with this data.
     */
    create: XOR<postsCreateInput, postsUncheckedCreateInput>
    /**
     * In case the posts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<postsUpdateInput, postsUncheckedUpdateInput>
  }

  /**
   * posts delete
   */
  export type postsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the posts
     */
    omit?: postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    /**
     * Filter which posts to delete.
     */
    where: postsWhereUniqueInput
  }

  /**
   * posts deleteMany
   */
  export type postsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which posts to delete
     */
    where?: postsWhereInput
    /**
     * Limit how many posts to delete.
     */
    limit?: number
  }

  /**
   * posts.comments
   */
  export type posts$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    cursor?: commentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * posts.post_tags
   */
  export type posts$post_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_tags
     */
    select?: post_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_tags
     */
    omit?: post_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_tagsInclude<ExtArgs> | null
    where?: post_tagsWhereInput
    orderBy?: post_tagsOrderByWithRelationInput | post_tagsOrderByWithRelationInput[]
    cursor?: post_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Post_tagsScalarFieldEnum | Post_tagsScalarFieldEnum[]
  }

  /**
   * posts.categories
   */
  export type posts$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
  }

  /**
   * posts.users
   */
  export type posts$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * posts.post_templates
   */
  export type posts$post_templatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_templates
     */
    select?: post_templatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_templates
     */
    omit?: post_templatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_templatesInclude<ExtArgs> | null
    where?: post_templatesWhereInput
  }

  /**
   * posts without action
   */
  export type postsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the posts
     */
    omit?: postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
  }


  /**
   * Model study_materials
   */

  export type AggregateStudy_materials = {
    _count: Study_materialsCountAggregateOutputType | null
    _avg: Study_materialsAvgAggregateOutputType | null
    _sum: Study_materialsSumAggregateOutputType | null
    _min: Study_materialsMinAggregateOutputType | null
    _max: Study_materialsMaxAggregateOutputType | null
  }

  export type Study_materialsAvgAggregateOutputType = {
    id: number | null
  }

  export type Study_materialsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Study_materialsMinAggregateOutputType = {
    id: bigint | null
    title: string | null
    description: string | null
    file_url: string | null
    created_at: Date | null
  }

  export type Study_materialsMaxAggregateOutputType = {
    id: bigint | null
    title: string | null
    description: string | null
    file_url: string | null
    created_at: Date | null
  }

  export type Study_materialsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    file_url: number
    created_at: number
    _all: number
  }


  export type Study_materialsAvgAggregateInputType = {
    id?: true
  }

  export type Study_materialsSumAggregateInputType = {
    id?: true
  }

  export type Study_materialsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    file_url?: true
    created_at?: true
  }

  export type Study_materialsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    file_url?: true
    created_at?: true
  }

  export type Study_materialsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    file_url?: true
    created_at?: true
    _all?: true
  }

  export type Study_materialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_materials to aggregate.
     */
    where?: study_materialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_materials to fetch.
     */
    orderBy?: study_materialsOrderByWithRelationInput | study_materialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: study_materialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned study_materials
    **/
    _count?: true | Study_materialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Study_materialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Study_materialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Study_materialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Study_materialsMaxAggregateInputType
  }

  export type GetStudy_materialsAggregateType<T extends Study_materialsAggregateArgs> = {
        [P in keyof T & keyof AggregateStudy_materials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudy_materials[P]>
      : GetScalarType<T[P], AggregateStudy_materials[P]>
  }




  export type study_materialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: study_materialsWhereInput
    orderBy?: study_materialsOrderByWithAggregationInput | study_materialsOrderByWithAggregationInput[]
    by: Study_materialsScalarFieldEnum[] | Study_materialsScalarFieldEnum
    having?: study_materialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Study_materialsCountAggregateInputType | true
    _avg?: Study_materialsAvgAggregateInputType
    _sum?: Study_materialsSumAggregateInputType
    _min?: Study_materialsMinAggregateInputType
    _max?: Study_materialsMaxAggregateInputType
  }

  export type Study_materialsGroupByOutputType = {
    id: bigint
    title: string
    description: string | null
    file_url: string
    created_at: Date | null
    _count: Study_materialsCountAggregateOutputType | null
    _avg: Study_materialsAvgAggregateOutputType | null
    _sum: Study_materialsSumAggregateOutputType | null
    _min: Study_materialsMinAggregateOutputType | null
    _max: Study_materialsMaxAggregateOutputType | null
  }

  type GetStudy_materialsGroupByPayload<T extends study_materialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Study_materialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Study_materialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Study_materialsGroupByOutputType[P]>
            : GetScalarType<T[P], Study_materialsGroupByOutputType[P]>
        }
      >
    >


  export type study_materialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    file_url?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["study_materials"]>

  export type study_materialsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    file_url?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["study_materials"]>

  export type study_materialsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    file_url?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["study_materials"]>

  export type study_materialsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    file_url?: boolean
    created_at?: boolean
  }

  export type study_materialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "file_url" | "created_at", ExtArgs["result"]["study_materials"]>

  export type $study_materialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "study_materials"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      title: string
      description: string | null
      file_url: string
      created_at: Date | null
    }, ExtArgs["result"]["study_materials"]>
    composites: {}
  }

  type study_materialsGetPayload<S extends boolean | null | undefined | study_materialsDefaultArgs> = $Result.GetResult<Prisma.$study_materialsPayload, S>

  type study_materialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<study_materialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Study_materialsCountAggregateInputType | true
    }

  export interface study_materialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['study_materials'], meta: { name: 'study_materials' } }
    /**
     * Find zero or one Study_materials that matches the filter.
     * @param {study_materialsFindUniqueArgs} args - Arguments to find a Study_materials
     * @example
     * // Get one Study_materials
     * const study_materials = await prisma.study_materials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends study_materialsFindUniqueArgs>(args: SelectSubset<T, study_materialsFindUniqueArgs<ExtArgs>>): Prisma__study_materialsClient<$Result.GetResult<Prisma.$study_materialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Study_materials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {study_materialsFindUniqueOrThrowArgs} args - Arguments to find a Study_materials
     * @example
     * // Get one Study_materials
     * const study_materials = await prisma.study_materials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends study_materialsFindUniqueOrThrowArgs>(args: SelectSubset<T, study_materialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__study_materialsClient<$Result.GetResult<Prisma.$study_materialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_materialsFindFirstArgs} args - Arguments to find a Study_materials
     * @example
     * // Get one Study_materials
     * const study_materials = await prisma.study_materials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends study_materialsFindFirstArgs>(args?: SelectSubset<T, study_materialsFindFirstArgs<ExtArgs>>): Prisma__study_materialsClient<$Result.GetResult<Prisma.$study_materialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Study_materials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_materialsFindFirstOrThrowArgs} args - Arguments to find a Study_materials
     * @example
     * // Get one Study_materials
     * const study_materials = await prisma.study_materials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends study_materialsFindFirstOrThrowArgs>(args?: SelectSubset<T, study_materialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__study_materialsClient<$Result.GetResult<Prisma.$study_materialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Study_materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_materialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Study_materials
     * const study_materials = await prisma.study_materials.findMany()
     * 
     * // Get first 10 Study_materials
     * const study_materials = await prisma.study_materials.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const study_materialsWithIdOnly = await prisma.study_materials.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends study_materialsFindManyArgs>(args?: SelectSubset<T, study_materialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_materialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Study_materials.
     * @param {study_materialsCreateArgs} args - Arguments to create a Study_materials.
     * @example
     * // Create one Study_materials
     * const Study_materials = await prisma.study_materials.create({
     *   data: {
     *     // ... data to create a Study_materials
     *   }
     * })
     * 
     */
    create<T extends study_materialsCreateArgs>(args: SelectSubset<T, study_materialsCreateArgs<ExtArgs>>): Prisma__study_materialsClient<$Result.GetResult<Prisma.$study_materialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Study_materials.
     * @param {study_materialsCreateManyArgs} args - Arguments to create many Study_materials.
     * @example
     * // Create many Study_materials
     * const study_materials = await prisma.study_materials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends study_materialsCreateManyArgs>(args?: SelectSubset<T, study_materialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Study_materials and returns the data saved in the database.
     * @param {study_materialsCreateManyAndReturnArgs} args - Arguments to create many Study_materials.
     * @example
     * // Create many Study_materials
     * const study_materials = await prisma.study_materials.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Study_materials and only return the `id`
     * const study_materialsWithIdOnly = await prisma.study_materials.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends study_materialsCreateManyAndReturnArgs>(args?: SelectSubset<T, study_materialsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_materialsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Study_materials.
     * @param {study_materialsDeleteArgs} args - Arguments to delete one Study_materials.
     * @example
     * // Delete one Study_materials
     * const Study_materials = await prisma.study_materials.delete({
     *   where: {
     *     // ... filter to delete one Study_materials
     *   }
     * })
     * 
     */
    delete<T extends study_materialsDeleteArgs>(args: SelectSubset<T, study_materialsDeleteArgs<ExtArgs>>): Prisma__study_materialsClient<$Result.GetResult<Prisma.$study_materialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Study_materials.
     * @param {study_materialsUpdateArgs} args - Arguments to update one Study_materials.
     * @example
     * // Update one Study_materials
     * const study_materials = await prisma.study_materials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends study_materialsUpdateArgs>(args: SelectSubset<T, study_materialsUpdateArgs<ExtArgs>>): Prisma__study_materialsClient<$Result.GetResult<Prisma.$study_materialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Study_materials.
     * @param {study_materialsDeleteManyArgs} args - Arguments to filter Study_materials to delete.
     * @example
     * // Delete a few Study_materials
     * const { count } = await prisma.study_materials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends study_materialsDeleteManyArgs>(args?: SelectSubset<T, study_materialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Study_materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_materialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Study_materials
     * const study_materials = await prisma.study_materials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends study_materialsUpdateManyArgs>(args: SelectSubset<T, study_materialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Study_materials and returns the data updated in the database.
     * @param {study_materialsUpdateManyAndReturnArgs} args - Arguments to update many Study_materials.
     * @example
     * // Update many Study_materials
     * const study_materials = await prisma.study_materials.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Study_materials and only return the `id`
     * const study_materialsWithIdOnly = await prisma.study_materials.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends study_materialsUpdateManyAndReturnArgs>(args: SelectSubset<T, study_materialsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$study_materialsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Study_materials.
     * @param {study_materialsUpsertArgs} args - Arguments to update or create a Study_materials.
     * @example
     * // Update or create a Study_materials
     * const study_materials = await prisma.study_materials.upsert({
     *   create: {
     *     // ... data to create a Study_materials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Study_materials we want to update
     *   }
     * })
     */
    upsert<T extends study_materialsUpsertArgs>(args: SelectSubset<T, study_materialsUpsertArgs<ExtArgs>>): Prisma__study_materialsClient<$Result.GetResult<Prisma.$study_materialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Study_materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_materialsCountArgs} args - Arguments to filter Study_materials to count.
     * @example
     * // Count the number of Study_materials
     * const count = await prisma.study_materials.count({
     *   where: {
     *     // ... the filter for the Study_materials we want to count
     *   }
     * })
    **/
    count<T extends study_materialsCountArgs>(
      args?: Subset<T, study_materialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Study_materialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Study_materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Study_materialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Study_materialsAggregateArgs>(args: Subset<T, Study_materialsAggregateArgs>): Prisma.PrismaPromise<GetStudy_materialsAggregateType<T>>

    /**
     * Group by Study_materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {study_materialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends study_materialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: study_materialsGroupByArgs['orderBy'] }
        : { orderBy?: study_materialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, study_materialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudy_materialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the study_materials model
   */
  readonly fields: study_materialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for study_materials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__study_materialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the study_materials model
   */
  interface study_materialsFieldRefs {
    readonly id: FieldRef<"study_materials", 'BigInt'>
    readonly title: FieldRef<"study_materials", 'String'>
    readonly description: FieldRef<"study_materials", 'String'>
    readonly file_url: FieldRef<"study_materials", 'String'>
    readonly created_at: FieldRef<"study_materials", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * study_materials findUnique
   */
  export type study_materialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_materials
     */
    select?: study_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_materials
     */
    omit?: study_materialsOmit<ExtArgs> | null
    /**
     * Filter, which study_materials to fetch.
     */
    where: study_materialsWhereUniqueInput
  }

  /**
   * study_materials findUniqueOrThrow
   */
  export type study_materialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_materials
     */
    select?: study_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_materials
     */
    omit?: study_materialsOmit<ExtArgs> | null
    /**
     * Filter, which study_materials to fetch.
     */
    where: study_materialsWhereUniqueInput
  }

  /**
   * study_materials findFirst
   */
  export type study_materialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_materials
     */
    select?: study_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_materials
     */
    omit?: study_materialsOmit<ExtArgs> | null
    /**
     * Filter, which study_materials to fetch.
     */
    where?: study_materialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_materials to fetch.
     */
    orderBy?: study_materialsOrderByWithRelationInput | study_materialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_materials.
     */
    cursor?: study_materialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_materials.
     */
    distinct?: Study_materialsScalarFieldEnum | Study_materialsScalarFieldEnum[]
  }

  /**
   * study_materials findFirstOrThrow
   */
  export type study_materialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_materials
     */
    select?: study_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_materials
     */
    omit?: study_materialsOmit<ExtArgs> | null
    /**
     * Filter, which study_materials to fetch.
     */
    where?: study_materialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_materials to fetch.
     */
    orderBy?: study_materialsOrderByWithRelationInput | study_materialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for study_materials.
     */
    cursor?: study_materialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of study_materials.
     */
    distinct?: Study_materialsScalarFieldEnum | Study_materialsScalarFieldEnum[]
  }

  /**
   * study_materials findMany
   */
  export type study_materialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_materials
     */
    select?: study_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_materials
     */
    omit?: study_materialsOmit<ExtArgs> | null
    /**
     * Filter, which study_materials to fetch.
     */
    where?: study_materialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of study_materials to fetch.
     */
    orderBy?: study_materialsOrderByWithRelationInput | study_materialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing study_materials.
     */
    cursor?: study_materialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` study_materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` study_materials.
     */
    skip?: number
    distinct?: Study_materialsScalarFieldEnum | Study_materialsScalarFieldEnum[]
  }

  /**
   * study_materials create
   */
  export type study_materialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_materials
     */
    select?: study_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_materials
     */
    omit?: study_materialsOmit<ExtArgs> | null
    /**
     * The data needed to create a study_materials.
     */
    data: XOR<study_materialsCreateInput, study_materialsUncheckedCreateInput>
  }

  /**
   * study_materials createMany
   */
  export type study_materialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many study_materials.
     */
    data: study_materialsCreateManyInput | study_materialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * study_materials createManyAndReturn
   */
  export type study_materialsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_materials
     */
    select?: study_materialsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the study_materials
     */
    omit?: study_materialsOmit<ExtArgs> | null
    /**
     * The data used to create many study_materials.
     */
    data: study_materialsCreateManyInput | study_materialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * study_materials update
   */
  export type study_materialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_materials
     */
    select?: study_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_materials
     */
    omit?: study_materialsOmit<ExtArgs> | null
    /**
     * The data needed to update a study_materials.
     */
    data: XOR<study_materialsUpdateInput, study_materialsUncheckedUpdateInput>
    /**
     * Choose, which study_materials to update.
     */
    where: study_materialsWhereUniqueInput
  }

  /**
   * study_materials updateMany
   */
  export type study_materialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update study_materials.
     */
    data: XOR<study_materialsUpdateManyMutationInput, study_materialsUncheckedUpdateManyInput>
    /**
     * Filter which study_materials to update
     */
    where?: study_materialsWhereInput
    /**
     * Limit how many study_materials to update.
     */
    limit?: number
  }

  /**
   * study_materials updateManyAndReturn
   */
  export type study_materialsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_materials
     */
    select?: study_materialsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the study_materials
     */
    omit?: study_materialsOmit<ExtArgs> | null
    /**
     * The data used to update study_materials.
     */
    data: XOR<study_materialsUpdateManyMutationInput, study_materialsUncheckedUpdateManyInput>
    /**
     * Filter which study_materials to update
     */
    where?: study_materialsWhereInput
    /**
     * Limit how many study_materials to update.
     */
    limit?: number
  }

  /**
   * study_materials upsert
   */
  export type study_materialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_materials
     */
    select?: study_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_materials
     */
    omit?: study_materialsOmit<ExtArgs> | null
    /**
     * The filter to search for the study_materials to update in case it exists.
     */
    where: study_materialsWhereUniqueInput
    /**
     * In case the study_materials found by the `where` argument doesn't exist, create a new study_materials with this data.
     */
    create: XOR<study_materialsCreateInput, study_materialsUncheckedCreateInput>
    /**
     * In case the study_materials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<study_materialsUpdateInput, study_materialsUncheckedUpdateInput>
  }

  /**
   * study_materials delete
   */
  export type study_materialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_materials
     */
    select?: study_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_materials
     */
    omit?: study_materialsOmit<ExtArgs> | null
    /**
     * Filter which study_materials to delete.
     */
    where: study_materialsWhereUniqueInput
  }

  /**
   * study_materials deleteMany
   */
  export type study_materialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which study_materials to delete
     */
    where?: study_materialsWhereInput
    /**
     * Limit how many study_materials to delete.
     */
    limit?: number
  }

  /**
   * study_materials without action
   */
  export type study_materialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the study_materials
     */
    select?: study_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the study_materials
     */
    omit?: study_materialsOmit<ExtArgs> | null
  }


  /**
   * Model tags
   */

  export type AggregateTags = {
    _count: TagsCountAggregateOutputType | null
    _avg: TagsAvgAggregateOutputType | null
    _sum: TagsSumAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  export type TagsAvgAggregateOutputType = {
    id: number | null
  }

  export type TagsSumAggregateOutputType = {
    id: bigint | null
  }

  export type TagsMinAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type TagsMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
  }

  export type TagsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type TagsAvgAggregateInputType = {
    id?: true
  }

  export type TagsSumAggregateInputType = {
    id?: true
  }

  export type TagsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type TagsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type TagsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type TagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tags to aggregate.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tags
    **/
    _count?: true | TagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagsMaxAggregateInputType
  }

  export type GetTagsAggregateType<T extends TagsAggregateArgs> = {
        [P in keyof T & keyof AggregateTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTags[P]>
      : GetScalarType<T[P], AggregateTags[P]>
  }




  export type tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tagsWhereInput
    orderBy?: tagsOrderByWithAggregationInput | tagsOrderByWithAggregationInput[]
    by: TagsScalarFieldEnum[] | TagsScalarFieldEnum
    having?: tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagsCountAggregateInputType | true
    _avg?: TagsAvgAggregateInputType
    _sum?: TagsSumAggregateInputType
    _min?: TagsMinAggregateInputType
    _max?: TagsMaxAggregateInputType
  }

  export type TagsGroupByOutputType = {
    id: bigint
    name: string
    _count: TagsCountAggregateOutputType | null
    _avg: TagsAvgAggregateOutputType | null
    _sum: TagsSumAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  type GetTagsGroupByPayload<T extends tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagsGroupByOutputType[P]>
            : GetScalarType<T[P], TagsGroupByOutputType[P]>
        }
      >
    >


  export type tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    post_tags?: boolean | tags$post_tagsArgs<ExtArgs>
    _count?: boolean | TagsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tags"]>

  export type tagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["tags"]>

  export type tagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["tags"]>

  export type tagsSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type tagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["tags"]>
  export type tagsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post_tags?: boolean | tags$post_tagsArgs<ExtArgs>
    _count?: boolean | TagsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tagsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type tagsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tags"
    objects: {
      post_tags: Prisma.$post_tagsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
    }, ExtArgs["result"]["tags"]>
    composites: {}
  }

  type tagsGetPayload<S extends boolean | null | undefined | tagsDefaultArgs> = $Result.GetResult<Prisma.$tagsPayload, S>

  type tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagsCountAggregateInputType | true
    }

  export interface tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tags'], meta: { name: 'tags' } }
    /**
     * Find zero or one Tags that matches the filter.
     * @param {tagsFindUniqueArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tagsFindUniqueArgs>(args: SelectSubset<T, tagsFindUniqueArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tagsFindUniqueOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tagsFindUniqueOrThrowArgs>(args: SelectSubset<T, tagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindFirstArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tagsFindFirstArgs>(args?: SelectSubset<T, tagsFindFirstArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindFirstOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tagsFindFirstOrThrowArgs>(args?: SelectSubset<T, tagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tags.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tags.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagsWithIdOnly = await prisma.tags.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tagsFindManyArgs>(args?: SelectSubset<T, tagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tags.
     * @param {tagsCreateArgs} args - Arguments to create a Tags.
     * @example
     * // Create one Tags
     * const Tags = await prisma.tags.create({
     *   data: {
     *     // ... data to create a Tags
     *   }
     * })
     * 
     */
    create<T extends tagsCreateArgs>(args: SelectSubset<T, tagsCreateArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {tagsCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tagsCreateManyArgs>(args?: SelectSubset<T, tagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {tagsCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagsWithIdOnly = await prisma.tags.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tagsCreateManyAndReturnArgs>(args?: SelectSubset<T, tagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tags.
     * @param {tagsDeleteArgs} args - Arguments to delete one Tags.
     * @example
     * // Delete one Tags
     * const Tags = await prisma.tags.delete({
     *   where: {
     *     // ... filter to delete one Tags
     *   }
     * })
     * 
     */
    delete<T extends tagsDeleteArgs>(args: SelectSubset<T, tagsDeleteArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tags.
     * @param {tagsUpdateArgs} args - Arguments to update one Tags.
     * @example
     * // Update one Tags
     * const tags = await prisma.tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tagsUpdateArgs>(args: SelectSubset<T, tagsUpdateArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {tagsDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tagsDeleteManyArgs>(args?: SelectSubset<T, tagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tagsUpdateManyArgs>(args: SelectSubset<T, tagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {tagsUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagsWithIdOnly = await prisma.tags.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tagsUpdateManyAndReturnArgs>(args: SelectSubset<T, tagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tags.
     * @param {tagsUpsertArgs} args - Arguments to update or create a Tags.
     * @example
     * // Update or create a Tags
     * const tags = await prisma.tags.upsert({
     *   create: {
     *     // ... data to create a Tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tags we want to update
     *   }
     * })
     */
    upsert<T extends tagsUpsertArgs>(args: SelectSubset<T, tagsUpsertArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tags.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends tagsCountArgs>(
      args?: Subset<T, tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagsAggregateArgs>(args: Subset<T, TagsAggregateArgs>): Prisma.PrismaPromise<GetTagsAggregateType<T>>

    /**
     * Group by Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tagsGroupByArgs['orderBy'] }
        : { orderBy?: tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tags model
   */
  readonly fields: tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post_tags<T extends tags$post_tagsArgs<ExtArgs> = {}>(args?: Subset<T, tags$post_tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$post_tagsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tags model
   */
  interface tagsFieldRefs {
    readonly id: FieldRef<"tags", 'BigInt'>
    readonly name: FieldRef<"tags", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tags findUnique
   */
  export type tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags findUniqueOrThrow
   */
  export type tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags findFirst
   */
  export type tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * tags findFirstOrThrow
   */
  export type tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * tags findMany
   */
  export type tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * tags create
   */
  export type tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * The data needed to create a tags.
     */
    data: XOR<tagsCreateInput, tagsUncheckedCreateInput>
  }

  /**
   * tags createMany
   */
  export type tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tags.
     */
    data: tagsCreateManyInput | tagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tags createManyAndReturn
   */
  export type tagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * The data used to create many tags.
     */
    data: tagsCreateManyInput | tagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tags update
   */
  export type tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * The data needed to update a tags.
     */
    data: XOR<tagsUpdateInput, tagsUncheckedUpdateInput>
    /**
     * Choose, which tags to update.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags updateMany
   */
  export type tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tags.
     */
    data: XOR<tagsUpdateManyMutationInput, tagsUncheckedUpdateManyInput>
    /**
     * Filter which tags to update
     */
    where?: tagsWhereInput
    /**
     * Limit how many tags to update.
     */
    limit?: number
  }

  /**
   * tags updateManyAndReturn
   */
  export type tagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * The data used to update tags.
     */
    data: XOR<tagsUpdateManyMutationInput, tagsUncheckedUpdateManyInput>
    /**
     * Filter which tags to update
     */
    where?: tagsWhereInput
    /**
     * Limit how many tags to update.
     */
    limit?: number
  }

  /**
   * tags upsert
   */
  export type tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * The filter to search for the tags to update in case it exists.
     */
    where: tagsWhereUniqueInput
    /**
     * In case the tags found by the `where` argument doesn't exist, create a new tags with this data.
     */
    create: XOR<tagsCreateInput, tagsUncheckedCreateInput>
    /**
     * In case the tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tagsUpdateInput, tagsUncheckedUpdateInput>
  }

  /**
   * tags delete
   */
  export type tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
    /**
     * Filter which tags to delete.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags deleteMany
   */
  export type tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tags to delete
     */
    where?: tagsWhereInput
    /**
     * Limit how many tags to delete.
     */
    limit?: number
  }

  /**
   * tags.post_tags
   */
  export type tags$post_tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_tags
     */
    select?: post_tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_tags
     */
    omit?: post_tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_tagsInclude<ExtArgs> | null
    where?: post_tagsWhereInput
    orderBy?: post_tagsOrderByWithRelationInput | post_tagsOrderByWithRelationInput[]
    cursor?: post_tagsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Post_tagsScalarFieldEnum | Post_tagsScalarFieldEnum[]
  }

  /**
   * tags without action
   */
  export type tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tagsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: bigint | null
  }

  export type UsersMinAggregateOutputType = {
    id: bigint | null
    full_name: string | null
    email: string | null
    password_hash: string | null
    role: $Enums.user_role | null
    created_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: bigint | null
    full_name: string | null
    email: string | null
    password_hash: string | null
    role: $Enums.user_role | null
    created_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    full_name: number
    email: number
    password_hash: number
    role: number
    created_at: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password_hash?: true
    role?: true
    created_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password_hash?: true
    role?: true
    created_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    full_name?: true
    email?: true
    password_hash?: true
    role?: true
    created_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: bigint
    full_name: string
    email: string
    password_hash: string
    role: $Enums.user_role | null
    created_at: Date | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    created_at?: boolean
    comments?: boolean | users$commentsArgs<ExtArgs>
    course_reviews?: boolean | users$course_reviewsArgs<ExtArgs>
    enrollments?: boolean | users$enrollmentsArgs<ExtArgs>
    mock_attempts?: boolean | users$mock_attemptsArgs<ExtArgs>
    payments?: boolean | users$paymentsArgs<ExtArgs>
    posts?: boolean | users$postsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    full_name?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    full_name?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    created_at?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "full_name" | "email" | "password_hash" | "role" | "created_at", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | users$commentsArgs<ExtArgs>
    course_reviews?: boolean | users$course_reviewsArgs<ExtArgs>
    enrollments?: boolean | users$enrollmentsArgs<ExtArgs>
    mock_attempts?: boolean | users$mock_attemptsArgs<ExtArgs>
    payments?: boolean | users$paymentsArgs<ExtArgs>
    posts?: boolean | users$postsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      comments: Prisma.$commentsPayload<ExtArgs>[]
      course_reviews: Prisma.$course_reviewsPayload<ExtArgs>[]
      enrollments: Prisma.$enrollmentsPayload<ExtArgs>[]
      mock_attempts: Prisma.$mock_attemptsPayload<ExtArgs>[]
      payments: Prisma.$paymentsPayload<ExtArgs>[]
      posts: Prisma.$postsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      full_name: string
      email: string
      password_hash: string
      role: $Enums.user_role | null
      created_at: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends users$commentsArgs<ExtArgs> = {}>(args?: Subset<T, users$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    course_reviews<T extends users$course_reviewsArgs<ExtArgs> = {}>(args?: Subset<T, users$course_reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$course_reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    enrollments<T extends users$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, users$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$enrollmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mock_attempts<T extends users$mock_attemptsArgs<ExtArgs> = {}>(args?: Subset<T, users$mock_attemptsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mock_attemptsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends users$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, users$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends users$postsArgs<ExtArgs> = {}>(args?: Subset<T, users$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'BigInt'>
    readonly full_name: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password_hash: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'user_role'>
    readonly created_at: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.comments
   */
  export type users$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comments
     */
    select?: commentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comments
     */
    omit?: commentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentsInclude<ExtArgs> | null
    where?: commentsWhereInput
    orderBy?: commentsOrderByWithRelationInput | commentsOrderByWithRelationInput[]
    cursor?: commentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentsScalarFieldEnum | CommentsScalarFieldEnum[]
  }

  /**
   * users.course_reviews
   */
  export type users$course_reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the course_reviews
     */
    select?: course_reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the course_reviews
     */
    omit?: course_reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: course_reviewsInclude<ExtArgs> | null
    where?: course_reviewsWhereInput
    orderBy?: course_reviewsOrderByWithRelationInput | course_reviewsOrderByWithRelationInput[]
    cursor?: course_reviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Course_reviewsScalarFieldEnum | Course_reviewsScalarFieldEnum[]
  }

  /**
   * users.enrollments
   */
  export type users$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the enrollments
     */
    select?: enrollmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the enrollments
     */
    omit?: enrollmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: enrollmentsInclude<ExtArgs> | null
    where?: enrollmentsWhereInput
    orderBy?: enrollmentsOrderByWithRelationInput | enrollmentsOrderByWithRelationInput[]
    cursor?: enrollmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EnrollmentsScalarFieldEnum | EnrollmentsScalarFieldEnum[]
  }

  /**
   * users.mock_attempts
   */
  export type users$mock_attemptsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mock_attempts
     */
    select?: mock_attemptsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mock_attempts
     */
    omit?: mock_attemptsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mock_attemptsInclude<ExtArgs> | null
    where?: mock_attemptsWhereInput
    orderBy?: mock_attemptsOrderByWithRelationInput | mock_attemptsOrderByWithRelationInput[]
    cursor?: mock_attemptsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Mock_attemptsScalarFieldEnum | Mock_attemptsScalarFieldEnum[]
  }

  /**
   * users.payments
   */
  export type users$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * users.posts
   */
  export type users$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the posts
     */
    select?: postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the posts
     */
    omit?: postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postsInclude<ExtArgs> | null
    where?: postsWhereInput
    orderBy?: postsOrderByWithRelationInput | postsOrderByWithRelationInput[]
    cursor?: postsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostsScalarFieldEnum | PostsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Answer_keysScalarFieldEnum: {
    id: 'id',
    title: 'title',
    year: 'year',
    file_url: 'file_url',
    created_at: 'created_at'
  };

  export type Answer_keysScalarFieldEnum = (typeof Answer_keysScalarFieldEnum)[keyof typeof Answer_keysScalarFieldEnum]


  export const CategoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    created_at: 'created_at'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const CommentsScalarFieldEnum: {
    id: 'id',
    post_id: 'post_id',
    user_id: 'user_id',
    content: 'content',
    created_at: 'created_at'
  };

  export type CommentsScalarFieldEnum = (typeof CommentsScalarFieldEnum)[keyof typeof CommentsScalarFieldEnum]


  export const Course_plansScalarFieldEnum: {
    id: 'id',
    course_id: 'course_id',
    plan_type: 'plan_type',
    plan_name: 'plan_name',
    price: 'price',
    duration_days: 'duration_days',
    created_at: 'created_at'
  };

  export type Course_plansScalarFieldEnum = (typeof Course_plansScalarFieldEnum)[keyof typeof Course_plansScalarFieldEnum]


  export const Course_reviewsScalarFieldEnum: {
    id: 'id',
    course_id: 'course_id',
    user_id: 'user_id',
    rating: 'rating',
    review: 'review',
    created_at: 'created_at'
  };

  export type Course_reviewsScalarFieldEnum = (typeof Course_reviewsScalarFieldEnum)[keyof typeof Course_reviewsScalarFieldEnum]


  export const Course_videosScalarFieldEnum: {
    id: 'id',
    course_id: 'course_id',
    title: 'title',
    video_url: 'video_url',
    position: 'position',
    is_demo: 'is_demo',
    created_at: 'created_at'
  };

  export type Course_videosScalarFieldEnum = (typeof Course_videosScalarFieldEnum)[keyof typeof Course_videosScalarFieldEnum]


  export const CoursesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    thumbnail_url: 'thumbnail_url',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CoursesScalarFieldEnum = (typeof CoursesScalarFieldEnum)[keyof typeof CoursesScalarFieldEnum]


  export const EnrollmentsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    course_id: 'course_id',
    plan_id: 'plan_id',
    status: 'status',
    started_at: 'started_at',
    expires_at: 'expires_at'
  };

  export type EnrollmentsScalarFieldEnum = (typeof EnrollmentsScalarFieldEnum)[keyof typeof EnrollmentsScalarFieldEnum]


  export const Google_adsScalarFieldEnum: {
    id: 'id',
    placement: 'placement',
    ad_code: 'ad_code',
    created_at: 'created_at'
  };

  export type Google_adsScalarFieldEnum = (typeof Google_adsScalarFieldEnum)[keyof typeof Google_adsScalarFieldEnum]


  export const Mock_attemptsScalarFieldEnum: {
    id: 'id',
    test_id: 'test_id',
    user_id: 'user_id',
    answers: 'answers',
    score: 'score',
    started_at: 'started_at',
    completed_at: 'completed_at'
  };

  export type Mock_attemptsScalarFieldEnum = (typeof Mock_attemptsScalarFieldEnum)[keyof typeof Mock_attemptsScalarFieldEnum]


  export const Mock_categoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type Mock_categoriesScalarFieldEnum = (typeof Mock_categoriesScalarFieldEnum)[keyof typeof Mock_categoriesScalarFieldEnum]


  export const Mock_questionsScalarFieldEnum: {
    id: 'id',
    test_id: 'test_id',
    question_text: 'question_text',
    question_type: 'question_type',
    options: 'options',
    correct_answer: 'correct_answer',
    marks: 'marks'
  };

  export type Mock_questionsScalarFieldEnum = (typeof Mock_questionsScalarFieldEnum)[keyof typeof Mock_questionsScalarFieldEnum]


  export const Mock_seriesScalarFieldEnum: {
    id: 'id',
    category_id: 'category_id',
    title: 'title',
    description: 'description',
    created_at: 'created_at',
    price: 'price'
  };

  export type Mock_seriesScalarFieldEnum = (typeof Mock_seriesScalarFieldEnum)[keyof typeof Mock_seriesScalarFieldEnum]


  export const Mock_testsScalarFieldEnum: {
    id: 'id',
    series_id: 'series_id',
    title: 'title',
    description: 'description',
    duration_minutes: 'duration_minutes',
    total_marks: 'total_marks',
    created_at: 'created_at',
    is_free: 'is_free'
  };

  export type Mock_testsScalarFieldEnum = (typeof Mock_testsScalarFieldEnum)[keyof typeof Mock_testsScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    course_id: 'course_id',
    amount: 'amount',
    payment_method: 'payment_method',
    status: 'status',
    transaction_id: 'transaction_id',
    created_at: 'created_at',
    mock_series_id: 'mock_series_id'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const Post_tagsScalarFieldEnum: {
    post_id: 'post_id',
    tag_id: 'tag_id'
  };

  export type Post_tagsScalarFieldEnum = (typeof Post_tagsScalarFieldEnum)[keyof typeof Post_tagsScalarFieldEnum]


  export const Post_templatesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    structure: 'structure',
    created_at: 'created_at'
  };

  export type Post_templatesScalarFieldEnum = (typeof Post_templatesScalarFieldEnum)[keyof typeof Post_templatesScalarFieldEnum]


  export const PostsScalarFieldEnum: {
    id: 'id',
    category_id: 'category_id',
    title: 'title',
    slug: 'slug',
    content: 'content',
    external_url: 'external_url',
    thumbnail_url: 'thumbnail_url',
    published_at: 'published_at',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at',
    template_id: 'template_id',
    content_json: 'content_json',
    content_html: 'content_html'
  };

  export type PostsScalarFieldEnum = (typeof PostsScalarFieldEnum)[keyof typeof PostsScalarFieldEnum]


  export const Study_materialsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    file_url: 'file_url',
    created_at: 'created_at'
  };

  export type Study_materialsScalarFieldEnum = (typeof Study_materialsScalarFieldEnum)[keyof typeof Study_materialsScalarFieldEnum]


  export const TagsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type TagsScalarFieldEnum = (typeof TagsScalarFieldEnum)[keyof typeof TagsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    full_name: 'full_name',
    email: 'email',
    password_hash: 'password_hash',
    role: 'role',
    created_at: 'created_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'plan_type'
   */
  export type Enumplan_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'plan_type'>
    


  /**
   * Reference to a field of type 'plan_type[]'
   */
  export type ListEnumplan_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'plan_type[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'enrollment_status'
   */
  export type Enumenrollment_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enrollment_status'>
    


  /**
   * Reference to a field of type 'enrollment_status[]'
   */
  export type ListEnumenrollment_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enrollment_status[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'question_type'
   */
  export type Enumquestion_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'question_type'>
    


  /**
   * Reference to a field of type 'question_type[]'
   */
  export type ListEnumquestion_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'question_type[]'>
    


  /**
   * Reference to a field of type 'payment_status'
   */
  export type Enumpayment_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payment_status'>
    


  /**
   * Reference to a field of type 'payment_status[]'
   */
  export type ListEnumpayment_statusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'payment_status[]'>
    


  /**
   * Reference to a field of type 'user_role'
   */
  export type Enumuser_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_role'>
    


  /**
   * Reference to a field of type 'user_role[]'
   */
  export type ListEnumuser_roleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'user_role[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type answer_keysWhereInput = {
    AND?: answer_keysWhereInput | answer_keysWhereInput[]
    OR?: answer_keysWhereInput[]
    NOT?: answer_keysWhereInput | answer_keysWhereInput[]
    id?: BigIntFilter<"answer_keys"> | bigint | number
    title?: StringFilter<"answer_keys"> | string
    year?: IntNullableFilter<"answer_keys"> | number | null
    file_url?: StringFilter<"answer_keys"> | string
    created_at?: DateTimeNullableFilter<"answer_keys"> | Date | string | null
  }

  export type answer_keysOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrderInput | SortOrder
    file_url?: SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type answer_keysWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: answer_keysWhereInput | answer_keysWhereInput[]
    OR?: answer_keysWhereInput[]
    NOT?: answer_keysWhereInput | answer_keysWhereInput[]
    title?: StringFilter<"answer_keys"> | string
    year?: IntNullableFilter<"answer_keys"> | number | null
    file_url?: StringFilter<"answer_keys"> | string
    created_at?: DateTimeNullableFilter<"answer_keys"> | Date | string | null
  }, "id">

  export type answer_keysOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrderInput | SortOrder
    file_url?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: answer_keysCountOrderByAggregateInput
    _avg?: answer_keysAvgOrderByAggregateInput
    _max?: answer_keysMaxOrderByAggregateInput
    _min?: answer_keysMinOrderByAggregateInput
    _sum?: answer_keysSumOrderByAggregateInput
  }

  export type answer_keysScalarWhereWithAggregatesInput = {
    AND?: answer_keysScalarWhereWithAggregatesInput | answer_keysScalarWhereWithAggregatesInput[]
    OR?: answer_keysScalarWhereWithAggregatesInput[]
    NOT?: answer_keysScalarWhereWithAggregatesInput | answer_keysScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"answer_keys"> | bigint | number
    title?: StringWithAggregatesFilter<"answer_keys"> | string
    year?: IntNullableWithAggregatesFilter<"answer_keys"> | number | null
    file_url?: StringWithAggregatesFilter<"answer_keys"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"answer_keys"> | Date | string | null
  }

  export type categoriesWhereInput = {
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    id?: BigIntFilter<"categories"> | bigint | number
    name?: StringFilter<"categories"> | string
    description?: StringNullableFilter<"categories"> | string | null
    created_at?: DateTimeNullableFilter<"categories"> | Date | string | null
    posts?: PostsListRelationFilter
  }

  export type categoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    posts?: postsOrderByRelationAggregateInput
  }

  export type categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    name?: string
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    description?: StringNullableFilter<"categories"> | string | null
    created_at?: DateTimeNullableFilter<"categories"> | Date | string | null
    posts?: PostsListRelationFilter
  }, "id" | "name">

  export type categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: categoriesCountOrderByAggregateInput
    _avg?: categoriesAvgOrderByAggregateInput
    _max?: categoriesMaxOrderByAggregateInput
    _min?: categoriesMinOrderByAggregateInput
    _sum?: categoriesSumOrderByAggregateInput
  }

  export type categoriesScalarWhereWithAggregatesInput = {
    AND?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    OR?: categoriesScalarWhereWithAggregatesInput[]
    NOT?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"categories"> | bigint | number
    name?: StringWithAggregatesFilter<"categories"> | string
    description?: StringNullableWithAggregatesFilter<"categories"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"categories"> | Date | string | null
  }

  export type commentsWhereInput = {
    AND?: commentsWhereInput | commentsWhereInput[]
    OR?: commentsWhereInput[]
    NOT?: commentsWhereInput | commentsWhereInput[]
    id?: BigIntFilter<"comments"> | bigint | number
    post_id?: BigIntNullableFilter<"comments"> | bigint | number | null
    user_id?: BigIntNullableFilter<"comments"> | bigint | number | null
    content?: StringFilter<"comments"> | string
    created_at?: DateTimeNullableFilter<"comments"> | Date | string | null
    posts?: XOR<PostsNullableScalarRelationFilter, postsWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type commentsOrderByWithRelationInput = {
    id?: SortOrder
    post_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    content?: SortOrder
    created_at?: SortOrderInput | SortOrder
    posts?: postsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type commentsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: commentsWhereInput | commentsWhereInput[]
    OR?: commentsWhereInput[]
    NOT?: commentsWhereInput | commentsWhereInput[]
    post_id?: BigIntNullableFilter<"comments"> | bigint | number | null
    user_id?: BigIntNullableFilter<"comments"> | bigint | number | null
    content?: StringFilter<"comments"> | string
    created_at?: DateTimeNullableFilter<"comments"> | Date | string | null
    posts?: XOR<PostsNullableScalarRelationFilter, postsWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type commentsOrderByWithAggregationInput = {
    id?: SortOrder
    post_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    content?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: commentsCountOrderByAggregateInput
    _avg?: commentsAvgOrderByAggregateInput
    _max?: commentsMaxOrderByAggregateInput
    _min?: commentsMinOrderByAggregateInput
    _sum?: commentsSumOrderByAggregateInput
  }

  export type commentsScalarWhereWithAggregatesInput = {
    AND?: commentsScalarWhereWithAggregatesInput | commentsScalarWhereWithAggregatesInput[]
    OR?: commentsScalarWhereWithAggregatesInput[]
    NOT?: commentsScalarWhereWithAggregatesInput | commentsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"comments"> | bigint | number
    post_id?: BigIntNullableWithAggregatesFilter<"comments"> | bigint | number | null
    user_id?: BigIntNullableWithAggregatesFilter<"comments"> | bigint | number | null
    content?: StringWithAggregatesFilter<"comments"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"comments"> | Date | string | null
  }

  export type course_plansWhereInput = {
    AND?: course_plansWhereInput | course_plansWhereInput[]
    OR?: course_plansWhereInput[]
    NOT?: course_plansWhereInput | course_plansWhereInput[]
    id?: BigIntFilter<"course_plans"> | bigint | number
    course_id?: BigIntNullableFilter<"course_plans"> | bigint | number | null
    plan_type?: Enumplan_typeFilter<"course_plans"> | $Enums.plan_type
    plan_name?: StringFilter<"course_plans"> | string
    price?: DecimalNullableFilter<"course_plans"> | Decimal | DecimalJsLike | number | string | null
    duration_days?: IntNullableFilter<"course_plans"> | number | null
    created_at?: DateTimeNullableFilter<"course_plans"> | Date | string | null
    courses?: XOR<CoursesNullableScalarRelationFilter, coursesWhereInput> | null
    enrollments?: EnrollmentsListRelationFilter
  }

  export type course_plansOrderByWithRelationInput = {
    id?: SortOrder
    course_id?: SortOrderInput | SortOrder
    plan_type?: SortOrder
    plan_name?: SortOrder
    price?: SortOrderInput | SortOrder
    duration_days?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    courses?: coursesOrderByWithRelationInput
    enrollments?: enrollmentsOrderByRelationAggregateInput
  }

  export type course_plansWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: course_plansWhereInput | course_plansWhereInput[]
    OR?: course_plansWhereInput[]
    NOT?: course_plansWhereInput | course_plansWhereInput[]
    course_id?: BigIntNullableFilter<"course_plans"> | bigint | number | null
    plan_type?: Enumplan_typeFilter<"course_plans"> | $Enums.plan_type
    plan_name?: StringFilter<"course_plans"> | string
    price?: DecimalNullableFilter<"course_plans"> | Decimal | DecimalJsLike | number | string | null
    duration_days?: IntNullableFilter<"course_plans"> | number | null
    created_at?: DateTimeNullableFilter<"course_plans"> | Date | string | null
    courses?: XOR<CoursesNullableScalarRelationFilter, coursesWhereInput> | null
    enrollments?: EnrollmentsListRelationFilter
  }, "id">

  export type course_plansOrderByWithAggregationInput = {
    id?: SortOrder
    course_id?: SortOrderInput | SortOrder
    plan_type?: SortOrder
    plan_name?: SortOrder
    price?: SortOrderInput | SortOrder
    duration_days?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: course_plansCountOrderByAggregateInput
    _avg?: course_plansAvgOrderByAggregateInput
    _max?: course_plansMaxOrderByAggregateInput
    _min?: course_plansMinOrderByAggregateInput
    _sum?: course_plansSumOrderByAggregateInput
  }

  export type course_plansScalarWhereWithAggregatesInput = {
    AND?: course_plansScalarWhereWithAggregatesInput | course_plansScalarWhereWithAggregatesInput[]
    OR?: course_plansScalarWhereWithAggregatesInput[]
    NOT?: course_plansScalarWhereWithAggregatesInput | course_plansScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"course_plans"> | bigint | number
    course_id?: BigIntNullableWithAggregatesFilter<"course_plans"> | bigint | number | null
    plan_type?: Enumplan_typeWithAggregatesFilter<"course_plans"> | $Enums.plan_type
    plan_name?: StringWithAggregatesFilter<"course_plans"> | string
    price?: DecimalNullableWithAggregatesFilter<"course_plans"> | Decimal | DecimalJsLike | number | string | null
    duration_days?: IntNullableWithAggregatesFilter<"course_plans"> | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"course_plans"> | Date | string | null
  }

  export type course_reviewsWhereInput = {
    AND?: course_reviewsWhereInput | course_reviewsWhereInput[]
    OR?: course_reviewsWhereInput[]
    NOT?: course_reviewsWhereInput | course_reviewsWhereInput[]
    id?: BigIntFilter<"course_reviews"> | bigint | number
    course_id?: BigIntNullableFilter<"course_reviews"> | bigint | number | null
    user_id?: BigIntNullableFilter<"course_reviews"> | bigint | number | null
    rating?: IntNullableFilter<"course_reviews"> | number | null
    review?: StringNullableFilter<"course_reviews"> | string | null
    created_at?: DateTimeNullableFilter<"course_reviews"> | Date | string | null
    courses?: XOR<CoursesNullableScalarRelationFilter, coursesWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type course_reviewsOrderByWithRelationInput = {
    id?: SortOrder
    course_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    review?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    courses?: coursesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type course_reviewsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: course_reviewsWhereInput | course_reviewsWhereInput[]
    OR?: course_reviewsWhereInput[]
    NOT?: course_reviewsWhereInput | course_reviewsWhereInput[]
    course_id?: BigIntNullableFilter<"course_reviews"> | bigint | number | null
    user_id?: BigIntNullableFilter<"course_reviews"> | bigint | number | null
    rating?: IntNullableFilter<"course_reviews"> | number | null
    review?: StringNullableFilter<"course_reviews"> | string | null
    created_at?: DateTimeNullableFilter<"course_reviews"> | Date | string | null
    courses?: XOR<CoursesNullableScalarRelationFilter, coursesWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type course_reviewsOrderByWithAggregationInput = {
    id?: SortOrder
    course_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    review?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: course_reviewsCountOrderByAggregateInput
    _avg?: course_reviewsAvgOrderByAggregateInput
    _max?: course_reviewsMaxOrderByAggregateInput
    _min?: course_reviewsMinOrderByAggregateInput
    _sum?: course_reviewsSumOrderByAggregateInput
  }

  export type course_reviewsScalarWhereWithAggregatesInput = {
    AND?: course_reviewsScalarWhereWithAggregatesInput | course_reviewsScalarWhereWithAggregatesInput[]
    OR?: course_reviewsScalarWhereWithAggregatesInput[]
    NOT?: course_reviewsScalarWhereWithAggregatesInput | course_reviewsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"course_reviews"> | bigint | number
    course_id?: BigIntNullableWithAggregatesFilter<"course_reviews"> | bigint | number | null
    user_id?: BigIntNullableWithAggregatesFilter<"course_reviews"> | bigint | number | null
    rating?: IntNullableWithAggregatesFilter<"course_reviews"> | number | null
    review?: StringNullableWithAggregatesFilter<"course_reviews"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"course_reviews"> | Date | string | null
  }

  export type course_videosWhereInput = {
    AND?: course_videosWhereInput | course_videosWhereInput[]
    OR?: course_videosWhereInput[]
    NOT?: course_videosWhereInput | course_videosWhereInput[]
    id?: BigIntFilter<"course_videos"> | bigint | number
    course_id?: BigIntNullableFilter<"course_videos"> | bigint | number | null
    title?: StringFilter<"course_videos"> | string
    video_url?: StringFilter<"course_videos"> | string
    position?: IntFilter<"course_videos"> | number
    is_demo?: BoolNullableFilter<"course_videos"> | boolean | null
    created_at?: DateTimeNullableFilter<"course_videos"> | Date | string | null
    courses?: XOR<CoursesNullableScalarRelationFilter, coursesWhereInput> | null
  }

  export type course_videosOrderByWithRelationInput = {
    id?: SortOrder
    course_id?: SortOrderInput | SortOrder
    title?: SortOrder
    video_url?: SortOrder
    position?: SortOrder
    is_demo?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    courses?: coursesOrderByWithRelationInput
  }

  export type course_videosWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: course_videosWhereInput | course_videosWhereInput[]
    OR?: course_videosWhereInput[]
    NOT?: course_videosWhereInput | course_videosWhereInput[]
    course_id?: BigIntNullableFilter<"course_videos"> | bigint | number | null
    title?: StringFilter<"course_videos"> | string
    video_url?: StringFilter<"course_videos"> | string
    position?: IntFilter<"course_videos"> | number
    is_demo?: BoolNullableFilter<"course_videos"> | boolean | null
    created_at?: DateTimeNullableFilter<"course_videos"> | Date | string | null
    courses?: XOR<CoursesNullableScalarRelationFilter, coursesWhereInput> | null
  }, "id">

  export type course_videosOrderByWithAggregationInput = {
    id?: SortOrder
    course_id?: SortOrderInput | SortOrder
    title?: SortOrder
    video_url?: SortOrder
    position?: SortOrder
    is_demo?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: course_videosCountOrderByAggregateInput
    _avg?: course_videosAvgOrderByAggregateInput
    _max?: course_videosMaxOrderByAggregateInput
    _min?: course_videosMinOrderByAggregateInput
    _sum?: course_videosSumOrderByAggregateInput
  }

  export type course_videosScalarWhereWithAggregatesInput = {
    AND?: course_videosScalarWhereWithAggregatesInput | course_videosScalarWhereWithAggregatesInput[]
    OR?: course_videosScalarWhereWithAggregatesInput[]
    NOT?: course_videosScalarWhereWithAggregatesInput | course_videosScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"course_videos"> | bigint | number
    course_id?: BigIntNullableWithAggregatesFilter<"course_videos"> | bigint | number | null
    title?: StringWithAggregatesFilter<"course_videos"> | string
    video_url?: StringWithAggregatesFilter<"course_videos"> | string
    position?: IntWithAggregatesFilter<"course_videos"> | number
    is_demo?: BoolNullableWithAggregatesFilter<"course_videos"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"course_videos"> | Date | string | null
  }

  export type coursesWhereInput = {
    AND?: coursesWhereInput | coursesWhereInput[]
    OR?: coursesWhereInput[]
    NOT?: coursesWhereInput | coursesWhereInput[]
    id?: BigIntFilter<"courses"> | bigint | number
    title?: StringFilter<"courses"> | string
    description?: StringNullableFilter<"courses"> | string | null
    thumbnail_url?: StringNullableFilter<"courses"> | string | null
    created_at?: DateTimeNullableFilter<"courses"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"courses"> | Date | string | null
    course_plans?: Course_plansListRelationFilter
    course_reviews?: Course_reviewsListRelationFilter
    course_videos?: Course_videosListRelationFilter
    enrollments?: EnrollmentsListRelationFilter
    payments?: PaymentsListRelationFilter
  }

  export type coursesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    thumbnail_url?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    course_plans?: course_plansOrderByRelationAggregateInput
    course_reviews?: course_reviewsOrderByRelationAggregateInput
    course_videos?: course_videosOrderByRelationAggregateInput
    enrollments?: enrollmentsOrderByRelationAggregateInput
    payments?: paymentsOrderByRelationAggregateInput
  }

  export type coursesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: coursesWhereInput | coursesWhereInput[]
    OR?: coursesWhereInput[]
    NOT?: coursesWhereInput | coursesWhereInput[]
    title?: StringFilter<"courses"> | string
    description?: StringNullableFilter<"courses"> | string | null
    thumbnail_url?: StringNullableFilter<"courses"> | string | null
    created_at?: DateTimeNullableFilter<"courses"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"courses"> | Date | string | null
    course_plans?: Course_plansListRelationFilter
    course_reviews?: Course_reviewsListRelationFilter
    course_videos?: Course_videosListRelationFilter
    enrollments?: EnrollmentsListRelationFilter
    payments?: PaymentsListRelationFilter
  }, "id">

  export type coursesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    thumbnail_url?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: coursesCountOrderByAggregateInput
    _avg?: coursesAvgOrderByAggregateInput
    _max?: coursesMaxOrderByAggregateInput
    _min?: coursesMinOrderByAggregateInput
    _sum?: coursesSumOrderByAggregateInput
  }

  export type coursesScalarWhereWithAggregatesInput = {
    AND?: coursesScalarWhereWithAggregatesInput | coursesScalarWhereWithAggregatesInput[]
    OR?: coursesScalarWhereWithAggregatesInput[]
    NOT?: coursesScalarWhereWithAggregatesInput | coursesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"courses"> | bigint | number
    title?: StringWithAggregatesFilter<"courses"> | string
    description?: StringNullableWithAggregatesFilter<"courses"> | string | null
    thumbnail_url?: StringNullableWithAggregatesFilter<"courses"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"courses"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"courses"> | Date | string | null
  }

  export type enrollmentsWhereInput = {
    AND?: enrollmentsWhereInput | enrollmentsWhereInput[]
    OR?: enrollmentsWhereInput[]
    NOT?: enrollmentsWhereInput | enrollmentsWhereInput[]
    id?: BigIntFilter<"enrollments"> | bigint | number
    user_id?: BigIntNullableFilter<"enrollments"> | bigint | number | null
    course_id?: BigIntNullableFilter<"enrollments"> | bigint | number | null
    plan_id?: BigIntNullableFilter<"enrollments"> | bigint | number | null
    status?: Enumenrollment_statusNullableFilter<"enrollments"> | $Enums.enrollment_status | null
    started_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    courses?: XOR<CoursesNullableScalarRelationFilter, coursesWhereInput> | null
    course_plans?: XOR<Course_plansNullableScalarRelationFilter, course_plansWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type enrollmentsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    course_id?: SortOrderInput | SortOrder
    plan_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    courses?: coursesOrderByWithRelationInput
    course_plans?: course_plansOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type enrollmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: enrollmentsWhereInput | enrollmentsWhereInput[]
    OR?: enrollmentsWhereInput[]
    NOT?: enrollmentsWhereInput | enrollmentsWhereInput[]
    user_id?: BigIntNullableFilter<"enrollments"> | bigint | number | null
    course_id?: BigIntNullableFilter<"enrollments"> | bigint | number | null
    plan_id?: BigIntNullableFilter<"enrollments"> | bigint | number | null
    status?: Enumenrollment_statusNullableFilter<"enrollments"> | $Enums.enrollment_status | null
    started_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    courses?: XOR<CoursesNullableScalarRelationFilter, coursesWhereInput> | null
    course_plans?: XOR<Course_plansNullableScalarRelationFilter, course_plansWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type enrollmentsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    course_id?: SortOrderInput | SortOrder
    plan_id?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    _count?: enrollmentsCountOrderByAggregateInput
    _avg?: enrollmentsAvgOrderByAggregateInput
    _max?: enrollmentsMaxOrderByAggregateInput
    _min?: enrollmentsMinOrderByAggregateInput
    _sum?: enrollmentsSumOrderByAggregateInput
  }

  export type enrollmentsScalarWhereWithAggregatesInput = {
    AND?: enrollmentsScalarWhereWithAggregatesInput | enrollmentsScalarWhereWithAggregatesInput[]
    OR?: enrollmentsScalarWhereWithAggregatesInput[]
    NOT?: enrollmentsScalarWhereWithAggregatesInput | enrollmentsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"enrollments"> | bigint | number
    user_id?: BigIntNullableWithAggregatesFilter<"enrollments"> | bigint | number | null
    course_id?: BigIntNullableWithAggregatesFilter<"enrollments"> | bigint | number | null
    plan_id?: BigIntNullableWithAggregatesFilter<"enrollments"> | bigint | number | null
    status?: Enumenrollment_statusNullableWithAggregatesFilter<"enrollments"> | $Enums.enrollment_status | null
    started_at?: DateTimeNullableWithAggregatesFilter<"enrollments"> | Date | string | null
    expires_at?: DateTimeNullableWithAggregatesFilter<"enrollments"> | Date | string | null
  }

  export type google_adsWhereInput = {
    AND?: google_adsWhereInput | google_adsWhereInput[]
    OR?: google_adsWhereInput[]
    NOT?: google_adsWhereInput | google_adsWhereInput[]
    id?: BigIntFilter<"google_ads"> | bigint | number
    placement?: StringFilter<"google_ads"> | string
    ad_code?: StringFilter<"google_ads"> | string
    created_at?: DateTimeNullableFilter<"google_ads"> | Date | string | null
  }

  export type google_adsOrderByWithRelationInput = {
    id?: SortOrder
    placement?: SortOrder
    ad_code?: SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type google_adsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: google_adsWhereInput | google_adsWhereInput[]
    OR?: google_adsWhereInput[]
    NOT?: google_adsWhereInput | google_adsWhereInput[]
    placement?: StringFilter<"google_ads"> | string
    ad_code?: StringFilter<"google_ads"> | string
    created_at?: DateTimeNullableFilter<"google_ads"> | Date | string | null
  }, "id">

  export type google_adsOrderByWithAggregationInput = {
    id?: SortOrder
    placement?: SortOrder
    ad_code?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: google_adsCountOrderByAggregateInput
    _avg?: google_adsAvgOrderByAggregateInput
    _max?: google_adsMaxOrderByAggregateInput
    _min?: google_adsMinOrderByAggregateInput
    _sum?: google_adsSumOrderByAggregateInput
  }

  export type google_adsScalarWhereWithAggregatesInput = {
    AND?: google_adsScalarWhereWithAggregatesInput | google_adsScalarWhereWithAggregatesInput[]
    OR?: google_adsScalarWhereWithAggregatesInput[]
    NOT?: google_adsScalarWhereWithAggregatesInput | google_adsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"google_ads"> | bigint | number
    placement?: StringWithAggregatesFilter<"google_ads"> | string
    ad_code?: StringWithAggregatesFilter<"google_ads"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"google_ads"> | Date | string | null
  }

  export type mock_attemptsWhereInput = {
    AND?: mock_attemptsWhereInput | mock_attemptsWhereInput[]
    OR?: mock_attemptsWhereInput[]
    NOT?: mock_attemptsWhereInput | mock_attemptsWhereInput[]
    id?: BigIntFilter<"mock_attempts"> | bigint | number
    test_id?: BigIntNullableFilter<"mock_attempts"> | bigint | number | null
    user_id?: BigIntNullableFilter<"mock_attempts"> | bigint | number | null
    answers?: JsonFilter<"mock_attempts">
    score?: IntNullableFilter<"mock_attempts"> | number | null
    started_at?: DateTimeNullableFilter<"mock_attempts"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"mock_attempts"> | Date | string | null
    mock_tests?: XOR<Mock_testsNullableScalarRelationFilter, mock_testsWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type mock_attemptsOrderByWithRelationInput = {
    id?: SortOrder
    test_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    answers?: SortOrder
    score?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    mock_tests?: mock_testsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type mock_attemptsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: mock_attemptsWhereInput | mock_attemptsWhereInput[]
    OR?: mock_attemptsWhereInput[]
    NOT?: mock_attemptsWhereInput | mock_attemptsWhereInput[]
    test_id?: BigIntNullableFilter<"mock_attempts"> | bigint | number | null
    user_id?: BigIntNullableFilter<"mock_attempts"> | bigint | number | null
    answers?: JsonFilter<"mock_attempts">
    score?: IntNullableFilter<"mock_attempts"> | number | null
    started_at?: DateTimeNullableFilter<"mock_attempts"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"mock_attempts"> | Date | string | null
    mock_tests?: XOR<Mock_testsNullableScalarRelationFilter, mock_testsWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type mock_attemptsOrderByWithAggregationInput = {
    id?: SortOrder
    test_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    answers?: SortOrder
    score?: SortOrderInput | SortOrder
    started_at?: SortOrderInput | SortOrder
    completed_at?: SortOrderInput | SortOrder
    _count?: mock_attemptsCountOrderByAggregateInput
    _avg?: mock_attemptsAvgOrderByAggregateInput
    _max?: mock_attemptsMaxOrderByAggregateInput
    _min?: mock_attemptsMinOrderByAggregateInput
    _sum?: mock_attemptsSumOrderByAggregateInput
  }

  export type mock_attemptsScalarWhereWithAggregatesInput = {
    AND?: mock_attemptsScalarWhereWithAggregatesInput | mock_attemptsScalarWhereWithAggregatesInput[]
    OR?: mock_attemptsScalarWhereWithAggregatesInput[]
    NOT?: mock_attemptsScalarWhereWithAggregatesInput | mock_attemptsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"mock_attempts"> | bigint | number
    test_id?: BigIntNullableWithAggregatesFilter<"mock_attempts"> | bigint | number | null
    user_id?: BigIntNullableWithAggregatesFilter<"mock_attempts"> | bigint | number | null
    answers?: JsonWithAggregatesFilter<"mock_attempts">
    score?: IntNullableWithAggregatesFilter<"mock_attempts"> | number | null
    started_at?: DateTimeNullableWithAggregatesFilter<"mock_attempts"> | Date | string | null
    completed_at?: DateTimeNullableWithAggregatesFilter<"mock_attempts"> | Date | string | null
  }

  export type mock_categoriesWhereInput = {
    AND?: mock_categoriesWhereInput | mock_categoriesWhereInput[]
    OR?: mock_categoriesWhereInput[]
    NOT?: mock_categoriesWhereInput | mock_categoriesWhereInput[]
    id?: BigIntFilter<"mock_categories"> | bigint | number
    name?: StringFilter<"mock_categories"> | string
    description?: StringNullableFilter<"mock_categories"> | string | null
    mock_series?: Mock_seriesListRelationFilter
  }

  export type mock_categoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    mock_series?: mock_seriesOrderByRelationAggregateInput
  }

  export type mock_categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    name?: string
    AND?: mock_categoriesWhereInput | mock_categoriesWhereInput[]
    OR?: mock_categoriesWhereInput[]
    NOT?: mock_categoriesWhereInput | mock_categoriesWhereInput[]
    description?: StringNullableFilter<"mock_categories"> | string | null
    mock_series?: Mock_seriesListRelationFilter
  }, "id" | "name">

  export type mock_categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: mock_categoriesCountOrderByAggregateInput
    _avg?: mock_categoriesAvgOrderByAggregateInput
    _max?: mock_categoriesMaxOrderByAggregateInput
    _min?: mock_categoriesMinOrderByAggregateInput
    _sum?: mock_categoriesSumOrderByAggregateInput
  }

  export type mock_categoriesScalarWhereWithAggregatesInput = {
    AND?: mock_categoriesScalarWhereWithAggregatesInput | mock_categoriesScalarWhereWithAggregatesInput[]
    OR?: mock_categoriesScalarWhereWithAggregatesInput[]
    NOT?: mock_categoriesScalarWhereWithAggregatesInput | mock_categoriesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"mock_categories"> | bigint | number
    name?: StringWithAggregatesFilter<"mock_categories"> | string
    description?: StringNullableWithAggregatesFilter<"mock_categories"> | string | null
  }

  export type mock_questionsWhereInput = {
    AND?: mock_questionsWhereInput | mock_questionsWhereInput[]
    OR?: mock_questionsWhereInput[]
    NOT?: mock_questionsWhereInput | mock_questionsWhereInput[]
    id?: BigIntFilter<"mock_questions"> | bigint | number
    test_id?: BigIntNullableFilter<"mock_questions"> | bigint | number | null
    question_text?: StringFilter<"mock_questions"> | string
    question_type?: Enumquestion_typeNullableFilter<"mock_questions"> | $Enums.question_type | null
    options?: JsonNullableFilter<"mock_questions">
    correct_answer?: StringFilter<"mock_questions"> | string
    marks?: IntNullableFilter<"mock_questions"> | number | null
    mock_tests?: XOR<Mock_testsNullableScalarRelationFilter, mock_testsWhereInput> | null
  }

  export type mock_questionsOrderByWithRelationInput = {
    id?: SortOrder
    test_id?: SortOrderInput | SortOrder
    question_text?: SortOrder
    question_type?: SortOrderInput | SortOrder
    options?: SortOrderInput | SortOrder
    correct_answer?: SortOrder
    marks?: SortOrderInput | SortOrder
    mock_tests?: mock_testsOrderByWithRelationInput
  }

  export type mock_questionsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: mock_questionsWhereInput | mock_questionsWhereInput[]
    OR?: mock_questionsWhereInput[]
    NOT?: mock_questionsWhereInput | mock_questionsWhereInput[]
    test_id?: BigIntNullableFilter<"mock_questions"> | bigint | number | null
    question_text?: StringFilter<"mock_questions"> | string
    question_type?: Enumquestion_typeNullableFilter<"mock_questions"> | $Enums.question_type | null
    options?: JsonNullableFilter<"mock_questions">
    correct_answer?: StringFilter<"mock_questions"> | string
    marks?: IntNullableFilter<"mock_questions"> | number | null
    mock_tests?: XOR<Mock_testsNullableScalarRelationFilter, mock_testsWhereInput> | null
  }, "id">

  export type mock_questionsOrderByWithAggregationInput = {
    id?: SortOrder
    test_id?: SortOrderInput | SortOrder
    question_text?: SortOrder
    question_type?: SortOrderInput | SortOrder
    options?: SortOrderInput | SortOrder
    correct_answer?: SortOrder
    marks?: SortOrderInput | SortOrder
    _count?: mock_questionsCountOrderByAggregateInput
    _avg?: mock_questionsAvgOrderByAggregateInput
    _max?: mock_questionsMaxOrderByAggregateInput
    _min?: mock_questionsMinOrderByAggregateInput
    _sum?: mock_questionsSumOrderByAggregateInput
  }

  export type mock_questionsScalarWhereWithAggregatesInput = {
    AND?: mock_questionsScalarWhereWithAggregatesInput | mock_questionsScalarWhereWithAggregatesInput[]
    OR?: mock_questionsScalarWhereWithAggregatesInput[]
    NOT?: mock_questionsScalarWhereWithAggregatesInput | mock_questionsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"mock_questions"> | bigint | number
    test_id?: BigIntNullableWithAggregatesFilter<"mock_questions"> | bigint | number | null
    question_text?: StringWithAggregatesFilter<"mock_questions"> | string
    question_type?: Enumquestion_typeNullableWithAggregatesFilter<"mock_questions"> | $Enums.question_type | null
    options?: JsonNullableWithAggregatesFilter<"mock_questions">
    correct_answer?: StringWithAggregatesFilter<"mock_questions"> | string
    marks?: IntNullableWithAggregatesFilter<"mock_questions"> | number | null
  }

  export type mock_seriesWhereInput = {
    AND?: mock_seriesWhereInput | mock_seriesWhereInput[]
    OR?: mock_seriesWhereInput[]
    NOT?: mock_seriesWhereInput | mock_seriesWhereInput[]
    id?: BigIntFilter<"mock_series"> | bigint | number
    category_id?: BigIntNullableFilter<"mock_series"> | bigint | number | null
    title?: StringFilter<"mock_series"> | string
    description?: StringNullableFilter<"mock_series"> | string | null
    created_at?: DateTimeNullableFilter<"mock_series"> | Date | string | null
    price?: DecimalNullableFilter<"mock_series"> | Decimal | DecimalJsLike | number | string | null
    mock_categories?: XOR<Mock_categoriesNullableScalarRelationFilter, mock_categoriesWhereInput> | null
    mock_tests?: Mock_testsListRelationFilter
    payments?: PaymentsListRelationFilter
  }

  export type mock_seriesOrderByWithRelationInput = {
    id?: SortOrder
    category_id?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    mock_categories?: mock_categoriesOrderByWithRelationInput
    mock_tests?: mock_testsOrderByRelationAggregateInput
    payments?: paymentsOrderByRelationAggregateInput
  }

  export type mock_seriesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: mock_seriesWhereInput | mock_seriesWhereInput[]
    OR?: mock_seriesWhereInput[]
    NOT?: mock_seriesWhereInput | mock_seriesWhereInput[]
    category_id?: BigIntNullableFilter<"mock_series"> | bigint | number | null
    title?: StringFilter<"mock_series"> | string
    description?: StringNullableFilter<"mock_series"> | string | null
    created_at?: DateTimeNullableFilter<"mock_series"> | Date | string | null
    price?: DecimalNullableFilter<"mock_series"> | Decimal | DecimalJsLike | number | string | null
    mock_categories?: XOR<Mock_categoriesNullableScalarRelationFilter, mock_categoriesWhereInput> | null
    mock_tests?: Mock_testsListRelationFilter
    payments?: PaymentsListRelationFilter
  }, "id">

  export type mock_seriesOrderByWithAggregationInput = {
    id?: SortOrder
    category_id?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    _count?: mock_seriesCountOrderByAggregateInput
    _avg?: mock_seriesAvgOrderByAggregateInput
    _max?: mock_seriesMaxOrderByAggregateInput
    _min?: mock_seriesMinOrderByAggregateInput
    _sum?: mock_seriesSumOrderByAggregateInput
  }

  export type mock_seriesScalarWhereWithAggregatesInput = {
    AND?: mock_seriesScalarWhereWithAggregatesInput | mock_seriesScalarWhereWithAggregatesInput[]
    OR?: mock_seriesScalarWhereWithAggregatesInput[]
    NOT?: mock_seriesScalarWhereWithAggregatesInput | mock_seriesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"mock_series"> | bigint | number
    category_id?: BigIntNullableWithAggregatesFilter<"mock_series"> | bigint | number | null
    title?: StringWithAggregatesFilter<"mock_series"> | string
    description?: StringNullableWithAggregatesFilter<"mock_series"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"mock_series"> | Date | string | null
    price?: DecimalNullableWithAggregatesFilter<"mock_series"> | Decimal | DecimalJsLike | number | string | null
  }

  export type mock_testsWhereInput = {
    AND?: mock_testsWhereInput | mock_testsWhereInput[]
    OR?: mock_testsWhereInput[]
    NOT?: mock_testsWhereInput | mock_testsWhereInput[]
    id?: BigIntFilter<"mock_tests"> | bigint | number
    series_id?: BigIntNullableFilter<"mock_tests"> | bigint | number | null
    title?: StringFilter<"mock_tests"> | string
    description?: StringNullableFilter<"mock_tests"> | string | null
    duration_minutes?: IntFilter<"mock_tests"> | number
    total_marks?: IntFilter<"mock_tests"> | number
    created_at?: DateTimeNullableFilter<"mock_tests"> | Date | string | null
    is_free?: BoolNullableFilter<"mock_tests"> | boolean | null
    mock_attempts?: Mock_attemptsListRelationFilter
    mock_questions?: Mock_questionsListRelationFilter
    mock_series?: XOR<Mock_seriesNullableScalarRelationFilter, mock_seriesWhereInput> | null
  }

  export type mock_testsOrderByWithRelationInput = {
    id?: SortOrder
    series_id?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    duration_minutes?: SortOrder
    total_marks?: SortOrder
    created_at?: SortOrderInput | SortOrder
    is_free?: SortOrderInput | SortOrder
    mock_attempts?: mock_attemptsOrderByRelationAggregateInput
    mock_questions?: mock_questionsOrderByRelationAggregateInput
    mock_series?: mock_seriesOrderByWithRelationInput
  }

  export type mock_testsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: mock_testsWhereInput | mock_testsWhereInput[]
    OR?: mock_testsWhereInput[]
    NOT?: mock_testsWhereInput | mock_testsWhereInput[]
    series_id?: BigIntNullableFilter<"mock_tests"> | bigint | number | null
    title?: StringFilter<"mock_tests"> | string
    description?: StringNullableFilter<"mock_tests"> | string | null
    duration_minutes?: IntFilter<"mock_tests"> | number
    total_marks?: IntFilter<"mock_tests"> | number
    created_at?: DateTimeNullableFilter<"mock_tests"> | Date | string | null
    is_free?: BoolNullableFilter<"mock_tests"> | boolean | null
    mock_attempts?: Mock_attemptsListRelationFilter
    mock_questions?: Mock_questionsListRelationFilter
    mock_series?: XOR<Mock_seriesNullableScalarRelationFilter, mock_seriesWhereInput> | null
  }, "id">

  export type mock_testsOrderByWithAggregationInput = {
    id?: SortOrder
    series_id?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    duration_minutes?: SortOrder
    total_marks?: SortOrder
    created_at?: SortOrderInput | SortOrder
    is_free?: SortOrderInput | SortOrder
    _count?: mock_testsCountOrderByAggregateInput
    _avg?: mock_testsAvgOrderByAggregateInput
    _max?: mock_testsMaxOrderByAggregateInput
    _min?: mock_testsMinOrderByAggregateInput
    _sum?: mock_testsSumOrderByAggregateInput
  }

  export type mock_testsScalarWhereWithAggregatesInput = {
    AND?: mock_testsScalarWhereWithAggregatesInput | mock_testsScalarWhereWithAggregatesInput[]
    OR?: mock_testsScalarWhereWithAggregatesInput[]
    NOT?: mock_testsScalarWhereWithAggregatesInput | mock_testsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"mock_tests"> | bigint | number
    series_id?: BigIntNullableWithAggregatesFilter<"mock_tests"> | bigint | number | null
    title?: StringWithAggregatesFilter<"mock_tests"> | string
    description?: StringNullableWithAggregatesFilter<"mock_tests"> | string | null
    duration_minutes?: IntWithAggregatesFilter<"mock_tests"> | number
    total_marks?: IntWithAggregatesFilter<"mock_tests"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"mock_tests"> | Date | string | null
    is_free?: BoolNullableWithAggregatesFilter<"mock_tests"> | boolean | null
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    id?: BigIntFilter<"payments"> | bigint | number
    user_id?: BigIntNullableFilter<"payments"> | bigint | number | null
    course_id?: BigIntNullableFilter<"payments"> | bigint | number | null
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_method?: StringFilter<"payments"> | string
    status?: Enumpayment_statusNullableFilter<"payments"> | $Enums.payment_status | null
    transaction_id?: StringNullableFilter<"payments"> | string | null
    created_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    mock_series_id?: BigIntNullableFilter<"payments"> | bigint | number | null
    courses?: XOR<CoursesNullableScalarRelationFilter, coursesWhereInput> | null
    mock_series?: XOR<Mock_seriesNullableScalarRelationFilter, mock_seriesWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type paymentsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    course_id?: SortOrderInput | SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    status?: SortOrderInput | SortOrder
    transaction_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    mock_series_id?: SortOrderInput | SortOrder
    courses?: coursesOrderByWithRelationInput
    mock_series?: mock_seriesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    user_id?: BigIntNullableFilter<"payments"> | bigint | number | null
    course_id?: BigIntNullableFilter<"payments"> | bigint | number | null
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_method?: StringFilter<"payments"> | string
    status?: Enumpayment_statusNullableFilter<"payments"> | $Enums.payment_status | null
    transaction_id?: StringNullableFilter<"payments"> | string | null
    created_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    mock_series_id?: BigIntNullableFilter<"payments"> | bigint | number | null
    courses?: XOR<CoursesNullableScalarRelationFilter, coursesWhereInput> | null
    mock_series?: XOR<Mock_seriesNullableScalarRelationFilter, mock_seriesWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type paymentsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    course_id?: SortOrderInput | SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    status?: SortOrderInput | SortOrder
    transaction_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    mock_series_id?: SortOrderInput | SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"payments"> | bigint | number
    user_id?: BigIntNullableWithAggregatesFilter<"payments"> | bigint | number | null
    course_id?: BigIntNullableWithAggregatesFilter<"payments"> | bigint | number | null
    amount?: DecimalWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_method?: StringWithAggregatesFilter<"payments"> | string
    status?: Enumpayment_statusNullableWithAggregatesFilter<"payments"> | $Enums.payment_status | null
    transaction_id?: StringNullableWithAggregatesFilter<"payments"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
    mock_series_id?: BigIntNullableWithAggregatesFilter<"payments"> | bigint | number | null
  }

  export type post_tagsWhereInput = {
    AND?: post_tagsWhereInput | post_tagsWhereInput[]
    OR?: post_tagsWhereInput[]
    NOT?: post_tagsWhereInput | post_tagsWhereInput[]
    post_id?: BigIntFilter<"post_tags"> | bigint | number
    tag_id?: BigIntFilter<"post_tags"> | bigint | number
    posts?: XOR<PostsScalarRelationFilter, postsWhereInput>
    tags?: XOR<TagsScalarRelationFilter, tagsWhereInput>
  }

  export type post_tagsOrderByWithRelationInput = {
    post_id?: SortOrder
    tag_id?: SortOrder
    posts?: postsOrderByWithRelationInput
    tags?: tagsOrderByWithRelationInput
  }

  export type post_tagsWhereUniqueInput = Prisma.AtLeast<{
    post_id_tag_id?: post_tagsPost_idTag_idCompoundUniqueInput
    AND?: post_tagsWhereInput | post_tagsWhereInput[]
    OR?: post_tagsWhereInput[]
    NOT?: post_tagsWhereInput | post_tagsWhereInput[]
    post_id?: BigIntFilter<"post_tags"> | bigint | number
    tag_id?: BigIntFilter<"post_tags"> | bigint | number
    posts?: XOR<PostsScalarRelationFilter, postsWhereInput>
    tags?: XOR<TagsScalarRelationFilter, tagsWhereInput>
  }, "post_id_tag_id">

  export type post_tagsOrderByWithAggregationInput = {
    post_id?: SortOrder
    tag_id?: SortOrder
    _count?: post_tagsCountOrderByAggregateInput
    _avg?: post_tagsAvgOrderByAggregateInput
    _max?: post_tagsMaxOrderByAggregateInput
    _min?: post_tagsMinOrderByAggregateInput
    _sum?: post_tagsSumOrderByAggregateInput
  }

  export type post_tagsScalarWhereWithAggregatesInput = {
    AND?: post_tagsScalarWhereWithAggregatesInput | post_tagsScalarWhereWithAggregatesInput[]
    OR?: post_tagsScalarWhereWithAggregatesInput[]
    NOT?: post_tagsScalarWhereWithAggregatesInput | post_tagsScalarWhereWithAggregatesInput[]
    post_id?: BigIntWithAggregatesFilter<"post_tags"> | bigint | number
    tag_id?: BigIntWithAggregatesFilter<"post_tags"> | bigint | number
  }

  export type post_templatesWhereInput = {
    AND?: post_templatesWhereInput | post_templatesWhereInput[]
    OR?: post_templatesWhereInput[]
    NOT?: post_templatesWhereInput | post_templatesWhereInput[]
    id?: BigIntFilter<"post_templates"> | bigint | number
    name?: StringFilter<"post_templates"> | string
    description?: StringNullableFilter<"post_templates"> | string | null
    structure?: JsonFilter<"post_templates">
    created_at?: DateTimeNullableFilter<"post_templates"> | Date | string | null
    posts?: PostsListRelationFilter
  }

  export type post_templatesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    structure?: SortOrder
    created_at?: SortOrderInput | SortOrder
    posts?: postsOrderByRelationAggregateInput
  }

  export type post_templatesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    name?: string
    AND?: post_templatesWhereInput | post_templatesWhereInput[]
    OR?: post_templatesWhereInput[]
    NOT?: post_templatesWhereInput | post_templatesWhereInput[]
    description?: StringNullableFilter<"post_templates"> | string | null
    structure?: JsonFilter<"post_templates">
    created_at?: DateTimeNullableFilter<"post_templates"> | Date | string | null
    posts?: PostsListRelationFilter
  }, "id" | "name">

  export type post_templatesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    structure?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: post_templatesCountOrderByAggregateInput
    _avg?: post_templatesAvgOrderByAggregateInput
    _max?: post_templatesMaxOrderByAggregateInput
    _min?: post_templatesMinOrderByAggregateInput
    _sum?: post_templatesSumOrderByAggregateInput
  }

  export type post_templatesScalarWhereWithAggregatesInput = {
    AND?: post_templatesScalarWhereWithAggregatesInput | post_templatesScalarWhereWithAggregatesInput[]
    OR?: post_templatesScalarWhereWithAggregatesInput[]
    NOT?: post_templatesScalarWhereWithAggregatesInput | post_templatesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"post_templates"> | bigint | number
    name?: StringWithAggregatesFilter<"post_templates"> | string
    description?: StringNullableWithAggregatesFilter<"post_templates"> | string | null
    structure?: JsonWithAggregatesFilter<"post_templates">
    created_at?: DateTimeNullableWithAggregatesFilter<"post_templates"> | Date | string | null
  }

  export type postsWhereInput = {
    AND?: postsWhereInput | postsWhereInput[]
    OR?: postsWhereInput[]
    NOT?: postsWhereInput | postsWhereInput[]
    id?: BigIntFilter<"posts"> | bigint | number
    category_id?: BigIntNullableFilter<"posts"> | bigint | number | null
    title?: StringFilter<"posts"> | string
    slug?: StringFilter<"posts"> | string
    content?: StringFilter<"posts"> | string
    external_url?: StringNullableFilter<"posts"> | string | null
    thumbnail_url?: StringNullableFilter<"posts"> | string | null
    published_at?: DateTimeNullableFilter<"posts"> | Date | string | null
    created_by?: BigIntNullableFilter<"posts"> | bigint | number | null
    created_at?: DateTimeNullableFilter<"posts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"posts"> | Date | string | null
    template_id?: BigIntNullableFilter<"posts"> | bigint | number | null
    content_json?: JsonNullableFilter<"posts">
    content_html?: StringNullableFilter<"posts"> | string | null
    comments?: CommentsListRelationFilter
    post_tags?: Post_tagsListRelationFilter
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    post_templates?: XOR<Post_templatesNullableScalarRelationFilter, post_templatesWhereInput> | null
  }

  export type postsOrderByWithRelationInput = {
    id?: SortOrder
    category_id?: SortOrderInput | SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    external_url?: SortOrderInput | SortOrder
    thumbnail_url?: SortOrderInput | SortOrder
    published_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    template_id?: SortOrderInput | SortOrder
    content_json?: SortOrderInput | SortOrder
    content_html?: SortOrderInput | SortOrder
    comments?: commentsOrderByRelationAggregateInput
    post_tags?: post_tagsOrderByRelationAggregateInput
    categories?: categoriesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    post_templates?: post_templatesOrderByWithRelationInput
  }

  export type postsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    slug?: string
    AND?: postsWhereInput | postsWhereInput[]
    OR?: postsWhereInput[]
    NOT?: postsWhereInput | postsWhereInput[]
    category_id?: BigIntNullableFilter<"posts"> | bigint | number | null
    title?: StringFilter<"posts"> | string
    content?: StringFilter<"posts"> | string
    external_url?: StringNullableFilter<"posts"> | string | null
    thumbnail_url?: StringNullableFilter<"posts"> | string | null
    published_at?: DateTimeNullableFilter<"posts"> | Date | string | null
    created_by?: BigIntNullableFilter<"posts"> | bigint | number | null
    created_at?: DateTimeNullableFilter<"posts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"posts"> | Date | string | null
    template_id?: BigIntNullableFilter<"posts"> | bigint | number | null
    content_json?: JsonNullableFilter<"posts">
    content_html?: StringNullableFilter<"posts"> | string | null
    comments?: CommentsListRelationFilter
    post_tags?: Post_tagsListRelationFilter
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    post_templates?: XOR<Post_templatesNullableScalarRelationFilter, post_templatesWhereInput> | null
  }, "id" | "slug">

  export type postsOrderByWithAggregationInput = {
    id?: SortOrder
    category_id?: SortOrderInput | SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    external_url?: SortOrderInput | SortOrder
    thumbnail_url?: SortOrderInput | SortOrder
    published_at?: SortOrderInput | SortOrder
    created_by?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    template_id?: SortOrderInput | SortOrder
    content_json?: SortOrderInput | SortOrder
    content_html?: SortOrderInput | SortOrder
    _count?: postsCountOrderByAggregateInput
    _avg?: postsAvgOrderByAggregateInput
    _max?: postsMaxOrderByAggregateInput
    _min?: postsMinOrderByAggregateInput
    _sum?: postsSumOrderByAggregateInput
  }

  export type postsScalarWhereWithAggregatesInput = {
    AND?: postsScalarWhereWithAggregatesInput | postsScalarWhereWithAggregatesInput[]
    OR?: postsScalarWhereWithAggregatesInput[]
    NOT?: postsScalarWhereWithAggregatesInput | postsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"posts"> | bigint | number
    category_id?: BigIntNullableWithAggregatesFilter<"posts"> | bigint | number | null
    title?: StringWithAggregatesFilter<"posts"> | string
    slug?: StringWithAggregatesFilter<"posts"> | string
    content?: StringWithAggregatesFilter<"posts"> | string
    external_url?: StringNullableWithAggregatesFilter<"posts"> | string | null
    thumbnail_url?: StringNullableWithAggregatesFilter<"posts"> | string | null
    published_at?: DateTimeNullableWithAggregatesFilter<"posts"> | Date | string | null
    created_by?: BigIntNullableWithAggregatesFilter<"posts"> | bigint | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"posts"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"posts"> | Date | string | null
    template_id?: BigIntNullableWithAggregatesFilter<"posts"> | bigint | number | null
    content_json?: JsonNullableWithAggregatesFilter<"posts">
    content_html?: StringNullableWithAggregatesFilter<"posts"> | string | null
  }

  export type study_materialsWhereInput = {
    AND?: study_materialsWhereInput | study_materialsWhereInput[]
    OR?: study_materialsWhereInput[]
    NOT?: study_materialsWhereInput | study_materialsWhereInput[]
    id?: BigIntFilter<"study_materials"> | bigint | number
    title?: StringFilter<"study_materials"> | string
    description?: StringNullableFilter<"study_materials"> | string | null
    file_url?: StringFilter<"study_materials"> | string
    created_at?: DateTimeNullableFilter<"study_materials"> | Date | string | null
  }

  export type study_materialsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    file_url?: SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type study_materialsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: study_materialsWhereInput | study_materialsWhereInput[]
    OR?: study_materialsWhereInput[]
    NOT?: study_materialsWhereInput | study_materialsWhereInput[]
    title?: StringFilter<"study_materials"> | string
    description?: StringNullableFilter<"study_materials"> | string | null
    file_url?: StringFilter<"study_materials"> | string
    created_at?: DateTimeNullableFilter<"study_materials"> | Date | string | null
  }, "id">

  export type study_materialsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    file_url?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: study_materialsCountOrderByAggregateInput
    _avg?: study_materialsAvgOrderByAggregateInput
    _max?: study_materialsMaxOrderByAggregateInput
    _min?: study_materialsMinOrderByAggregateInput
    _sum?: study_materialsSumOrderByAggregateInput
  }

  export type study_materialsScalarWhereWithAggregatesInput = {
    AND?: study_materialsScalarWhereWithAggregatesInput | study_materialsScalarWhereWithAggregatesInput[]
    OR?: study_materialsScalarWhereWithAggregatesInput[]
    NOT?: study_materialsScalarWhereWithAggregatesInput | study_materialsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"study_materials"> | bigint | number
    title?: StringWithAggregatesFilter<"study_materials"> | string
    description?: StringNullableWithAggregatesFilter<"study_materials"> | string | null
    file_url?: StringWithAggregatesFilter<"study_materials"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"study_materials"> | Date | string | null
  }

  export type tagsWhereInput = {
    AND?: tagsWhereInput | tagsWhereInput[]
    OR?: tagsWhereInput[]
    NOT?: tagsWhereInput | tagsWhereInput[]
    id?: BigIntFilter<"tags"> | bigint | number
    name?: StringFilter<"tags"> | string
    post_tags?: Post_tagsListRelationFilter
  }

  export type tagsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    post_tags?: post_tagsOrderByRelationAggregateInput
  }

  export type tagsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    name?: string
    AND?: tagsWhereInput | tagsWhereInput[]
    OR?: tagsWhereInput[]
    NOT?: tagsWhereInput | tagsWhereInput[]
    post_tags?: Post_tagsListRelationFilter
  }, "id" | "name">

  export type tagsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: tagsCountOrderByAggregateInput
    _avg?: tagsAvgOrderByAggregateInput
    _max?: tagsMaxOrderByAggregateInput
    _min?: tagsMinOrderByAggregateInput
    _sum?: tagsSumOrderByAggregateInput
  }

  export type tagsScalarWhereWithAggregatesInput = {
    AND?: tagsScalarWhereWithAggregatesInput | tagsScalarWhereWithAggregatesInput[]
    OR?: tagsScalarWhereWithAggregatesInput[]
    NOT?: tagsScalarWhereWithAggregatesInput | tagsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"tags"> | bigint | number
    name?: StringWithAggregatesFilter<"tags"> | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: BigIntFilter<"users"> | bigint | number
    full_name?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password_hash?: StringFilter<"users"> | string
    role?: Enumuser_roleNullableFilter<"users"> | $Enums.user_role | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    comments?: CommentsListRelationFilter
    course_reviews?: Course_reviewsListRelationFilter
    enrollments?: EnrollmentsListRelationFilter
    mock_attempts?: Mock_attemptsListRelationFilter
    payments?: PaymentsListRelationFilter
    posts?: PostsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    comments?: commentsOrderByRelationAggregateInput
    course_reviews?: course_reviewsOrderByRelationAggregateInput
    enrollments?: enrollmentsOrderByRelationAggregateInput
    mock_attempts?: mock_attemptsOrderByRelationAggregateInput
    payments?: paymentsOrderByRelationAggregateInput
    posts?: postsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    full_name?: StringFilter<"users"> | string
    password_hash?: StringFilter<"users"> | string
    role?: Enumuser_roleNullableFilter<"users"> | $Enums.user_role | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    comments?: CommentsListRelationFilter
    course_reviews?: Course_reviewsListRelationFilter
    enrollments?: EnrollmentsListRelationFilter
    mock_attempts?: Mock_attemptsListRelationFilter
    payments?: PaymentsListRelationFilter
    posts?: PostsListRelationFilter
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"users"> | bigint | number
    full_name?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    password_hash?: StringWithAggregatesFilter<"users"> | string
    role?: Enumuser_roleNullableWithAggregatesFilter<"users"> | $Enums.user_role | null
    created_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type answer_keysCreateInput = {
    id?: bigint | number
    title: string
    year?: number | null
    file_url: string
    created_at?: Date | string | null
  }

  export type answer_keysUncheckedCreateInput = {
    id?: bigint | number
    title: string
    year?: number | null
    file_url: string
    created_at?: Date | string | null
  }

  export type answer_keysUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    file_url?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type answer_keysUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    file_url?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type answer_keysCreateManyInput = {
    id?: bigint | number
    title: string
    year?: number | null
    file_url: string
    created_at?: Date | string | null
  }

  export type answer_keysUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    file_url?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type answer_keysUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    year?: NullableIntFieldUpdateOperationsInput | number | null
    file_url?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type categoriesCreateInput = {
    id?: bigint | number
    name: string
    description?: string | null
    created_at?: Date | string | null
    posts?: postsCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateInput = {
    id?: bigint | number
    name: string
    description?: string | null
    created_at?: Date | string | null
    posts?: postsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posts?: postsUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posts?: postsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesCreateManyInput = {
    id?: bigint | number
    name: string
    description?: string | null
    created_at?: Date | string | null
  }

  export type categoriesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type categoriesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type commentsCreateInput = {
    id?: bigint | number
    content: string
    created_at?: Date | string | null
    posts?: postsCreateNestedOneWithoutCommentsInput
    users?: usersCreateNestedOneWithoutCommentsInput
  }

  export type commentsUncheckedCreateInput = {
    id?: bigint | number
    post_id?: bigint | number | null
    user_id?: bigint | number | null
    content: string
    created_at?: Date | string | null
  }

  export type commentsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posts?: postsUpdateOneWithoutCommentsNestedInput
    users?: usersUpdateOneWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type commentsCreateManyInput = {
    id?: bigint | number
    post_id?: bigint | number | null
    user_id?: bigint | number | null
    content: string
    created_at?: Date | string | null
  }

  export type commentsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type commentsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type course_plansCreateInput = {
    id?: bigint | number
    plan_type: $Enums.plan_type
    plan_name: string
    price?: Decimal | DecimalJsLike | number | string | null
    duration_days?: number | null
    created_at?: Date | string | null
    courses?: coursesCreateNestedOneWithoutCourse_plansInput
    enrollments?: enrollmentsCreateNestedManyWithoutCourse_plansInput
  }

  export type course_plansUncheckedCreateInput = {
    id?: bigint | number
    course_id?: bigint | number | null
    plan_type: $Enums.plan_type
    plan_name: string
    price?: Decimal | DecimalJsLike | number | string | null
    duration_days?: number | null
    created_at?: Date | string | null
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutCourse_plansInput
  }

  export type course_plansUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plan_type?: Enumplan_typeFieldUpdateOperationsInput | $Enums.plan_type
    plan_name?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration_days?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: coursesUpdateOneWithoutCourse_plansNestedInput
    enrollments?: enrollmentsUpdateManyWithoutCourse_plansNestedInput
  }

  export type course_plansUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    plan_type?: Enumplan_typeFieldUpdateOperationsInput | $Enums.plan_type
    plan_name?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration_days?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollments?: enrollmentsUncheckedUpdateManyWithoutCourse_plansNestedInput
  }

  export type course_plansCreateManyInput = {
    id?: bigint | number
    course_id?: bigint | number | null
    plan_type: $Enums.plan_type
    plan_name: string
    price?: Decimal | DecimalJsLike | number | string | null
    duration_days?: number | null
    created_at?: Date | string | null
  }

  export type course_plansUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plan_type?: Enumplan_typeFieldUpdateOperationsInput | $Enums.plan_type
    plan_name?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration_days?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type course_plansUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    plan_type?: Enumplan_typeFieldUpdateOperationsInput | $Enums.plan_type
    plan_name?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration_days?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type course_reviewsCreateInput = {
    id?: bigint | number
    rating?: number | null
    review?: string | null
    created_at?: Date | string | null
    courses?: coursesCreateNestedOneWithoutCourse_reviewsInput
    users?: usersCreateNestedOneWithoutCourse_reviewsInput
  }

  export type course_reviewsUncheckedCreateInput = {
    id?: bigint | number
    course_id?: bigint | number | null
    user_id?: bigint | number | null
    rating?: number | null
    review?: string | null
    created_at?: Date | string | null
  }

  export type course_reviewsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: coursesUpdateOneWithoutCourse_reviewsNestedInput
    users?: usersUpdateOneWithoutCourse_reviewsNestedInput
  }

  export type course_reviewsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type course_reviewsCreateManyInput = {
    id?: bigint | number
    course_id?: bigint | number | null
    user_id?: bigint | number | null
    rating?: number | null
    review?: string | null
    created_at?: Date | string | null
  }

  export type course_reviewsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type course_reviewsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type course_videosCreateInput = {
    id?: bigint | number
    title: string
    video_url: string
    position: number
    is_demo?: boolean | null
    created_at?: Date | string | null
    courses?: coursesCreateNestedOneWithoutCourse_videosInput
  }

  export type course_videosUncheckedCreateInput = {
    id?: bigint | number
    course_id?: bigint | number | null
    title: string
    video_url: string
    position: number
    is_demo?: boolean | null
    created_at?: Date | string | null
  }

  export type course_videosUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    video_url?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: coursesUpdateOneWithoutCourse_videosNestedInput
  }

  export type course_videosUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    video_url?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type course_videosCreateManyInput = {
    id?: bigint | number
    course_id?: bigint | number | null
    title: string
    video_url: string
    position: number
    is_demo?: boolean | null
    created_at?: Date | string | null
  }

  export type course_videosUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    video_url?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type course_videosUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    video_url?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type coursesCreateInput = {
    id?: bigint | number
    title: string
    description?: string | null
    thumbnail_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    course_plans?: course_plansCreateNestedManyWithoutCoursesInput
    course_reviews?: course_reviewsCreateNestedManyWithoutCoursesInput
    course_videos?: course_videosCreateNestedManyWithoutCoursesInput
    enrollments?: enrollmentsCreateNestedManyWithoutCoursesInput
    payments?: paymentsCreateNestedManyWithoutCoursesInput
  }

  export type coursesUncheckedCreateInput = {
    id?: bigint | number
    title: string
    description?: string | null
    thumbnail_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    course_plans?: course_plansUncheckedCreateNestedManyWithoutCoursesInput
    course_reviews?: course_reviewsUncheckedCreateNestedManyWithoutCoursesInput
    course_videos?: course_videosUncheckedCreateNestedManyWithoutCoursesInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutCoursesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type coursesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_plans?: course_plansUpdateManyWithoutCoursesNestedInput
    course_reviews?: course_reviewsUpdateManyWithoutCoursesNestedInput
    course_videos?: course_videosUpdateManyWithoutCoursesNestedInput
    enrollments?: enrollmentsUpdateManyWithoutCoursesNestedInput
    payments?: paymentsUpdateManyWithoutCoursesNestedInput
  }

  export type coursesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_plans?: course_plansUncheckedUpdateManyWithoutCoursesNestedInput
    course_reviews?: course_reviewsUncheckedUpdateManyWithoutCoursesNestedInput
    course_videos?: course_videosUncheckedUpdateManyWithoutCoursesNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutCoursesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type coursesCreateManyInput = {
    id?: bigint | number
    title: string
    description?: string | null
    thumbnail_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type coursesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type coursesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsCreateInput = {
    id?: bigint | number
    status?: $Enums.enrollment_status | null
    started_at?: Date | string | null
    expires_at?: Date | string | null
    courses?: coursesCreateNestedOneWithoutEnrollmentsInput
    course_plans?: course_plansCreateNestedOneWithoutEnrollmentsInput
    users?: usersCreateNestedOneWithoutEnrollmentsInput
  }

  export type enrollmentsUncheckedCreateInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    course_id?: bigint | number | null
    plan_id?: bigint | number | null
    status?: $Enums.enrollment_status | null
    started_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type enrollmentsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: NullableEnumenrollment_statusFieldUpdateOperationsInput | $Enums.enrollment_status | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: coursesUpdateOneWithoutEnrollmentsNestedInput
    course_plans?: course_plansUpdateOneWithoutEnrollmentsNestedInput
    users?: usersUpdateOneWithoutEnrollmentsNestedInput
  }

  export type enrollmentsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    plan_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: NullableEnumenrollment_statusFieldUpdateOperationsInput | $Enums.enrollment_status | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsCreateManyInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    course_id?: bigint | number | null
    plan_id?: bigint | number | null
    status?: $Enums.enrollment_status | null
    started_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type enrollmentsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: NullableEnumenrollment_statusFieldUpdateOperationsInput | $Enums.enrollment_status | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    plan_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: NullableEnumenrollment_statusFieldUpdateOperationsInput | $Enums.enrollment_status | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type google_adsCreateInput = {
    id?: bigint | number
    placement: string
    ad_code: string
    created_at?: Date | string | null
  }

  export type google_adsUncheckedCreateInput = {
    id?: bigint | number
    placement: string
    ad_code: string
    created_at?: Date | string | null
  }

  export type google_adsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    placement?: StringFieldUpdateOperationsInput | string
    ad_code?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type google_adsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    placement?: StringFieldUpdateOperationsInput | string
    ad_code?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type google_adsCreateManyInput = {
    id?: bigint | number
    placement: string
    ad_code: string
    created_at?: Date | string | null
  }

  export type google_adsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    placement?: StringFieldUpdateOperationsInput | string
    ad_code?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type google_adsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    placement?: StringFieldUpdateOperationsInput | string
    ad_code?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mock_attemptsCreateInput = {
    id?: bigint | number
    answers: JsonNullValueInput | InputJsonValue
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    mock_tests?: mock_testsCreateNestedOneWithoutMock_attemptsInput
    users?: usersCreateNestedOneWithoutMock_attemptsInput
  }

  export type mock_attemptsUncheckedCreateInput = {
    id?: bigint | number
    test_id?: bigint | number | null
    user_id?: bigint | number | null
    answers: JsonNullValueInput | InputJsonValue
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
  }

  export type mock_attemptsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    answers?: JsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mock_tests?: mock_testsUpdateOneWithoutMock_attemptsNestedInput
    users?: usersUpdateOneWithoutMock_attemptsNestedInput
  }

  export type mock_attemptsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    answers?: JsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mock_attemptsCreateManyInput = {
    id?: bigint | number
    test_id?: bigint | number | null
    user_id?: bigint | number | null
    answers: JsonNullValueInput | InputJsonValue
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
  }

  export type mock_attemptsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    answers?: JsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mock_attemptsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    answers?: JsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mock_categoriesCreateInput = {
    id?: bigint | number
    name: string
    description?: string | null
    mock_series?: mock_seriesCreateNestedManyWithoutMock_categoriesInput
  }

  export type mock_categoriesUncheckedCreateInput = {
    id?: bigint | number
    name: string
    description?: string | null
    mock_series?: mock_seriesUncheckedCreateNestedManyWithoutMock_categoriesInput
  }

  export type mock_categoriesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mock_series?: mock_seriesUpdateManyWithoutMock_categoriesNestedInput
  }

  export type mock_categoriesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    mock_series?: mock_seriesUncheckedUpdateManyWithoutMock_categoriesNestedInput
  }

  export type mock_categoriesCreateManyInput = {
    id?: bigint | number
    name: string
    description?: string | null
  }

  export type mock_categoriesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mock_categoriesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mock_questionsCreateInput = {
    id?: bigint | number
    question_text: string
    question_type?: $Enums.question_type | null
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: string
    marks?: number | null
    mock_tests?: mock_testsCreateNestedOneWithoutMock_questionsInput
  }

  export type mock_questionsUncheckedCreateInput = {
    id?: bigint | number
    test_id?: bigint | number | null
    question_text: string
    question_type?: $Enums.question_type | null
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: string
    marks?: number | null
  }

  export type mock_questionsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: NullableEnumquestion_typeFieldUpdateOperationsInput | $Enums.question_type | null
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: StringFieldUpdateOperationsInput | string
    marks?: NullableIntFieldUpdateOperationsInput | number | null
    mock_tests?: mock_testsUpdateOneWithoutMock_questionsNestedInput
  }

  export type mock_questionsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: NullableEnumquestion_typeFieldUpdateOperationsInput | $Enums.question_type | null
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: StringFieldUpdateOperationsInput | string
    marks?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mock_questionsCreateManyInput = {
    id?: bigint | number
    test_id?: bigint | number | null
    question_text: string
    question_type?: $Enums.question_type | null
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: string
    marks?: number | null
  }

  export type mock_questionsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: NullableEnumquestion_typeFieldUpdateOperationsInput | $Enums.question_type | null
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: StringFieldUpdateOperationsInput | string
    marks?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mock_questionsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: NullableEnumquestion_typeFieldUpdateOperationsInput | $Enums.question_type | null
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: StringFieldUpdateOperationsInput | string
    marks?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mock_seriesCreateInput = {
    id?: bigint | number
    title: string
    description?: string | null
    created_at?: Date | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    mock_categories?: mock_categoriesCreateNestedOneWithoutMock_seriesInput
    mock_tests?: mock_testsCreateNestedManyWithoutMock_seriesInput
    payments?: paymentsCreateNestedManyWithoutMock_seriesInput
  }

  export type mock_seriesUncheckedCreateInput = {
    id?: bigint | number
    category_id?: bigint | number | null
    title: string
    description?: string | null
    created_at?: Date | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    mock_tests?: mock_testsUncheckedCreateNestedManyWithoutMock_seriesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutMock_seriesInput
  }

  export type mock_seriesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mock_categories?: mock_categoriesUpdateOneWithoutMock_seriesNestedInput
    mock_tests?: mock_testsUpdateManyWithoutMock_seriesNestedInput
    payments?: paymentsUpdateManyWithoutMock_seriesNestedInput
  }

  export type mock_seriesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mock_tests?: mock_testsUncheckedUpdateManyWithoutMock_seriesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutMock_seriesNestedInput
  }

  export type mock_seriesCreateManyInput = {
    id?: bigint | number
    category_id?: bigint | number | null
    title: string
    description?: string | null
    created_at?: Date | string | null
    price?: Decimal | DecimalJsLike | number | string | null
  }

  export type mock_seriesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type mock_seriesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type mock_testsCreateInput = {
    id?: bigint | number
    title: string
    description?: string | null
    duration_minutes: number
    total_marks: number
    created_at?: Date | string | null
    is_free?: boolean | null
    mock_attempts?: mock_attemptsCreateNestedManyWithoutMock_testsInput
    mock_questions?: mock_questionsCreateNestedManyWithoutMock_testsInput
    mock_series?: mock_seriesCreateNestedOneWithoutMock_testsInput
  }

  export type mock_testsUncheckedCreateInput = {
    id?: bigint | number
    series_id?: bigint | number | null
    title: string
    description?: string | null
    duration_minutes: number
    total_marks: number
    created_at?: Date | string | null
    is_free?: boolean | null
    mock_attempts?: mock_attemptsUncheckedCreateNestedManyWithoutMock_testsInput
    mock_questions?: mock_questionsUncheckedCreateNestedManyWithoutMock_testsInput
  }

  export type mock_testsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration_minutes?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_free?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mock_attempts?: mock_attemptsUpdateManyWithoutMock_testsNestedInput
    mock_questions?: mock_questionsUpdateManyWithoutMock_testsNestedInput
    mock_series?: mock_seriesUpdateOneWithoutMock_testsNestedInput
  }

  export type mock_testsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    series_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration_minutes?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_free?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mock_attempts?: mock_attemptsUncheckedUpdateManyWithoutMock_testsNestedInput
    mock_questions?: mock_questionsUncheckedUpdateManyWithoutMock_testsNestedInput
  }

  export type mock_testsCreateManyInput = {
    id?: bigint | number
    series_id?: bigint | number | null
    title: string
    description?: string | null
    duration_minutes: number
    total_marks: number
    created_at?: Date | string | null
    is_free?: boolean | null
  }

  export type mock_testsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration_minutes?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_free?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type mock_testsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    series_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration_minutes?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_free?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type paymentsCreateInput = {
    id?: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    status?: $Enums.payment_status | null
    transaction_id?: string | null
    created_at?: Date | string | null
    courses?: coursesCreateNestedOneWithoutPaymentsInput
    mock_series?: mock_seriesCreateNestedOneWithoutPaymentsInput
    users?: usersCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    course_id?: bigint | number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    status?: $Enums.payment_status | null
    transaction_id?: string | null
    created_at?: Date | string | null
    mock_series_id?: bigint | number | null
  }

  export type paymentsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: coursesUpdateOneWithoutPaymentsNestedInput
    mock_series?: mock_seriesUpdateOneWithoutPaymentsNestedInput
    users?: usersUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mock_series_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type paymentsCreateManyInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    course_id?: bigint | number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    status?: $Enums.payment_status | null
    transaction_id?: string | null
    created_at?: Date | string | null
    mock_series_id?: bigint | number | null
  }

  export type paymentsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mock_series_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type post_tagsCreateInput = {
    posts: postsCreateNestedOneWithoutPost_tagsInput
    tags: tagsCreateNestedOneWithoutPost_tagsInput
  }

  export type post_tagsUncheckedCreateInput = {
    post_id: bigint | number
    tag_id: bigint | number
  }

  export type post_tagsUpdateInput = {
    posts?: postsUpdateOneRequiredWithoutPost_tagsNestedInput
    tags?: tagsUpdateOneRequiredWithoutPost_tagsNestedInput
  }

  export type post_tagsUncheckedUpdateInput = {
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tag_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type post_tagsCreateManyInput = {
    post_id: bigint | number
    tag_id: bigint | number
  }

  export type post_tagsUpdateManyMutationInput = {

  }

  export type post_tagsUncheckedUpdateManyInput = {
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
    tag_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type post_templatesCreateInput = {
    id?: bigint | number
    name: string
    description?: string | null
    structure: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    posts?: postsCreateNestedManyWithoutPost_templatesInput
  }

  export type post_templatesUncheckedCreateInput = {
    id?: bigint | number
    name: string
    description?: string | null
    structure: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    posts?: postsUncheckedCreateNestedManyWithoutPost_templatesInput
  }

  export type post_templatesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posts?: postsUpdateManyWithoutPost_templatesNestedInput
  }

  export type post_templatesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posts?: postsUncheckedUpdateManyWithoutPost_templatesNestedInput
  }

  export type post_templatesCreateManyInput = {
    id?: bigint | number
    name: string
    description?: string | null
    structure: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type post_templatesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type post_templatesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type postsCreateInput = {
    id?: bigint | number
    title: string
    slug: string
    content: string
    external_url?: string | null
    thumbnail_url?: string | null
    published_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: string | null
    comments?: commentsCreateNestedManyWithoutPostsInput
    post_tags?: post_tagsCreateNestedManyWithoutPostsInput
    categories?: categoriesCreateNestedOneWithoutPostsInput
    users?: usersCreateNestedOneWithoutPostsInput
    post_templates?: post_templatesCreateNestedOneWithoutPostsInput
  }

  export type postsUncheckedCreateInput = {
    id?: bigint | number
    category_id?: bigint | number | null
    title: string
    slug: string
    content: string
    external_url?: string | null
    thumbnail_url?: string | null
    published_at?: Date | string | null
    created_by?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    template_id?: bigint | number | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: string | null
    comments?: commentsUncheckedCreateNestedManyWithoutPostsInput
    post_tags?: post_tagsUncheckedCreateNestedManyWithoutPostsInput
  }

  export type postsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUpdateManyWithoutPostsNestedInput
    post_tags?: post_tagsUpdateManyWithoutPostsNestedInput
    categories?: categoriesUpdateOneWithoutPostsNestedInput
    users?: usersUpdateOneWithoutPostsNestedInput
    post_templates?: post_templatesUpdateOneWithoutPostsNestedInput
  }

  export type postsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUncheckedUpdateManyWithoutPostsNestedInput
    post_tags?: post_tagsUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type postsCreateManyInput = {
    id?: bigint | number
    category_id?: bigint | number | null
    title: string
    slug: string
    content: string
    external_url?: string | null
    thumbnail_url?: string | null
    published_at?: Date | string | null
    created_by?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    template_id?: bigint | number | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: string | null
  }

  export type postsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type postsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type study_materialsCreateInput = {
    id?: bigint | number
    title: string
    description?: string | null
    file_url: string
    created_at?: Date | string | null
  }

  export type study_materialsUncheckedCreateInput = {
    id?: bigint | number
    title: string
    description?: string | null
    file_url: string
    created_at?: Date | string | null
  }

  export type study_materialsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type study_materialsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type study_materialsCreateManyInput = {
    id?: bigint | number
    title: string
    description?: string | null
    file_url: string
    created_at?: Date | string | null
  }

  export type study_materialsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type study_materialsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    file_url?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tagsCreateInput = {
    id?: bigint | number
    name: string
    post_tags?: post_tagsCreateNestedManyWithoutTagsInput
  }

  export type tagsUncheckedCreateInput = {
    id?: bigint | number
    name: string
    post_tags?: post_tagsUncheckedCreateNestedManyWithoutTagsInput
  }

  export type tagsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    post_tags?: post_tagsUpdateManyWithoutTagsNestedInput
  }

  export type tagsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    post_tags?: post_tagsUncheckedUpdateManyWithoutTagsNestedInput
  }

  export type tagsCreateManyInput = {
    id?: bigint | number
    name: string
  }

  export type tagsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type tagsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type usersCreateInput = {
    id?: bigint | number
    full_name: string
    email: string
    password_hash: string
    role?: $Enums.user_role | null
    created_at?: Date | string | null
    comments?: commentsCreateNestedManyWithoutUsersInput
    course_reviews?: course_reviewsCreateNestedManyWithoutUsersInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    mock_attempts?: mock_attemptsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    posts?: postsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: bigint | number
    full_name: string
    email: string
    password_hash: string
    role?: $Enums.user_role | null
    created_at?: Date | string | null
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    course_reviews?: course_reviewsUncheckedCreateNestedManyWithoutUsersInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    mock_attempts?: mock_attemptsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    posts?: postsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: commentsUpdateManyWithoutUsersNestedInput
    course_reviews?: course_reviewsUpdateManyWithoutUsersNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    mock_attempts?: mock_attemptsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    posts?: postsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    course_reviews?: course_reviewsUncheckedUpdateManyWithoutUsersNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    mock_attempts?: mock_attemptsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    posts?: postsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: bigint | number
    full_name: string
    email: string
    password_hash: string
    role?: $Enums.user_role | null
    created_at?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type answer_keysCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    file_url?: SortOrder
    created_at?: SortOrder
  }

  export type answer_keysAvgOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
  }

  export type answer_keysMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    file_url?: SortOrder
    created_at?: SortOrder
  }

  export type answer_keysMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    year?: SortOrder
    file_url?: SortOrder
    created_at?: SortOrder
  }

  export type answer_keysSumOrderByAggregateInput = {
    id?: SortOrder
    year?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type PostsListRelationFilter = {
    every?: postsWhereInput
    some?: postsWhereInput
    none?: postsWhereInput
  }

  export type postsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type categoriesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type categoriesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type PostsNullableScalarRelationFilter = {
    is?: postsWhereInput | null
    isNot?: postsWhereInput | null
  }

  export type UsersNullableScalarRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type commentsCountOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type commentsAvgOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type commentsMaxOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type commentsMinOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
  }

  export type commentsSumOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type Enumplan_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.plan_type | Enumplan_typeFieldRefInput<$PrismaModel>
    in?: $Enums.plan_type[] | ListEnumplan_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.plan_type[] | ListEnumplan_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumplan_typeFilter<$PrismaModel> | $Enums.plan_type
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type CoursesNullableScalarRelationFilter = {
    is?: coursesWhereInput | null
    isNot?: coursesWhereInput | null
  }

  export type EnrollmentsListRelationFilter = {
    every?: enrollmentsWhereInput
    some?: enrollmentsWhereInput
    none?: enrollmentsWhereInput
  }

  export type enrollmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type course_plansCountOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    plan_type?: SortOrder
    plan_name?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    created_at?: SortOrder
  }

  export type course_plansAvgOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
  }

  export type course_plansMaxOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    plan_type?: SortOrder
    plan_name?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    created_at?: SortOrder
  }

  export type course_plansMinOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    plan_type?: SortOrder
    plan_name?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    created_at?: SortOrder
  }

  export type course_plansSumOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
  }

  export type Enumplan_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.plan_type | Enumplan_typeFieldRefInput<$PrismaModel>
    in?: $Enums.plan_type[] | ListEnumplan_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.plan_type[] | ListEnumplan_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumplan_typeWithAggregatesFilter<$PrismaModel> | $Enums.plan_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumplan_typeFilter<$PrismaModel>
    _max?: NestedEnumplan_typeFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type course_reviewsCountOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    created_at?: SortOrder
  }

  export type course_reviewsAvgOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
  }

  export type course_reviewsMaxOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    created_at?: SortOrder
  }

  export type course_reviewsMinOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    created_at?: SortOrder
  }

  export type course_reviewsSumOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    user_id?: SortOrder
    rating?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type course_videosCountOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    title?: SortOrder
    video_url?: SortOrder
    position?: SortOrder
    is_demo?: SortOrder
    created_at?: SortOrder
  }

  export type course_videosAvgOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    position?: SortOrder
  }

  export type course_videosMaxOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    title?: SortOrder
    video_url?: SortOrder
    position?: SortOrder
    is_demo?: SortOrder
    created_at?: SortOrder
  }

  export type course_videosMinOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    title?: SortOrder
    video_url?: SortOrder
    position?: SortOrder
    is_demo?: SortOrder
    created_at?: SortOrder
  }

  export type course_videosSumOrderByAggregateInput = {
    id?: SortOrder
    course_id?: SortOrder
    position?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type Course_plansListRelationFilter = {
    every?: course_plansWhereInput
    some?: course_plansWhereInput
    none?: course_plansWhereInput
  }

  export type Course_reviewsListRelationFilter = {
    every?: course_reviewsWhereInput
    some?: course_reviewsWhereInput
    none?: course_reviewsWhereInput
  }

  export type Course_videosListRelationFilter = {
    every?: course_videosWhereInput
    some?: course_videosWhereInput
    none?: course_videosWhereInput
  }

  export type PaymentsListRelationFilter = {
    every?: paymentsWhereInput
    some?: paymentsWhereInput
    none?: paymentsWhereInput
  }

  export type course_plansOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type course_reviewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type course_videosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type coursesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type coursesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type coursesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type coursesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    thumbnail_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type coursesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumenrollment_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enrollment_status | Enumenrollment_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enrollment_status[] | ListEnumenrollment_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enrollment_status[] | ListEnumenrollment_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenrollment_statusNullableFilter<$PrismaModel> | $Enums.enrollment_status | null
  }

  export type Course_plansNullableScalarRelationFilter = {
    is?: course_plansWhereInput | null
    isNot?: course_plansWhereInput | null
  }

  export type enrollmentsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    plan_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    expires_at?: SortOrder
  }

  export type enrollmentsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    plan_id?: SortOrder
  }

  export type enrollmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    plan_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    expires_at?: SortOrder
  }

  export type enrollmentsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    plan_id?: SortOrder
    status?: SortOrder
    started_at?: SortOrder
    expires_at?: SortOrder
  }

  export type enrollmentsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    plan_id?: SortOrder
  }

  export type Enumenrollment_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enrollment_status | Enumenrollment_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enrollment_status[] | ListEnumenrollment_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enrollment_status[] | ListEnumenrollment_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenrollment_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enrollment_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenrollment_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenrollment_statusNullableFilter<$PrismaModel>
  }

  export type google_adsCountOrderByAggregateInput = {
    id?: SortOrder
    placement?: SortOrder
    ad_code?: SortOrder
    created_at?: SortOrder
  }

  export type google_adsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type google_adsMaxOrderByAggregateInput = {
    id?: SortOrder
    placement?: SortOrder
    ad_code?: SortOrder
    created_at?: SortOrder
  }

  export type google_adsMinOrderByAggregateInput = {
    id?: SortOrder
    placement?: SortOrder
    ad_code?: SortOrder
    created_at?: SortOrder
  }

  export type google_adsSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type Mock_testsNullableScalarRelationFilter = {
    is?: mock_testsWhereInput | null
    isNot?: mock_testsWhereInput | null
  }

  export type mock_attemptsCountOrderByAggregateInput = {
    id?: SortOrder
    test_id?: SortOrder
    user_id?: SortOrder
    answers?: SortOrder
    score?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
  }

  export type mock_attemptsAvgOrderByAggregateInput = {
    id?: SortOrder
    test_id?: SortOrder
    user_id?: SortOrder
    score?: SortOrder
  }

  export type mock_attemptsMaxOrderByAggregateInput = {
    id?: SortOrder
    test_id?: SortOrder
    user_id?: SortOrder
    score?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
  }

  export type mock_attemptsMinOrderByAggregateInput = {
    id?: SortOrder
    test_id?: SortOrder
    user_id?: SortOrder
    score?: SortOrder
    started_at?: SortOrder
    completed_at?: SortOrder
  }

  export type mock_attemptsSumOrderByAggregateInput = {
    id?: SortOrder
    test_id?: SortOrder
    user_id?: SortOrder
    score?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type Mock_seriesListRelationFilter = {
    every?: mock_seriesWhereInput
    some?: mock_seriesWhereInput
    none?: mock_seriesWhereInput
  }

  export type mock_seriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mock_categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type mock_categoriesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type mock_categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type mock_categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type mock_categoriesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumquestion_typeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.question_type | Enumquestion_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.question_type[] | ListEnumquestion_typeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.question_type[] | ListEnumquestion_typeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumquestion_typeNullableFilter<$PrismaModel> | $Enums.question_type | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type mock_questionsCountOrderByAggregateInput = {
    id?: SortOrder
    test_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    options?: SortOrder
    correct_answer?: SortOrder
    marks?: SortOrder
  }

  export type mock_questionsAvgOrderByAggregateInput = {
    id?: SortOrder
    test_id?: SortOrder
    marks?: SortOrder
  }

  export type mock_questionsMaxOrderByAggregateInput = {
    id?: SortOrder
    test_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    correct_answer?: SortOrder
    marks?: SortOrder
  }

  export type mock_questionsMinOrderByAggregateInput = {
    id?: SortOrder
    test_id?: SortOrder
    question_text?: SortOrder
    question_type?: SortOrder
    correct_answer?: SortOrder
    marks?: SortOrder
  }

  export type mock_questionsSumOrderByAggregateInput = {
    id?: SortOrder
    test_id?: SortOrder
    marks?: SortOrder
  }

  export type Enumquestion_typeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.question_type | Enumquestion_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.question_type[] | ListEnumquestion_typeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.question_type[] | ListEnumquestion_typeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumquestion_typeNullableWithAggregatesFilter<$PrismaModel> | $Enums.question_type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumquestion_typeNullableFilter<$PrismaModel>
    _max?: NestedEnumquestion_typeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type Mock_categoriesNullableScalarRelationFilter = {
    is?: mock_categoriesWhereInput | null
    isNot?: mock_categoriesWhereInput | null
  }

  export type Mock_testsListRelationFilter = {
    every?: mock_testsWhereInput
    some?: mock_testsWhereInput
    none?: mock_testsWhereInput
  }

  export type mock_testsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mock_seriesCountOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    price?: SortOrder
  }

  export type mock_seriesAvgOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    price?: SortOrder
  }

  export type mock_seriesMaxOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    price?: SortOrder
  }

  export type mock_seriesMinOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    price?: SortOrder
  }

  export type mock_seriesSumOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    price?: SortOrder
  }

  export type Mock_attemptsListRelationFilter = {
    every?: mock_attemptsWhereInput
    some?: mock_attemptsWhereInput
    none?: mock_attemptsWhereInput
  }

  export type Mock_questionsListRelationFilter = {
    every?: mock_questionsWhereInput
    some?: mock_questionsWhereInput
    none?: mock_questionsWhereInput
  }

  export type Mock_seriesNullableScalarRelationFilter = {
    is?: mock_seriesWhereInput | null
    isNot?: mock_seriesWhereInput | null
  }

  export type mock_attemptsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mock_questionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mock_testsCountOrderByAggregateInput = {
    id?: SortOrder
    series_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    duration_minutes?: SortOrder
    total_marks?: SortOrder
    created_at?: SortOrder
    is_free?: SortOrder
  }

  export type mock_testsAvgOrderByAggregateInput = {
    id?: SortOrder
    series_id?: SortOrder
    duration_minutes?: SortOrder
    total_marks?: SortOrder
  }

  export type mock_testsMaxOrderByAggregateInput = {
    id?: SortOrder
    series_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    duration_minutes?: SortOrder
    total_marks?: SortOrder
    created_at?: SortOrder
    is_free?: SortOrder
  }

  export type mock_testsMinOrderByAggregateInput = {
    id?: SortOrder
    series_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    duration_minutes?: SortOrder
    total_marks?: SortOrder
    created_at?: SortOrder
    is_free?: SortOrder
  }

  export type mock_testsSumOrderByAggregateInput = {
    id?: SortOrder
    series_id?: SortOrder
    duration_minutes?: SortOrder
    total_marks?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type Enumpayment_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_status | Enumpayment_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_status[] | ListEnumpayment_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.payment_status[] | ListEnumpayment_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpayment_statusNullableFilter<$PrismaModel> | $Enums.payment_status | null
  }

  export type paymentsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    transaction_id?: SortOrder
    created_at?: SortOrder
    mock_series_id?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    amount?: SortOrder
    mock_series_id?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    transaction_id?: SortOrder
    created_at?: SortOrder
    mock_series_id?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    transaction_id?: SortOrder
    created_at?: SortOrder
    mock_series_id?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    course_id?: SortOrder
    amount?: SortOrder
    mock_series_id?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type Enumpayment_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_status | Enumpayment_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_status[] | ListEnumpayment_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.payment_status[] | ListEnumpayment_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpayment_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.payment_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumpayment_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumpayment_statusNullableFilter<$PrismaModel>
  }

  export type PostsScalarRelationFilter = {
    is?: postsWhereInput
    isNot?: postsWhereInput
  }

  export type TagsScalarRelationFilter = {
    is?: tagsWhereInput
    isNot?: tagsWhereInput
  }

  export type post_tagsPost_idTag_idCompoundUniqueInput = {
    post_id: bigint | number
    tag_id: bigint | number
  }

  export type post_tagsCountOrderByAggregateInput = {
    post_id?: SortOrder
    tag_id?: SortOrder
  }

  export type post_tagsAvgOrderByAggregateInput = {
    post_id?: SortOrder
    tag_id?: SortOrder
  }

  export type post_tagsMaxOrderByAggregateInput = {
    post_id?: SortOrder
    tag_id?: SortOrder
  }

  export type post_tagsMinOrderByAggregateInput = {
    post_id?: SortOrder
    tag_id?: SortOrder
  }

  export type post_tagsSumOrderByAggregateInput = {
    post_id?: SortOrder
    tag_id?: SortOrder
  }

  export type post_templatesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    structure?: SortOrder
    created_at?: SortOrder
  }

  export type post_templatesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type post_templatesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type post_templatesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
  }

  export type post_templatesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CommentsListRelationFilter = {
    every?: commentsWhereInput
    some?: commentsWhereInput
    none?: commentsWhereInput
  }

  export type Post_tagsListRelationFilter = {
    every?: post_tagsWhereInput
    some?: post_tagsWhereInput
    none?: post_tagsWhereInput
  }

  export type CategoriesNullableScalarRelationFilter = {
    is?: categoriesWhereInput | null
    isNot?: categoriesWhereInput | null
  }

  export type Post_templatesNullableScalarRelationFilter = {
    is?: post_templatesWhereInput | null
    isNot?: post_templatesWhereInput | null
  }

  export type commentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type post_tagsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type postsCountOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    external_url?: SortOrder
    thumbnail_url?: SortOrder
    published_at?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    template_id?: SortOrder
    content_json?: SortOrder
    content_html?: SortOrder
  }

  export type postsAvgOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    created_by?: SortOrder
    template_id?: SortOrder
  }

  export type postsMaxOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    external_url?: SortOrder
    thumbnail_url?: SortOrder
    published_at?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    template_id?: SortOrder
    content_html?: SortOrder
  }

  export type postsMinOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    external_url?: SortOrder
    thumbnail_url?: SortOrder
    published_at?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    template_id?: SortOrder
    content_html?: SortOrder
  }

  export type postsSumOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    created_by?: SortOrder
    template_id?: SortOrder
  }

  export type study_materialsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file_url?: SortOrder
    created_at?: SortOrder
  }

  export type study_materialsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type study_materialsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file_url?: SortOrder
    created_at?: SortOrder
  }

  export type study_materialsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    file_url?: SortOrder
    created_at?: SortOrder
  }

  export type study_materialsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tagsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type tagsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tagsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type tagsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type tagsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumuser_roleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumuser_roleNullableFilter<$PrismaModel> | $Enums.user_role | null
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    full_name?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Enumuser_roleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumuser_roleNullableWithAggregatesFilter<$PrismaModel> | $Enums.user_role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumuser_roleNullableFilter<$PrismaModel>
    _max?: NestedEnumuser_roleNullableFilter<$PrismaModel>
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type postsCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<postsCreateWithoutCategoriesInput, postsUncheckedCreateWithoutCategoriesInput> | postsCreateWithoutCategoriesInput[] | postsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: postsCreateOrConnectWithoutCategoriesInput | postsCreateOrConnectWithoutCategoriesInput[]
    createMany?: postsCreateManyCategoriesInputEnvelope
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
  }

  export type postsUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<postsCreateWithoutCategoriesInput, postsUncheckedCreateWithoutCategoriesInput> | postsCreateWithoutCategoriesInput[] | postsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: postsCreateOrConnectWithoutCategoriesInput | postsCreateOrConnectWithoutCategoriesInput[]
    createMany?: postsCreateManyCategoriesInputEnvelope
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type postsUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<postsCreateWithoutCategoriesInput, postsUncheckedCreateWithoutCategoriesInput> | postsCreateWithoutCategoriesInput[] | postsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: postsCreateOrConnectWithoutCategoriesInput | postsCreateOrConnectWithoutCategoriesInput[]
    upsert?: postsUpsertWithWhereUniqueWithoutCategoriesInput | postsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: postsCreateManyCategoriesInputEnvelope
    set?: postsWhereUniqueInput | postsWhereUniqueInput[]
    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    update?: postsUpdateWithWhereUniqueWithoutCategoriesInput | postsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: postsUpdateManyWithWhereWithoutCategoriesInput | postsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]
  }

  export type postsUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<postsCreateWithoutCategoriesInput, postsUncheckedCreateWithoutCategoriesInput> | postsCreateWithoutCategoriesInput[] | postsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: postsCreateOrConnectWithoutCategoriesInput | postsCreateOrConnectWithoutCategoriesInput[]
    upsert?: postsUpsertWithWhereUniqueWithoutCategoriesInput | postsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: postsCreateManyCategoriesInputEnvelope
    set?: postsWhereUniqueInput | postsWhereUniqueInput[]
    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    update?: postsUpdateWithWhereUniqueWithoutCategoriesInput | postsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: postsUpdateManyWithWhereWithoutCategoriesInput | postsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]
  }

  export type postsCreateNestedOneWithoutCommentsInput = {
    create?: XOR<postsCreateWithoutCommentsInput, postsUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: postsCreateOrConnectWithoutCommentsInput
    connect?: postsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutCommentsInput = {
    create?: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCommentsInput
    connect?: usersWhereUniqueInput
  }

  export type postsUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<postsCreateWithoutCommentsInput, postsUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: postsCreateOrConnectWithoutCommentsInput
    upsert?: postsUpsertWithoutCommentsInput
    disconnect?: postsWhereInput | boolean
    delete?: postsWhereInput | boolean
    connect?: postsWhereUniqueInput
    update?: XOR<XOR<postsUpdateToOneWithWhereWithoutCommentsInput, postsUpdateWithoutCommentsInput>, postsUncheckedUpdateWithoutCommentsInput>
  }

  export type usersUpdateOneWithoutCommentsNestedInput = {
    create?: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCommentsInput
    upsert?: usersUpsertWithoutCommentsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCommentsInput, usersUpdateWithoutCommentsInput>, usersUncheckedUpdateWithoutCommentsInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type coursesCreateNestedOneWithoutCourse_plansInput = {
    create?: XOR<coursesCreateWithoutCourse_plansInput, coursesUncheckedCreateWithoutCourse_plansInput>
    connectOrCreate?: coursesCreateOrConnectWithoutCourse_plansInput
    connect?: coursesWhereUniqueInput
  }

  export type enrollmentsCreateNestedManyWithoutCourse_plansInput = {
    create?: XOR<enrollmentsCreateWithoutCourse_plansInput, enrollmentsUncheckedCreateWithoutCourse_plansInput> | enrollmentsCreateWithoutCourse_plansInput[] | enrollmentsUncheckedCreateWithoutCourse_plansInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutCourse_plansInput | enrollmentsCreateOrConnectWithoutCourse_plansInput[]
    createMany?: enrollmentsCreateManyCourse_plansInputEnvelope
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
  }

  export type enrollmentsUncheckedCreateNestedManyWithoutCourse_plansInput = {
    create?: XOR<enrollmentsCreateWithoutCourse_plansInput, enrollmentsUncheckedCreateWithoutCourse_plansInput> | enrollmentsCreateWithoutCourse_plansInput[] | enrollmentsUncheckedCreateWithoutCourse_plansInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutCourse_plansInput | enrollmentsCreateOrConnectWithoutCourse_plansInput[]
    createMany?: enrollmentsCreateManyCourse_plansInputEnvelope
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
  }

  export type Enumplan_typeFieldUpdateOperationsInput = {
    set?: $Enums.plan_type
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type coursesUpdateOneWithoutCourse_plansNestedInput = {
    create?: XOR<coursesCreateWithoutCourse_plansInput, coursesUncheckedCreateWithoutCourse_plansInput>
    connectOrCreate?: coursesCreateOrConnectWithoutCourse_plansInput
    upsert?: coursesUpsertWithoutCourse_plansInput
    disconnect?: coursesWhereInput | boolean
    delete?: coursesWhereInput | boolean
    connect?: coursesWhereUniqueInput
    update?: XOR<XOR<coursesUpdateToOneWithWhereWithoutCourse_plansInput, coursesUpdateWithoutCourse_plansInput>, coursesUncheckedUpdateWithoutCourse_plansInput>
  }

  export type enrollmentsUpdateManyWithoutCourse_plansNestedInput = {
    create?: XOR<enrollmentsCreateWithoutCourse_plansInput, enrollmentsUncheckedCreateWithoutCourse_plansInput> | enrollmentsCreateWithoutCourse_plansInput[] | enrollmentsUncheckedCreateWithoutCourse_plansInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutCourse_plansInput | enrollmentsCreateOrConnectWithoutCourse_plansInput[]
    upsert?: enrollmentsUpsertWithWhereUniqueWithoutCourse_plansInput | enrollmentsUpsertWithWhereUniqueWithoutCourse_plansInput[]
    createMany?: enrollmentsCreateManyCourse_plansInputEnvelope
    set?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    disconnect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    delete?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    update?: enrollmentsUpdateWithWhereUniqueWithoutCourse_plansInput | enrollmentsUpdateWithWhereUniqueWithoutCourse_plansInput[]
    updateMany?: enrollmentsUpdateManyWithWhereWithoutCourse_plansInput | enrollmentsUpdateManyWithWhereWithoutCourse_plansInput[]
    deleteMany?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
  }

  export type enrollmentsUncheckedUpdateManyWithoutCourse_plansNestedInput = {
    create?: XOR<enrollmentsCreateWithoutCourse_plansInput, enrollmentsUncheckedCreateWithoutCourse_plansInput> | enrollmentsCreateWithoutCourse_plansInput[] | enrollmentsUncheckedCreateWithoutCourse_plansInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutCourse_plansInput | enrollmentsCreateOrConnectWithoutCourse_plansInput[]
    upsert?: enrollmentsUpsertWithWhereUniqueWithoutCourse_plansInput | enrollmentsUpsertWithWhereUniqueWithoutCourse_plansInput[]
    createMany?: enrollmentsCreateManyCourse_plansInputEnvelope
    set?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    disconnect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    delete?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    update?: enrollmentsUpdateWithWhereUniqueWithoutCourse_plansInput | enrollmentsUpdateWithWhereUniqueWithoutCourse_plansInput[]
    updateMany?: enrollmentsUpdateManyWithWhereWithoutCourse_plansInput | enrollmentsUpdateManyWithWhereWithoutCourse_plansInput[]
    deleteMany?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
  }

  export type coursesCreateNestedOneWithoutCourse_reviewsInput = {
    create?: XOR<coursesCreateWithoutCourse_reviewsInput, coursesUncheckedCreateWithoutCourse_reviewsInput>
    connectOrCreate?: coursesCreateOrConnectWithoutCourse_reviewsInput
    connect?: coursesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutCourse_reviewsInput = {
    create?: XOR<usersCreateWithoutCourse_reviewsInput, usersUncheckedCreateWithoutCourse_reviewsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCourse_reviewsInput
    connect?: usersWhereUniqueInput
  }

  export type coursesUpdateOneWithoutCourse_reviewsNestedInput = {
    create?: XOR<coursesCreateWithoutCourse_reviewsInput, coursesUncheckedCreateWithoutCourse_reviewsInput>
    connectOrCreate?: coursesCreateOrConnectWithoutCourse_reviewsInput
    upsert?: coursesUpsertWithoutCourse_reviewsInput
    disconnect?: coursesWhereInput | boolean
    delete?: coursesWhereInput | boolean
    connect?: coursesWhereUniqueInput
    update?: XOR<XOR<coursesUpdateToOneWithWhereWithoutCourse_reviewsInput, coursesUpdateWithoutCourse_reviewsInput>, coursesUncheckedUpdateWithoutCourse_reviewsInput>
  }

  export type usersUpdateOneWithoutCourse_reviewsNestedInput = {
    create?: XOR<usersCreateWithoutCourse_reviewsInput, usersUncheckedCreateWithoutCourse_reviewsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCourse_reviewsInput
    upsert?: usersUpsertWithoutCourse_reviewsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCourse_reviewsInput, usersUpdateWithoutCourse_reviewsInput>, usersUncheckedUpdateWithoutCourse_reviewsInput>
  }

  export type coursesCreateNestedOneWithoutCourse_videosInput = {
    create?: XOR<coursesCreateWithoutCourse_videosInput, coursesUncheckedCreateWithoutCourse_videosInput>
    connectOrCreate?: coursesCreateOrConnectWithoutCourse_videosInput
    connect?: coursesWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type coursesUpdateOneWithoutCourse_videosNestedInput = {
    create?: XOR<coursesCreateWithoutCourse_videosInput, coursesUncheckedCreateWithoutCourse_videosInput>
    connectOrCreate?: coursesCreateOrConnectWithoutCourse_videosInput
    upsert?: coursesUpsertWithoutCourse_videosInput
    disconnect?: coursesWhereInput | boolean
    delete?: coursesWhereInput | boolean
    connect?: coursesWhereUniqueInput
    update?: XOR<XOR<coursesUpdateToOneWithWhereWithoutCourse_videosInput, coursesUpdateWithoutCourse_videosInput>, coursesUncheckedUpdateWithoutCourse_videosInput>
  }

  export type course_plansCreateNestedManyWithoutCoursesInput = {
    create?: XOR<course_plansCreateWithoutCoursesInput, course_plansUncheckedCreateWithoutCoursesInput> | course_plansCreateWithoutCoursesInput[] | course_plansUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: course_plansCreateOrConnectWithoutCoursesInput | course_plansCreateOrConnectWithoutCoursesInput[]
    createMany?: course_plansCreateManyCoursesInputEnvelope
    connect?: course_plansWhereUniqueInput | course_plansWhereUniqueInput[]
  }

  export type course_reviewsCreateNestedManyWithoutCoursesInput = {
    create?: XOR<course_reviewsCreateWithoutCoursesInput, course_reviewsUncheckedCreateWithoutCoursesInput> | course_reviewsCreateWithoutCoursesInput[] | course_reviewsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: course_reviewsCreateOrConnectWithoutCoursesInput | course_reviewsCreateOrConnectWithoutCoursesInput[]
    createMany?: course_reviewsCreateManyCoursesInputEnvelope
    connect?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
  }

  export type course_videosCreateNestedManyWithoutCoursesInput = {
    create?: XOR<course_videosCreateWithoutCoursesInput, course_videosUncheckedCreateWithoutCoursesInput> | course_videosCreateWithoutCoursesInput[] | course_videosUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: course_videosCreateOrConnectWithoutCoursesInput | course_videosCreateOrConnectWithoutCoursesInput[]
    createMany?: course_videosCreateManyCoursesInputEnvelope
    connect?: course_videosWhereUniqueInput | course_videosWhereUniqueInput[]
  }

  export type enrollmentsCreateNestedManyWithoutCoursesInput = {
    create?: XOR<enrollmentsCreateWithoutCoursesInput, enrollmentsUncheckedCreateWithoutCoursesInput> | enrollmentsCreateWithoutCoursesInput[] | enrollmentsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutCoursesInput | enrollmentsCreateOrConnectWithoutCoursesInput[]
    createMany?: enrollmentsCreateManyCoursesInputEnvelope
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
  }

  export type paymentsCreateNestedManyWithoutCoursesInput = {
    create?: XOR<paymentsCreateWithoutCoursesInput, paymentsUncheckedCreateWithoutCoursesInput> | paymentsCreateWithoutCoursesInput[] | paymentsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutCoursesInput | paymentsCreateOrConnectWithoutCoursesInput[]
    createMany?: paymentsCreateManyCoursesInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type course_plansUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<course_plansCreateWithoutCoursesInput, course_plansUncheckedCreateWithoutCoursesInput> | course_plansCreateWithoutCoursesInput[] | course_plansUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: course_plansCreateOrConnectWithoutCoursesInput | course_plansCreateOrConnectWithoutCoursesInput[]
    createMany?: course_plansCreateManyCoursesInputEnvelope
    connect?: course_plansWhereUniqueInput | course_plansWhereUniqueInput[]
  }

  export type course_reviewsUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<course_reviewsCreateWithoutCoursesInput, course_reviewsUncheckedCreateWithoutCoursesInput> | course_reviewsCreateWithoutCoursesInput[] | course_reviewsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: course_reviewsCreateOrConnectWithoutCoursesInput | course_reviewsCreateOrConnectWithoutCoursesInput[]
    createMany?: course_reviewsCreateManyCoursesInputEnvelope
    connect?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
  }

  export type course_videosUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<course_videosCreateWithoutCoursesInput, course_videosUncheckedCreateWithoutCoursesInput> | course_videosCreateWithoutCoursesInput[] | course_videosUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: course_videosCreateOrConnectWithoutCoursesInput | course_videosCreateOrConnectWithoutCoursesInput[]
    createMany?: course_videosCreateManyCoursesInputEnvelope
    connect?: course_videosWhereUniqueInput | course_videosWhereUniqueInput[]
  }

  export type enrollmentsUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<enrollmentsCreateWithoutCoursesInput, enrollmentsUncheckedCreateWithoutCoursesInput> | enrollmentsCreateWithoutCoursesInput[] | enrollmentsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutCoursesInput | enrollmentsCreateOrConnectWithoutCoursesInput[]
    createMany?: enrollmentsCreateManyCoursesInputEnvelope
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutCoursesInput = {
    create?: XOR<paymentsCreateWithoutCoursesInput, paymentsUncheckedCreateWithoutCoursesInput> | paymentsCreateWithoutCoursesInput[] | paymentsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutCoursesInput | paymentsCreateOrConnectWithoutCoursesInput[]
    createMany?: paymentsCreateManyCoursesInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type course_plansUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<course_plansCreateWithoutCoursesInput, course_plansUncheckedCreateWithoutCoursesInput> | course_plansCreateWithoutCoursesInput[] | course_plansUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: course_plansCreateOrConnectWithoutCoursesInput | course_plansCreateOrConnectWithoutCoursesInput[]
    upsert?: course_plansUpsertWithWhereUniqueWithoutCoursesInput | course_plansUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: course_plansCreateManyCoursesInputEnvelope
    set?: course_plansWhereUniqueInput | course_plansWhereUniqueInput[]
    disconnect?: course_plansWhereUniqueInput | course_plansWhereUniqueInput[]
    delete?: course_plansWhereUniqueInput | course_plansWhereUniqueInput[]
    connect?: course_plansWhereUniqueInput | course_plansWhereUniqueInput[]
    update?: course_plansUpdateWithWhereUniqueWithoutCoursesInput | course_plansUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: course_plansUpdateManyWithWhereWithoutCoursesInput | course_plansUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: course_plansScalarWhereInput | course_plansScalarWhereInput[]
  }

  export type course_reviewsUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<course_reviewsCreateWithoutCoursesInput, course_reviewsUncheckedCreateWithoutCoursesInput> | course_reviewsCreateWithoutCoursesInput[] | course_reviewsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: course_reviewsCreateOrConnectWithoutCoursesInput | course_reviewsCreateOrConnectWithoutCoursesInput[]
    upsert?: course_reviewsUpsertWithWhereUniqueWithoutCoursesInput | course_reviewsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: course_reviewsCreateManyCoursesInputEnvelope
    set?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
    disconnect?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
    delete?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
    connect?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
    update?: course_reviewsUpdateWithWhereUniqueWithoutCoursesInput | course_reviewsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: course_reviewsUpdateManyWithWhereWithoutCoursesInput | course_reviewsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: course_reviewsScalarWhereInput | course_reviewsScalarWhereInput[]
  }

  export type course_videosUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<course_videosCreateWithoutCoursesInput, course_videosUncheckedCreateWithoutCoursesInput> | course_videosCreateWithoutCoursesInput[] | course_videosUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: course_videosCreateOrConnectWithoutCoursesInput | course_videosCreateOrConnectWithoutCoursesInput[]
    upsert?: course_videosUpsertWithWhereUniqueWithoutCoursesInput | course_videosUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: course_videosCreateManyCoursesInputEnvelope
    set?: course_videosWhereUniqueInput | course_videosWhereUniqueInput[]
    disconnect?: course_videosWhereUniqueInput | course_videosWhereUniqueInput[]
    delete?: course_videosWhereUniqueInput | course_videosWhereUniqueInput[]
    connect?: course_videosWhereUniqueInput | course_videosWhereUniqueInput[]
    update?: course_videosUpdateWithWhereUniqueWithoutCoursesInput | course_videosUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: course_videosUpdateManyWithWhereWithoutCoursesInput | course_videosUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: course_videosScalarWhereInput | course_videosScalarWhereInput[]
  }

  export type enrollmentsUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<enrollmentsCreateWithoutCoursesInput, enrollmentsUncheckedCreateWithoutCoursesInput> | enrollmentsCreateWithoutCoursesInput[] | enrollmentsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutCoursesInput | enrollmentsCreateOrConnectWithoutCoursesInput[]
    upsert?: enrollmentsUpsertWithWhereUniqueWithoutCoursesInput | enrollmentsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: enrollmentsCreateManyCoursesInputEnvelope
    set?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    disconnect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    delete?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    update?: enrollmentsUpdateWithWhereUniqueWithoutCoursesInput | enrollmentsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: enrollmentsUpdateManyWithWhereWithoutCoursesInput | enrollmentsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
  }

  export type paymentsUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<paymentsCreateWithoutCoursesInput, paymentsUncheckedCreateWithoutCoursesInput> | paymentsCreateWithoutCoursesInput[] | paymentsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutCoursesInput | paymentsCreateOrConnectWithoutCoursesInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutCoursesInput | paymentsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: paymentsCreateManyCoursesInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutCoursesInput | paymentsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutCoursesInput | paymentsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type course_plansUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<course_plansCreateWithoutCoursesInput, course_plansUncheckedCreateWithoutCoursesInput> | course_plansCreateWithoutCoursesInput[] | course_plansUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: course_plansCreateOrConnectWithoutCoursesInput | course_plansCreateOrConnectWithoutCoursesInput[]
    upsert?: course_plansUpsertWithWhereUniqueWithoutCoursesInput | course_plansUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: course_plansCreateManyCoursesInputEnvelope
    set?: course_plansWhereUniqueInput | course_plansWhereUniqueInput[]
    disconnect?: course_plansWhereUniqueInput | course_plansWhereUniqueInput[]
    delete?: course_plansWhereUniqueInput | course_plansWhereUniqueInput[]
    connect?: course_plansWhereUniqueInput | course_plansWhereUniqueInput[]
    update?: course_plansUpdateWithWhereUniqueWithoutCoursesInput | course_plansUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: course_plansUpdateManyWithWhereWithoutCoursesInput | course_plansUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: course_plansScalarWhereInput | course_plansScalarWhereInput[]
  }

  export type course_reviewsUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<course_reviewsCreateWithoutCoursesInput, course_reviewsUncheckedCreateWithoutCoursesInput> | course_reviewsCreateWithoutCoursesInput[] | course_reviewsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: course_reviewsCreateOrConnectWithoutCoursesInput | course_reviewsCreateOrConnectWithoutCoursesInput[]
    upsert?: course_reviewsUpsertWithWhereUniqueWithoutCoursesInput | course_reviewsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: course_reviewsCreateManyCoursesInputEnvelope
    set?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
    disconnect?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
    delete?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
    connect?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
    update?: course_reviewsUpdateWithWhereUniqueWithoutCoursesInput | course_reviewsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: course_reviewsUpdateManyWithWhereWithoutCoursesInput | course_reviewsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: course_reviewsScalarWhereInput | course_reviewsScalarWhereInput[]
  }

  export type course_videosUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<course_videosCreateWithoutCoursesInput, course_videosUncheckedCreateWithoutCoursesInput> | course_videosCreateWithoutCoursesInput[] | course_videosUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: course_videosCreateOrConnectWithoutCoursesInput | course_videosCreateOrConnectWithoutCoursesInput[]
    upsert?: course_videosUpsertWithWhereUniqueWithoutCoursesInput | course_videosUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: course_videosCreateManyCoursesInputEnvelope
    set?: course_videosWhereUniqueInput | course_videosWhereUniqueInput[]
    disconnect?: course_videosWhereUniqueInput | course_videosWhereUniqueInput[]
    delete?: course_videosWhereUniqueInput | course_videosWhereUniqueInput[]
    connect?: course_videosWhereUniqueInput | course_videosWhereUniqueInput[]
    update?: course_videosUpdateWithWhereUniqueWithoutCoursesInput | course_videosUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: course_videosUpdateManyWithWhereWithoutCoursesInput | course_videosUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: course_videosScalarWhereInput | course_videosScalarWhereInput[]
  }

  export type enrollmentsUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<enrollmentsCreateWithoutCoursesInput, enrollmentsUncheckedCreateWithoutCoursesInput> | enrollmentsCreateWithoutCoursesInput[] | enrollmentsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutCoursesInput | enrollmentsCreateOrConnectWithoutCoursesInput[]
    upsert?: enrollmentsUpsertWithWhereUniqueWithoutCoursesInput | enrollmentsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: enrollmentsCreateManyCoursesInputEnvelope
    set?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    disconnect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    delete?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    update?: enrollmentsUpdateWithWhereUniqueWithoutCoursesInput | enrollmentsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: enrollmentsUpdateManyWithWhereWithoutCoursesInput | enrollmentsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutCoursesNestedInput = {
    create?: XOR<paymentsCreateWithoutCoursesInput, paymentsUncheckedCreateWithoutCoursesInput> | paymentsCreateWithoutCoursesInput[] | paymentsUncheckedCreateWithoutCoursesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutCoursesInput | paymentsCreateOrConnectWithoutCoursesInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutCoursesInput | paymentsUpsertWithWhereUniqueWithoutCoursesInput[]
    createMany?: paymentsCreateManyCoursesInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutCoursesInput | paymentsUpdateWithWhereUniqueWithoutCoursesInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutCoursesInput | paymentsUpdateManyWithWhereWithoutCoursesInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type coursesCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<coursesCreateWithoutEnrollmentsInput, coursesUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: coursesCreateOrConnectWithoutEnrollmentsInput
    connect?: coursesWhereUniqueInput
  }

  export type course_plansCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<course_plansCreateWithoutEnrollmentsInput, course_plansUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: course_plansCreateOrConnectWithoutEnrollmentsInput
    connect?: course_plansWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<usersCreateWithoutEnrollmentsInput, usersUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutEnrollmentsInput
    connect?: usersWhereUniqueInput
  }

  export type NullableEnumenrollment_statusFieldUpdateOperationsInput = {
    set?: $Enums.enrollment_status | null
  }

  export type coursesUpdateOneWithoutEnrollmentsNestedInput = {
    create?: XOR<coursesCreateWithoutEnrollmentsInput, coursesUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: coursesCreateOrConnectWithoutEnrollmentsInput
    upsert?: coursesUpsertWithoutEnrollmentsInput
    disconnect?: coursesWhereInput | boolean
    delete?: coursesWhereInput | boolean
    connect?: coursesWhereUniqueInput
    update?: XOR<XOR<coursesUpdateToOneWithWhereWithoutEnrollmentsInput, coursesUpdateWithoutEnrollmentsInput>, coursesUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type course_plansUpdateOneWithoutEnrollmentsNestedInput = {
    create?: XOR<course_plansCreateWithoutEnrollmentsInput, course_plansUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: course_plansCreateOrConnectWithoutEnrollmentsInput
    upsert?: course_plansUpsertWithoutEnrollmentsInput
    disconnect?: course_plansWhereInput | boolean
    delete?: course_plansWhereInput | boolean
    connect?: course_plansWhereUniqueInput
    update?: XOR<XOR<course_plansUpdateToOneWithWhereWithoutEnrollmentsInput, course_plansUpdateWithoutEnrollmentsInput>, course_plansUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type usersUpdateOneWithoutEnrollmentsNestedInput = {
    create?: XOR<usersCreateWithoutEnrollmentsInput, usersUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutEnrollmentsInput
    upsert?: usersUpsertWithoutEnrollmentsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutEnrollmentsInput, usersUpdateWithoutEnrollmentsInput>, usersUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type mock_testsCreateNestedOneWithoutMock_attemptsInput = {
    create?: XOR<mock_testsCreateWithoutMock_attemptsInput, mock_testsUncheckedCreateWithoutMock_attemptsInput>
    connectOrCreate?: mock_testsCreateOrConnectWithoutMock_attemptsInput
    connect?: mock_testsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutMock_attemptsInput = {
    create?: XOR<usersCreateWithoutMock_attemptsInput, usersUncheckedCreateWithoutMock_attemptsInput>
    connectOrCreate?: usersCreateOrConnectWithoutMock_attemptsInput
    connect?: usersWhereUniqueInput
  }

  export type mock_testsUpdateOneWithoutMock_attemptsNestedInput = {
    create?: XOR<mock_testsCreateWithoutMock_attemptsInput, mock_testsUncheckedCreateWithoutMock_attemptsInput>
    connectOrCreate?: mock_testsCreateOrConnectWithoutMock_attemptsInput
    upsert?: mock_testsUpsertWithoutMock_attemptsInput
    disconnect?: mock_testsWhereInput | boolean
    delete?: mock_testsWhereInput | boolean
    connect?: mock_testsWhereUniqueInput
    update?: XOR<XOR<mock_testsUpdateToOneWithWhereWithoutMock_attemptsInput, mock_testsUpdateWithoutMock_attemptsInput>, mock_testsUncheckedUpdateWithoutMock_attemptsInput>
  }

  export type usersUpdateOneWithoutMock_attemptsNestedInput = {
    create?: XOR<usersCreateWithoutMock_attemptsInput, usersUncheckedCreateWithoutMock_attemptsInput>
    connectOrCreate?: usersCreateOrConnectWithoutMock_attemptsInput
    upsert?: usersUpsertWithoutMock_attemptsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutMock_attemptsInput, usersUpdateWithoutMock_attemptsInput>, usersUncheckedUpdateWithoutMock_attemptsInput>
  }

  export type mock_seriesCreateNestedManyWithoutMock_categoriesInput = {
    create?: XOR<mock_seriesCreateWithoutMock_categoriesInput, mock_seriesUncheckedCreateWithoutMock_categoriesInput> | mock_seriesCreateWithoutMock_categoriesInput[] | mock_seriesUncheckedCreateWithoutMock_categoriesInput[]
    connectOrCreate?: mock_seriesCreateOrConnectWithoutMock_categoriesInput | mock_seriesCreateOrConnectWithoutMock_categoriesInput[]
    createMany?: mock_seriesCreateManyMock_categoriesInputEnvelope
    connect?: mock_seriesWhereUniqueInput | mock_seriesWhereUniqueInput[]
  }

  export type mock_seriesUncheckedCreateNestedManyWithoutMock_categoriesInput = {
    create?: XOR<mock_seriesCreateWithoutMock_categoriesInput, mock_seriesUncheckedCreateWithoutMock_categoriesInput> | mock_seriesCreateWithoutMock_categoriesInput[] | mock_seriesUncheckedCreateWithoutMock_categoriesInput[]
    connectOrCreate?: mock_seriesCreateOrConnectWithoutMock_categoriesInput | mock_seriesCreateOrConnectWithoutMock_categoriesInput[]
    createMany?: mock_seriesCreateManyMock_categoriesInputEnvelope
    connect?: mock_seriesWhereUniqueInput | mock_seriesWhereUniqueInput[]
  }

  export type mock_seriesUpdateManyWithoutMock_categoriesNestedInput = {
    create?: XOR<mock_seriesCreateWithoutMock_categoriesInput, mock_seriesUncheckedCreateWithoutMock_categoriesInput> | mock_seriesCreateWithoutMock_categoriesInput[] | mock_seriesUncheckedCreateWithoutMock_categoriesInput[]
    connectOrCreate?: mock_seriesCreateOrConnectWithoutMock_categoriesInput | mock_seriesCreateOrConnectWithoutMock_categoriesInput[]
    upsert?: mock_seriesUpsertWithWhereUniqueWithoutMock_categoriesInput | mock_seriesUpsertWithWhereUniqueWithoutMock_categoriesInput[]
    createMany?: mock_seriesCreateManyMock_categoriesInputEnvelope
    set?: mock_seriesWhereUniqueInput | mock_seriesWhereUniqueInput[]
    disconnect?: mock_seriesWhereUniqueInput | mock_seriesWhereUniqueInput[]
    delete?: mock_seriesWhereUniqueInput | mock_seriesWhereUniqueInput[]
    connect?: mock_seriesWhereUniqueInput | mock_seriesWhereUniqueInput[]
    update?: mock_seriesUpdateWithWhereUniqueWithoutMock_categoriesInput | mock_seriesUpdateWithWhereUniqueWithoutMock_categoriesInput[]
    updateMany?: mock_seriesUpdateManyWithWhereWithoutMock_categoriesInput | mock_seriesUpdateManyWithWhereWithoutMock_categoriesInput[]
    deleteMany?: mock_seriesScalarWhereInput | mock_seriesScalarWhereInput[]
  }

  export type mock_seriesUncheckedUpdateManyWithoutMock_categoriesNestedInput = {
    create?: XOR<mock_seriesCreateWithoutMock_categoriesInput, mock_seriesUncheckedCreateWithoutMock_categoriesInput> | mock_seriesCreateWithoutMock_categoriesInput[] | mock_seriesUncheckedCreateWithoutMock_categoriesInput[]
    connectOrCreate?: mock_seriesCreateOrConnectWithoutMock_categoriesInput | mock_seriesCreateOrConnectWithoutMock_categoriesInput[]
    upsert?: mock_seriesUpsertWithWhereUniqueWithoutMock_categoriesInput | mock_seriesUpsertWithWhereUniqueWithoutMock_categoriesInput[]
    createMany?: mock_seriesCreateManyMock_categoriesInputEnvelope
    set?: mock_seriesWhereUniqueInput | mock_seriesWhereUniqueInput[]
    disconnect?: mock_seriesWhereUniqueInput | mock_seriesWhereUniqueInput[]
    delete?: mock_seriesWhereUniqueInput | mock_seriesWhereUniqueInput[]
    connect?: mock_seriesWhereUniqueInput | mock_seriesWhereUniqueInput[]
    update?: mock_seriesUpdateWithWhereUniqueWithoutMock_categoriesInput | mock_seriesUpdateWithWhereUniqueWithoutMock_categoriesInput[]
    updateMany?: mock_seriesUpdateManyWithWhereWithoutMock_categoriesInput | mock_seriesUpdateManyWithWhereWithoutMock_categoriesInput[]
    deleteMany?: mock_seriesScalarWhereInput | mock_seriesScalarWhereInput[]
  }

  export type mock_testsCreateNestedOneWithoutMock_questionsInput = {
    create?: XOR<mock_testsCreateWithoutMock_questionsInput, mock_testsUncheckedCreateWithoutMock_questionsInput>
    connectOrCreate?: mock_testsCreateOrConnectWithoutMock_questionsInput
    connect?: mock_testsWhereUniqueInput
  }

  export type NullableEnumquestion_typeFieldUpdateOperationsInput = {
    set?: $Enums.question_type | null
  }

  export type mock_testsUpdateOneWithoutMock_questionsNestedInput = {
    create?: XOR<mock_testsCreateWithoutMock_questionsInput, mock_testsUncheckedCreateWithoutMock_questionsInput>
    connectOrCreate?: mock_testsCreateOrConnectWithoutMock_questionsInput
    upsert?: mock_testsUpsertWithoutMock_questionsInput
    disconnect?: mock_testsWhereInput | boolean
    delete?: mock_testsWhereInput | boolean
    connect?: mock_testsWhereUniqueInput
    update?: XOR<XOR<mock_testsUpdateToOneWithWhereWithoutMock_questionsInput, mock_testsUpdateWithoutMock_questionsInput>, mock_testsUncheckedUpdateWithoutMock_questionsInput>
  }

  export type mock_categoriesCreateNestedOneWithoutMock_seriesInput = {
    create?: XOR<mock_categoriesCreateWithoutMock_seriesInput, mock_categoriesUncheckedCreateWithoutMock_seriesInput>
    connectOrCreate?: mock_categoriesCreateOrConnectWithoutMock_seriesInput
    connect?: mock_categoriesWhereUniqueInput
  }

  export type mock_testsCreateNestedManyWithoutMock_seriesInput = {
    create?: XOR<mock_testsCreateWithoutMock_seriesInput, mock_testsUncheckedCreateWithoutMock_seriesInput> | mock_testsCreateWithoutMock_seriesInput[] | mock_testsUncheckedCreateWithoutMock_seriesInput[]
    connectOrCreate?: mock_testsCreateOrConnectWithoutMock_seriesInput | mock_testsCreateOrConnectWithoutMock_seriesInput[]
    createMany?: mock_testsCreateManyMock_seriesInputEnvelope
    connect?: mock_testsWhereUniqueInput | mock_testsWhereUniqueInput[]
  }

  export type paymentsCreateNestedManyWithoutMock_seriesInput = {
    create?: XOR<paymentsCreateWithoutMock_seriesInput, paymentsUncheckedCreateWithoutMock_seriesInput> | paymentsCreateWithoutMock_seriesInput[] | paymentsUncheckedCreateWithoutMock_seriesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutMock_seriesInput | paymentsCreateOrConnectWithoutMock_seriesInput[]
    createMany?: paymentsCreateManyMock_seriesInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type mock_testsUncheckedCreateNestedManyWithoutMock_seriesInput = {
    create?: XOR<mock_testsCreateWithoutMock_seriesInput, mock_testsUncheckedCreateWithoutMock_seriesInput> | mock_testsCreateWithoutMock_seriesInput[] | mock_testsUncheckedCreateWithoutMock_seriesInput[]
    connectOrCreate?: mock_testsCreateOrConnectWithoutMock_seriesInput | mock_testsCreateOrConnectWithoutMock_seriesInput[]
    createMany?: mock_testsCreateManyMock_seriesInputEnvelope
    connect?: mock_testsWhereUniqueInput | mock_testsWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutMock_seriesInput = {
    create?: XOR<paymentsCreateWithoutMock_seriesInput, paymentsUncheckedCreateWithoutMock_seriesInput> | paymentsCreateWithoutMock_seriesInput[] | paymentsUncheckedCreateWithoutMock_seriesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutMock_seriesInput | paymentsCreateOrConnectWithoutMock_seriesInput[]
    createMany?: paymentsCreateManyMock_seriesInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type mock_categoriesUpdateOneWithoutMock_seriesNestedInput = {
    create?: XOR<mock_categoriesCreateWithoutMock_seriesInput, mock_categoriesUncheckedCreateWithoutMock_seriesInput>
    connectOrCreate?: mock_categoriesCreateOrConnectWithoutMock_seriesInput
    upsert?: mock_categoriesUpsertWithoutMock_seriesInput
    disconnect?: mock_categoriesWhereInput | boolean
    delete?: mock_categoriesWhereInput | boolean
    connect?: mock_categoriesWhereUniqueInput
    update?: XOR<XOR<mock_categoriesUpdateToOneWithWhereWithoutMock_seriesInput, mock_categoriesUpdateWithoutMock_seriesInput>, mock_categoriesUncheckedUpdateWithoutMock_seriesInput>
  }

  export type mock_testsUpdateManyWithoutMock_seriesNestedInput = {
    create?: XOR<mock_testsCreateWithoutMock_seriesInput, mock_testsUncheckedCreateWithoutMock_seriesInput> | mock_testsCreateWithoutMock_seriesInput[] | mock_testsUncheckedCreateWithoutMock_seriesInput[]
    connectOrCreate?: mock_testsCreateOrConnectWithoutMock_seriesInput | mock_testsCreateOrConnectWithoutMock_seriesInput[]
    upsert?: mock_testsUpsertWithWhereUniqueWithoutMock_seriesInput | mock_testsUpsertWithWhereUniqueWithoutMock_seriesInput[]
    createMany?: mock_testsCreateManyMock_seriesInputEnvelope
    set?: mock_testsWhereUniqueInput | mock_testsWhereUniqueInput[]
    disconnect?: mock_testsWhereUniqueInput | mock_testsWhereUniqueInput[]
    delete?: mock_testsWhereUniqueInput | mock_testsWhereUniqueInput[]
    connect?: mock_testsWhereUniqueInput | mock_testsWhereUniqueInput[]
    update?: mock_testsUpdateWithWhereUniqueWithoutMock_seriesInput | mock_testsUpdateWithWhereUniqueWithoutMock_seriesInput[]
    updateMany?: mock_testsUpdateManyWithWhereWithoutMock_seriesInput | mock_testsUpdateManyWithWhereWithoutMock_seriesInput[]
    deleteMany?: mock_testsScalarWhereInput | mock_testsScalarWhereInput[]
  }

  export type paymentsUpdateManyWithoutMock_seriesNestedInput = {
    create?: XOR<paymentsCreateWithoutMock_seriesInput, paymentsUncheckedCreateWithoutMock_seriesInput> | paymentsCreateWithoutMock_seriesInput[] | paymentsUncheckedCreateWithoutMock_seriesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutMock_seriesInput | paymentsCreateOrConnectWithoutMock_seriesInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutMock_seriesInput | paymentsUpsertWithWhereUniqueWithoutMock_seriesInput[]
    createMany?: paymentsCreateManyMock_seriesInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutMock_seriesInput | paymentsUpdateWithWhereUniqueWithoutMock_seriesInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutMock_seriesInput | paymentsUpdateManyWithWhereWithoutMock_seriesInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type mock_testsUncheckedUpdateManyWithoutMock_seriesNestedInput = {
    create?: XOR<mock_testsCreateWithoutMock_seriesInput, mock_testsUncheckedCreateWithoutMock_seriesInput> | mock_testsCreateWithoutMock_seriesInput[] | mock_testsUncheckedCreateWithoutMock_seriesInput[]
    connectOrCreate?: mock_testsCreateOrConnectWithoutMock_seriesInput | mock_testsCreateOrConnectWithoutMock_seriesInput[]
    upsert?: mock_testsUpsertWithWhereUniqueWithoutMock_seriesInput | mock_testsUpsertWithWhereUniqueWithoutMock_seriesInput[]
    createMany?: mock_testsCreateManyMock_seriesInputEnvelope
    set?: mock_testsWhereUniqueInput | mock_testsWhereUniqueInput[]
    disconnect?: mock_testsWhereUniqueInput | mock_testsWhereUniqueInput[]
    delete?: mock_testsWhereUniqueInput | mock_testsWhereUniqueInput[]
    connect?: mock_testsWhereUniqueInput | mock_testsWhereUniqueInput[]
    update?: mock_testsUpdateWithWhereUniqueWithoutMock_seriesInput | mock_testsUpdateWithWhereUniqueWithoutMock_seriesInput[]
    updateMany?: mock_testsUpdateManyWithWhereWithoutMock_seriesInput | mock_testsUpdateManyWithWhereWithoutMock_seriesInput[]
    deleteMany?: mock_testsScalarWhereInput | mock_testsScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutMock_seriesNestedInput = {
    create?: XOR<paymentsCreateWithoutMock_seriesInput, paymentsUncheckedCreateWithoutMock_seriesInput> | paymentsCreateWithoutMock_seriesInput[] | paymentsUncheckedCreateWithoutMock_seriesInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutMock_seriesInput | paymentsCreateOrConnectWithoutMock_seriesInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutMock_seriesInput | paymentsUpsertWithWhereUniqueWithoutMock_seriesInput[]
    createMany?: paymentsCreateManyMock_seriesInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutMock_seriesInput | paymentsUpdateWithWhereUniqueWithoutMock_seriesInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutMock_seriesInput | paymentsUpdateManyWithWhereWithoutMock_seriesInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type mock_attemptsCreateNestedManyWithoutMock_testsInput = {
    create?: XOR<mock_attemptsCreateWithoutMock_testsInput, mock_attemptsUncheckedCreateWithoutMock_testsInput> | mock_attemptsCreateWithoutMock_testsInput[] | mock_attemptsUncheckedCreateWithoutMock_testsInput[]
    connectOrCreate?: mock_attemptsCreateOrConnectWithoutMock_testsInput | mock_attemptsCreateOrConnectWithoutMock_testsInput[]
    createMany?: mock_attemptsCreateManyMock_testsInputEnvelope
    connect?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
  }

  export type mock_questionsCreateNestedManyWithoutMock_testsInput = {
    create?: XOR<mock_questionsCreateWithoutMock_testsInput, mock_questionsUncheckedCreateWithoutMock_testsInput> | mock_questionsCreateWithoutMock_testsInput[] | mock_questionsUncheckedCreateWithoutMock_testsInput[]
    connectOrCreate?: mock_questionsCreateOrConnectWithoutMock_testsInput | mock_questionsCreateOrConnectWithoutMock_testsInput[]
    createMany?: mock_questionsCreateManyMock_testsInputEnvelope
    connect?: mock_questionsWhereUniqueInput | mock_questionsWhereUniqueInput[]
  }

  export type mock_seriesCreateNestedOneWithoutMock_testsInput = {
    create?: XOR<mock_seriesCreateWithoutMock_testsInput, mock_seriesUncheckedCreateWithoutMock_testsInput>
    connectOrCreate?: mock_seriesCreateOrConnectWithoutMock_testsInput
    connect?: mock_seriesWhereUniqueInput
  }

  export type mock_attemptsUncheckedCreateNestedManyWithoutMock_testsInput = {
    create?: XOR<mock_attemptsCreateWithoutMock_testsInput, mock_attemptsUncheckedCreateWithoutMock_testsInput> | mock_attemptsCreateWithoutMock_testsInput[] | mock_attemptsUncheckedCreateWithoutMock_testsInput[]
    connectOrCreate?: mock_attemptsCreateOrConnectWithoutMock_testsInput | mock_attemptsCreateOrConnectWithoutMock_testsInput[]
    createMany?: mock_attemptsCreateManyMock_testsInputEnvelope
    connect?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
  }

  export type mock_questionsUncheckedCreateNestedManyWithoutMock_testsInput = {
    create?: XOR<mock_questionsCreateWithoutMock_testsInput, mock_questionsUncheckedCreateWithoutMock_testsInput> | mock_questionsCreateWithoutMock_testsInput[] | mock_questionsUncheckedCreateWithoutMock_testsInput[]
    connectOrCreate?: mock_questionsCreateOrConnectWithoutMock_testsInput | mock_questionsCreateOrConnectWithoutMock_testsInput[]
    createMany?: mock_questionsCreateManyMock_testsInputEnvelope
    connect?: mock_questionsWhereUniqueInput | mock_questionsWhereUniqueInput[]
  }

  export type mock_attemptsUpdateManyWithoutMock_testsNestedInput = {
    create?: XOR<mock_attemptsCreateWithoutMock_testsInput, mock_attemptsUncheckedCreateWithoutMock_testsInput> | mock_attemptsCreateWithoutMock_testsInput[] | mock_attemptsUncheckedCreateWithoutMock_testsInput[]
    connectOrCreate?: mock_attemptsCreateOrConnectWithoutMock_testsInput | mock_attemptsCreateOrConnectWithoutMock_testsInput[]
    upsert?: mock_attemptsUpsertWithWhereUniqueWithoutMock_testsInput | mock_attemptsUpsertWithWhereUniqueWithoutMock_testsInput[]
    createMany?: mock_attemptsCreateManyMock_testsInputEnvelope
    set?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
    disconnect?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
    delete?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
    connect?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
    update?: mock_attemptsUpdateWithWhereUniqueWithoutMock_testsInput | mock_attemptsUpdateWithWhereUniqueWithoutMock_testsInput[]
    updateMany?: mock_attemptsUpdateManyWithWhereWithoutMock_testsInput | mock_attemptsUpdateManyWithWhereWithoutMock_testsInput[]
    deleteMany?: mock_attemptsScalarWhereInput | mock_attemptsScalarWhereInput[]
  }

  export type mock_questionsUpdateManyWithoutMock_testsNestedInput = {
    create?: XOR<mock_questionsCreateWithoutMock_testsInput, mock_questionsUncheckedCreateWithoutMock_testsInput> | mock_questionsCreateWithoutMock_testsInput[] | mock_questionsUncheckedCreateWithoutMock_testsInput[]
    connectOrCreate?: mock_questionsCreateOrConnectWithoutMock_testsInput | mock_questionsCreateOrConnectWithoutMock_testsInput[]
    upsert?: mock_questionsUpsertWithWhereUniqueWithoutMock_testsInput | mock_questionsUpsertWithWhereUniqueWithoutMock_testsInput[]
    createMany?: mock_questionsCreateManyMock_testsInputEnvelope
    set?: mock_questionsWhereUniqueInput | mock_questionsWhereUniqueInput[]
    disconnect?: mock_questionsWhereUniqueInput | mock_questionsWhereUniqueInput[]
    delete?: mock_questionsWhereUniqueInput | mock_questionsWhereUniqueInput[]
    connect?: mock_questionsWhereUniqueInput | mock_questionsWhereUniqueInput[]
    update?: mock_questionsUpdateWithWhereUniqueWithoutMock_testsInput | mock_questionsUpdateWithWhereUniqueWithoutMock_testsInput[]
    updateMany?: mock_questionsUpdateManyWithWhereWithoutMock_testsInput | mock_questionsUpdateManyWithWhereWithoutMock_testsInput[]
    deleteMany?: mock_questionsScalarWhereInput | mock_questionsScalarWhereInput[]
  }

  export type mock_seriesUpdateOneWithoutMock_testsNestedInput = {
    create?: XOR<mock_seriesCreateWithoutMock_testsInput, mock_seriesUncheckedCreateWithoutMock_testsInput>
    connectOrCreate?: mock_seriesCreateOrConnectWithoutMock_testsInput
    upsert?: mock_seriesUpsertWithoutMock_testsInput
    disconnect?: mock_seriesWhereInput | boolean
    delete?: mock_seriesWhereInput | boolean
    connect?: mock_seriesWhereUniqueInput
    update?: XOR<XOR<mock_seriesUpdateToOneWithWhereWithoutMock_testsInput, mock_seriesUpdateWithoutMock_testsInput>, mock_seriesUncheckedUpdateWithoutMock_testsInput>
  }

  export type mock_attemptsUncheckedUpdateManyWithoutMock_testsNestedInput = {
    create?: XOR<mock_attemptsCreateWithoutMock_testsInput, mock_attemptsUncheckedCreateWithoutMock_testsInput> | mock_attemptsCreateWithoutMock_testsInput[] | mock_attemptsUncheckedCreateWithoutMock_testsInput[]
    connectOrCreate?: mock_attemptsCreateOrConnectWithoutMock_testsInput | mock_attemptsCreateOrConnectWithoutMock_testsInput[]
    upsert?: mock_attemptsUpsertWithWhereUniqueWithoutMock_testsInput | mock_attemptsUpsertWithWhereUniqueWithoutMock_testsInput[]
    createMany?: mock_attemptsCreateManyMock_testsInputEnvelope
    set?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
    disconnect?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
    delete?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
    connect?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
    update?: mock_attemptsUpdateWithWhereUniqueWithoutMock_testsInput | mock_attemptsUpdateWithWhereUniqueWithoutMock_testsInput[]
    updateMany?: mock_attemptsUpdateManyWithWhereWithoutMock_testsInput | mock_attemptsUpdateManyWithWhereWithoutMock_testsInput[]
    deleteMany?: mock_attemptsScalarWhereInput | mock_attemptsScalarWhereInput[]
  }

  export type mock_questionsUncheckedUpdateManyWithoutMock_testsNestedInput = {
    create?: XOR<mock_questionsCreateWithoutMock_testsInput, mock_questionsUncheckedCreateWithoutMock_testsInput> | mock_questionsCreateWithoutMock_testsInput[] | mock_questionsUncheckedCreateWithoutMock_testsInput[]
    connectOrCreate?: mock_questionsCreateOrConnectWithoutMock_testsInput | mock_questionsCreateOrConnectWithoutMock_testsInput[]
    upsert?: mock_questionsUpsertWithWhereUniqueWithoutMock_testsInput | mock_questionsUpsertWithWhereUniqueWithoutMock_testsInput[]
    createMany?: mock_questionsCreateManyMock_testsInputEnvelope
    set?: mock_questionsWhereUniqueInput | mock_questionsWhereUniqueInput[]
    disconnect?: mock_questionsWhereUniqueInput | mock_questionsWhereUniqueInput[]
    delete?: mock_questionsWhereUniqueInput | mock_questionsWhereUniqueInput[]
    connect?: mock_questionsWhereUniqueInput | mock_questionsWhereUniqueInput[]
    update?: mock_questionsUpdateWithWhereUniqueWithoutMock_testsInput | mock_questionsUpdateWithWhereUniqueWithoutMock_testsInput[]
    updateMany?: mock_questionsUpdateManyWithWhereWithoutMock_testsInput | mock_questionsUpdateManyWithWhereWithoutMock_testsInput[]
    deleteMany?: mock_questionsScalarWhereInput | mock_questionsScalarWhereInput[]
  }

  export type coursesCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<coursesCreateWithoutPaymentsInput, coursesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: coursesCreateOrConnectWithoutPaymentsInput
    connect?: coursesWhereUniqueInput
  }

  export type mock_seriesCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<mock_seriesCreateWithoutPaymentsInput, mock_seriesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: mock_seriesCreateOrConnectWithoutPaymentsInput
    connect?: mock_seriesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPaymentsInput
    connect?: usersWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableEnumpayment_statusFieldUpdateOperationsInput = {
    set?: $Enums.payment_status | null
  }

  export type coursesUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<coursesCreateWithoutPaymentsInput, coursesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: coursesCreateOrConnectWithoutPaymentsInput
    upsert?: coursesUpsertWithoutPaymentsInput
    disconnect?: coursesWhereInput | boolean
    delete?: coursesWhereInput | boolean
    connect?: coursesWhereUniqueInput
    update?: XOR<XOR<coursesUpdateToOneWithWhereWithoutPaymentsInput, coursesUpdateWithoutPaymentsInput>, coursesUncheckedUpdateWithoutPaymentsInput>
  }

  export type mock_seriesUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<mock_seriesCreateWithoutPaymentsInput, mock_seriesUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: mock_seriesCreateOrConnectWithoutPaymentsInput
    upsert?: mock_seriesUpsertWithoutPaymentsInput
    disconnect?: mock_seriesWhereInput | boolean
    delete?: mock_seriesWhereInput | boolean
    connect?: mock_seriesWhereUniqueInput
    update?: XOR<XOR<mock_seriesUpdateToOneWithWhereWithoutPaymentsInput, mock_seriesUpdateWithoutPaymentsInput>, mock_seriesUncheckedUpdateWithoutPaymentsInput>
  }

  export type usersUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPaymentsInput
    upsert?: usersUpsertWithoutPaymentsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPaymentsInput, usersUpdateWithoutPaymentsInput>, usersUncheckedUpdateWithoutPaymentsInput>
  }

  export type postsCreateNestedOneWithoutPost_tagsInput = {
    create?: XOR<postsCreateWithoutPost_tagsInput, postsUncheckedCreateWithoutPost_tagsInput>
    connectOrCreate?: postsCreateOrConnectWithoutPost_tagsInput
    connect?: postsWhereUniqueInput
  }

  export type tagsCreateNestedOneWithoutPost_tagsInput = {
    create?: XOR<tagsCreateWithoutPost_tagsInput, tagsUncheckedCreateWithoutPost_tagsInput>
    connectOrCreate?: tagsCreateOrConnectWithoutPost_tagsInput
    connect?: tagsWhereUniqueInput
  }

  export type postsUpdateOneRequiredWithoutPost_tagsNestedInput = {
    create?: XOR<postsCreateWithoutPost_tagsInput, postsUncheckedCreateWithoutPost_tagsInput>
    connectOrCreate?: postsCreateOrConnectWithoutPost_tagsInput
    upsert?: postsUpsertWithoutPost_tagsInput
    connect?: postsWhereUniqueInput
    update?: XOR<XOR<postsUpdateToOneWithWhereWithoutPost_tagsInput, postsUpdateWithoutPost_tagsInput>, postsUncheckedUpdateWithoutPost_tagsInput>
  }

  export type tagsUpdateOneRequiredWithoutPost_tagsNestedInput = {
    create?: XOR<tagsCreateWithoutPost_tagsInput, tagsUncheckedCreateWithoutPost_tagsInput>
    connectOrCreate?: tagsCreateOrConnectWithoutPost_tagsInput
    upsert?: tagsUpsertWithoutPost_tagsInput
    connect?: tagsWhereUniqueInput
    update?: XOR<XOR<tagsUpdateToOneWithWhereWithoutPost_tagsInput, tagsUpdateWithoutPost_tagsInput>, tagsUncheckedUpdateWithoutPost_tagsInput>
  }

  export type postsCreateNestedManyWithoutPost_templatesInput = {
    create?: XOR<postsCreateWithoutPost_templatesInput, postsUncheckedCreateWithoutPost_templatesInput> | postsCreateWithoutPost_templatesInput[] | postsUncheckedCreateWithoutPost_templatesInput[]
    connectOrCreate?: postsCreateOrConnectWithoutPost_templatesInput | postsCreateOrConnectWithoutPost_templatesInput[]
    createMany?: postsCreateManyPost_templatesInputEnvelope
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
  }

  export type postsUncheckedCreateNestedManyWithoutPost_templatesInput = {
    create?: XOR<postsCreateWithoutPost_templatesInput, postsUncheckedCreateWithoutPost_templatesInput> | postsCreateWithoutPost_templatesInput[] | postsUncheckedCreateWithoutPost_templatesInput[]
    connectOrCreate?: postsCreateOrConnectWithoutPost_templatesInput | postsCreateOrConnectWithoutPost_templatesInput[]
    createMany?: postsCreateManyPost_templatesInputEnvelope
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
  }

  export type postsUpdateManyWithoutPost_templatesNestedInput = {
    create?: XOR<postsCreateWithoutPost_templatesInput, postsUncheckedCreateWithoutPost_templatesInput> | postsCreateWithoutPost_templatesInput[] | postsUncheckedCreateWithoutPost_templatesInput[]
    connectOrCreate?: postsCreateOrConnectWithoutPost_templatesInput | postsCreateOrConnectWithoutPost_templatesInput[]
    upsert?: postsUpsertWithWhereUniqueWithoutPost_templatesInput | postsUpsertWithWhereUniqueWithoutPost_templatesInput[]
    createMany?: postsCreateManyPost_templatesInputEnvelope
    set?: postsWhereUniqueInput | postsWhereUniqueInput[]
    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    update?: postsUpdateWithWhereUniqueWithoutPost_templatesInput | postsUpdateWithWhereUniqueWithoutPost_templatesInput[]
    updateMany?: postsUpdateManyWithWhereWithoutPost_templatesInput | postsUpdateManyWithWhereWithoutPost_templatesInput[]
    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]
  }

  export type postsUncheckedUpdateManyWithoutPost_templatesNestedInput = {
    create?: XOR<postsCreateWithoutPost_templatesInput, postsUncheckedCreateWithoutPost_templatesInput> | postsCreateWithoutPost_templatesInput[] | postsUncheckedCreateWithoutPost_templatesInput[]
    connectOrCreate?: postsCreateOrConnectWithoutPost_templatesInput | postsCreateOrConnectWithoutPost_templatesInput[]
    upsert?: postsUpsertWithWhereUniqueWithoutPost_templatesInput | postsUpsertWithWhereUniqueWithoutPost_templatesInput[]
    createMany?: postsCreateManyPost_templatesInputEnvelope
    set?: postsWhereUniqueInput | postsWhereUniqueInput[]
    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    update?: postsUpdateWithWhereUniqueWithoutPost_templatesInput | postsUpdateWithWhereUniqueWithoutPost_templatesInput[]
    updateMany?: postsUpdateManyWithWhereWithoutPost_templatesInput | postsUpdateManyWithWhereWithoutPost_templatesInput[]
    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]
  }

  export type commentsCreateNestedManyWithoutPostsInput = {
    create?: XOR<commentsCreateWithoutPostsInput, commentsUncheckedCreateWithoutPostsInput> | commentsCreateWithoutPostsInput[] | commentsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutPostsInput | commentsCreateOrConnectWithoutPostsInput[]
    createMany?: commentsCreateManyPostsInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type post_tagsCreateNestedManyWithoutPostsInput = {
    create?: XOR<post_tagsCreateWithoutPostsInput, post_tagsUncheckedCreateWithoutPostsInput> | post_tagsCreateWithoutPostsInput[] | post_tagsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: post_tagsCreateOrConnectWithoutPostsInput | post_tagsCreateOrConnectWithoutPostsInput[]
    createMany?: post_tagsCreateManyPostsInputEnvelope
    connect?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
  }

  export type categoriesCreateNestedOneWithoutPostsInput = {
    create?: XOR<categoriesCreateWithoutPostsInput, categoriesUncheckedCreateWithoutPostsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutPostsInput
    connect?: categoriesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutPostsInput = {
    create?: XOR<usersCreateWithoutPostsInput, usersUncheckedCreateWithoutPostsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPostsInput
    connect?: usersWhereUniqueInput
  }

  export type post_templatesCreateNestedOneWithoutPostsInput = {
    create?: XOR<post_templatesCreateWithoutPostsInput, post_templatesUncheckedCreateWithoutPostsInput>
    connectOrCreate?: post_templatesCreateOrConnectWithoutPostsInput
    connect?: post_templatesWhereUniqueInput
  }

  export type commentsUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<commentsCreateWithoutPostsInput, commentsUncheckedCreateWithoutPostsInput> | commentsCreateWithoutPostsInput[] | commentsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutPostsInput | commentsCreateOrConnectWithoutPostsInput[]
    createMany?: commentsCreateManyPostsInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type post_tagsUncheckedCreateNestedManyWithoutPostsInput = {
    create?: XOR<post_tagsCreateWithoutPostsInput, post_tagsUncheckedCreateWithoutPostsInput> | post_tagsCreateWithoutPostsInput[] | post_tagsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: post_tagsCreateOrConnectWithoutPostsInput | post_tagsCreateOrConnectWithoutPostsInput[]
    createMany?: post_tagsCreateManyPostsInputEnvelope
    connect?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
  }

  export type commentsUpdateManyWithoutPostsNestedInput = {
    create?: XOR<commentsCreateWithoutPostsInput, commentsUncheckedCreateWithoutPostsInput> | commentsCreateWithoutPostsInput[] | commentsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutPostsInput | commentsCreateOrConnectWithoutPostsInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutPostsInput | commentsUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: commentsCreateManyPostsInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutPostsInput | commentsUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutPostsInput | commentsUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type post_tagsUpdateManyWithoutPostsNestedInput = {
    create?: XOR<post_tagsCreateWithoutPostsInput, post_tagsUncheckedCreateWithoutPostsInput> | post_tagsCreateWithoutPostsInput[] | post_tagsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: post_tagsCreateOrConnectWithoutPostsInput | post_tagsCreateOrConnectWithoutPostsInput[]
    upsert?: post_tagsUpsertWithWhereUniqueWithoutPostsInput | post_tagsUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: post_tagsCreateManyPostsInputEnvelope
    set?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
    disconnect?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
    delete?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
    connect?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
    update?: post_tagsUpdateWithWhereUniqueWithoutPostsInput | post_tagsUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: post_tagsUpdateManyWithWhereWithoutPostsInput | post_tagsUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: post_tagsScalarWhereInput | post_tagsScalarWhereInput[]
  }

  export type categoriesUpdateOneWithoutPostsNestedInput = {
    create?: XOR<categoriesCreateWithoutPostsInput, categoriesUncheckedCreateWithoutPostsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutPostsInput
    upsert?: categoriesUpsertWithoutPostsInput
    disconnect?: categoriesWhereInput | boolean
    delete?: categoriesWhereInput | boolean
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutPostsInput, categoriesUpdateWithoutPostsInput>, categoriesUncheckedUpdateWithoutPostsInput>
  }

  export type usersUpdateOneWithoutPostsNestedInput = {
    create?: XOR<usersCreateWithoutPostsInput, usersUncheckedCreateWithoutPostsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPostsInput
    upsert?: usersUpsertWithoutPostsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPostsInput, usersUpdateWithoutPostsInput>, usersUncheckedUpdateWithoutPostsInput>
  }

  export type post_templatesUpdateOneWithoutPostsNestedInput = {
    create?: XOR<post_templatesCreateWithoutPostsInput, post_templatesUncheckedCreateWithoutPostsInput>
    connectOrCreate?: post_templatesCreateOrConnectWithoutPostsInput
    upsert?: post_templatesUpsertWithoutPostsInput
    disconnect?: post_templatesWhereInput | boolean
    delete?: post_templatesWhereInput | boolean
    connect?: post_templatesWhereUniqueInput
    update?: XOR<XOR<post_templatesUpdateToOneWithWhereWithoutPostsInput, post_templatesUpdateWithoutPostsInput>, post_templatesUncheckedUpdateWithoutPostsInput>
  }

  export type commentsUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<commentsCreateWithoutPostsInput, commentsUncheckedCreateWithoutPostsInput> | commentsCreateWithoutPostsInput[] | commentsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutPostsInput | commentsCreateOrConnectWithoutPostsInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutPostsInput | commentsUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: commentsCreateManyPostsInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutPostsInput | commentsUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutPostsInput | commentsUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type post_tagsUncheckedUpdateManyWithoutPostsNestedInput = {
    create?: XOR<post_tagsCreateWithoutPostsInput, post_tagsUncheckedCreateWithoutPostsInput> | post_tagsCreateWithoutPostsInput[] | post_tagsUncheckedCreateWithoutPostsInput[]
    connectOrCreate?: post_tagsCreateOrConnectWithoutPostsInput | post_tagsCreateOrConnectWithoutPostsInput[]
    upsert?: post_tagsUpsertWithWhereUniqueWithoutPostsInput | post_tagsUpsertWithWhereUniqueWithoutPostsInput[]
    createMany?: post_tagsCreateManyPostsInputEnvelope
    set?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
    disconnect?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
    delete?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
    connect?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
    update?: post_tagsUpdateWithWhereUniqueWithoutPostsInput | post_tagsUpdateWithWhereUniqueWithoutPostsInput[]
    updateMany?: post_tagsUpdateManyWithWhereWithoutPostsInput | post_tagsUpdateManyWithWhereWithoutPostsInput[]
    deleteMany?: post_tagsScalarWhereInput | post_tagsScalarWhereInput[]
  }

  export type post_tagsCreateNestedManyWithoutTagsInput = {
    create?: XOR<post_tagsCreateWithoutTagsInput, post_tagsUncheckedCreateWithoutTagsInput> | post_tagsCreateWithoutTagsInput[] | post_tagsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: post_tagsCreateOrConnectWithoutTagsInput | post_tagsCreateOrConnectWithoutTagsInput[]
    createMany?: post_tagsCreateManyTagsInputEnvelope
    connect?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
  }

  export type post_tagsUncheckedCreateNestedManyWithoutTagsInput = {
    create?: XOR<post_tagsCreateWithoutTagsInput, post_tagsUncheckedCreateWithoutTagsInput> | post_tagsCreateWithoutTagsInput[] | post_tagsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: post_tagsCreateOrConnectWithoutTagsInput | post_tagsCreateOrConnectWithoutTagsInput[]
    createMany?: post_tagsCreateManyTagsInputEnvelope
    connect?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
  }

  export type post_tagsUpdateManyWithoutTagsNestedInput = {
    create?: XOR<post_tagsCreateWithoutTagsInput, post_tagsUncheckedCreateWithoutTagsInput> | post_tagsCreateWithoutTagsInput[] | post_tagsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: post_tagsCreateOrConnectWithoutTagsInput | post_tagsCreateOrConnectWithoutTagsInput[]
    upsert?: post_tagsUpsertWithWhereUniqueWithoutTagsInput | post_tagsUpsertWithWhereUniqueWithoutTagsInput[]
    createMany?: post_tagsCreateManyTagsInputEnvelope
    set?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
    disconnect?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
    delete?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
    connect?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
    update?: post_tagsUpdateWithWhereUniqueWithoutTagsInput | post_tagsUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: post_tagsUpdateManyWithWhereWithoutTagsInput | post_tagsUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: post_tagsScalarWhereInput | post_tagsScalarWhereInput[]
  }

  export type post_tagsUncheckedUpdateManyWithoutTagsNestedInput = {
    create?: XOR<post_tagsCreateWithoutTagsInput, post_tagsUncheckedCreateWithoutTagsInput> | post_tagsCreateWithoutTagsInput[] | post_tagsUncheckedCreateWithoutTagsInput[]
    connectOrCreate?: post_tagsCreateOrConnectWithoutTagsInput | post_tagsCreateOrConnectWithoutTagsInput[]
    upsert?: post_tagsUpsertWithWhereUniqueWithoutTagsInput | post_tagsUpsertWithWhereUniqueWithoutTagsInput[]
    createMany?: post_tagsCreateManyTagsInputEnvelope
    set?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
    disconnect?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
    delete?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
    connect?: post_tagsWhereUniqueInput | post_tagsWhereUniqueInput[]
    update?: post_tagsUpdateWithWhereUniqueWithoutTagsInput | post_tagsUpdateWithWhereUniqueWithoutTagsInput[]
    updateMany?: post_tagsUpdateManyWithWhereWithoutTagsInput | post_tagsUpdateManyWithWhereWithoutTagsInput[]
    deleteMany?: post_tagsScalarWhereInput | post_tagsScalarWhereInput[]
  }

  export type commentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput> | commentsCreateWithoutUsersInput[] | commentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUsersInput | commentsCreateOrConnectWithoutUsersInput[]
    createMany?: commentsCreateManyUsersInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type course_reviewsCreateNestedManyWithoutUsersInput = {
    create?: XOR<course_reviewsCreateWithoutUsersInput, course_reviewsUncheckedCreateWithoutUsersInput> | course_reviewsCreateWithoutUsersInput[] | course_reviewsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: course_reviewsCreateOrConnectWithoutUsersInput | course_reviewsCreateOrConnectWithoutUsersInput[]
    createMany?: course_reviewsCreateManyUsersInputEnvelope
    connect?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
  }

  export type enrollmentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<enrollmentsCreateWithoutUsersInput, enrollmentsUncheckedCreateWithoutUsersInput> | enrollmentsCreateWithoutUsersInput[] | enrollmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutUsersInput | enrollmentsCreateOrConnectWithoutUsersInput[]
    createMany?: enrollmentsCreateManyUsersInputEnvelope
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
  }

  export type mock_attemptsCreateNestedManyWithoutUsersInput = {
    create?: XOR<mock_attemptsCreateWithoutUsersInput, mock_attemptsUncheckedCreateWithoutUsersInput> | mock_attemptsCreateWithoutUsersInput[] | mock_attemptsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: mock_attemptsCreateOrConnectWithoutUsersInput | mock_attemptsCreateOrConnectWithoutUsersInput[]
    createMany?: mock_attemptsCreateManyUsersInputEnvelope
    connect?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
  }

  export type paymentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type postsCreateNestedManyWithoutUsersInput = {
    create?: XOR<postsCreateWithoutUsersInput, postsUncheckedCreateWithoutUsersInput> | postsCreateWithoutUsersInput[] | postsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: postsCreateOrConnectWithoutUsersInput | postsCreateOrConnectWithoutUsersInput[]
    createMany?: postsCreateManyUsersInputEnvelope
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
  }

  export type commentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput> | commentsCreateWithoutUsersInput[] | commentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUsersInput | commentsCreateOrConnectWithoutUsersInput[]
    createMany?: commentsCreateManyUsersInputEnvelope
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
  }

  export type course_reviewsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<course_reviewsCreateWithoutUsersInput, course_reviewsUncheckedCreateWithoutUsersInput> | course_reviewsCreateWithoutUsersInput[] | course_reviewsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: course_reviewsCreateOrConnectWithoutUsersInput | course_reviewsCreateOrConnectWithoutUsersInput[]
    createMany?: course_reviewsCreateManyUsersInputEnvelope
    connect?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
  }

  export type enrollmentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<enrollmentsCreateWithoutUsersInput, enrollmentsUncheckedCreateWithoutUsersInput> | enrollmentsCreateWithoutUsersInput[] | enrollmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutUsersInput | enrollmentsCreateOrConnectWithoutUsersInput[]
    createMany?: enrollmentsCreateManyUsersInputEnvelope
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
  }

  export type mock_attemptsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<mock_attemptsCreateWithoutUsersInput, mock_attemptsUncheckedCreateWithoutUsersInput> | mock_attemptsCreateWithoutUsersInput[] | mock_attemptsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: mock_attemptsCreateOrConnectWithoutUsersInput | mock_attemptsCreateOrConnectWithoutUsersInput[]
    createMany?: mock_attemptsCreateManyUsersInputEnvelope
    connect?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type postsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<postsCreateWithoutUsersInput, postsUncheckedCreateWithoutUsersInput> | postsCreateWithoutUsersInput[] | postsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: postsCreateOrConnectWithoutUsersInput | postsCreateOrConnectWithoutUsersInput[]
    createMany?: postsCreateManyUsersInputEnvelope
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
  }

  export type NullableEnumuser_roleFieldUpdateOperationsInput = {
    set?: $Enums.user_role | null
  }

  export type commentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput> | commentsCreateWithoutUsersInput[] | commentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUsersInput | commentsCreateOrConnectWithoutUsersInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutUsersInput | commentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: commentsCreateManyUsersInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutUsersInput | commentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutUsersInput | commentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type course_reviewsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<course_reviewsCreateWithoutUsersInput, course_reviewsUncheckedCreateWithoutUsersInput> | course_reviewsCreateWithoutUsersInput[] | course_reviewsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: course_reviewsCreateOrConnectWithoutUsersInput | course_reviewsCreateOrConnectWithoutUsersInput[]
    upsert?: course_reviewsUpsertWithWhereUniqueWithoutUsersInput | course_reviewsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: course_reviewsCreateManyUsersInputEnvelope
    set?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
    disconnect?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
    delete?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
    connect?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
    update?: course_reviewsUpdateWithWhereUniqueWithoutUsersInput | course_reviewsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: course_reviewsUpdateManyWithWhereWithoutUsersInput | course_reviewsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: course_reviewsScalarWhereInput | course_reviewsScalarWhereInput[]
  }

  export type enrollmentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<enrollmentsCreateWithoutUsersInput, enrollmentsUncheckedCreateWithoutUsersInput> | enrollmentsCreateWithoutUsersInput[] | enrollmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutUsersInput | enrollmentsCreateOrConnectWithoutUsersInput[]
    upsert?: enrollmentsUpsertWithWhereUniqueWithoutUsersInput | enrollmentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: enrollmentsCreateManyUsersInputEnvelope
    set?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    disconnect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    delete?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    update?: enrollmentsUpdateWithWhereUniqueWithoutUsersInput | enrollmentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: enrollmentsUpdateManyWithWhereWithoutUsersInput | enrollmentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
  }

  export type mock_attemptsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<mock_attemptsCreateWithoutUsersInput, mock_attemptsUncheckedCreateWithoutUsersInput> | mock_attemptsCreateWithoutUsersInput[] | mock_attemptsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: mock_attemptsCreateOrConnectWithoutUsersInput | mock_attemptsCreateOrConnectWithoutUsersInput[]
    upsert?: mock_attemptsUpsertWithWhereUniqueWithoutUsersInput | mock_attemptsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: mock_attemptsCreateManyUsersInputEnvelope
    set?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
    disconnect?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
    delete?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
    connect?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
    update?: mock_attemptsUpdateWithWhereUniqueWithoutUsersInput | mock_attemptsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: mock_attemptsUpdateManyWithWhereWithoutUsersInput | mock_attemptsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: mock_attemptsScalarWhereInput | mock_attemptsScalarWhereInput[]
  }

  export type paymentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutUsersInput | paymentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutUsersInput | paymentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutUsersInput | paymentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type postsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<postsCreateWithoutUsersInput, postsUncheckedCreateWithoutUsersInput> | postsCreateWithoutUsersInput[] | postsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: postsCreateOrConnectWithoutUsersInput | postsCreateOrConnectWithoutUsersInput[]
    upsert?: postsUpsertWithWhereUniqueWithoutUsersInput | postsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: postsCreateManyUsersInputEnvelope
    set?: postsWhereUniqueInput | postsWhereUniqueInput[]
    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    update?: postsUpdateWithWhereUniqueWithoutUsersInput | postsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: postsUpdateManyWithWhereWithoutUsersInput | postsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]
  }

  export type commentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput> | commentsCreateWithoutUsersInput[] | commentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: commentsCreateOrConnectWithoutUsersInput | commentsCreateOrConnectWithoutUsersInput[]
    upsert?: commentsUpsertWithWhereUniqueWithoutUsersInput | commentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: commentsCreateManyUsersInputEnvelope
    set?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    disconnect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    delete?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    connect?: commentsWhereUniqueInput | commentsWhereUniqueInput[]
    update?: commentsUpdateWithWhereUniqueWithoutUsersInput | commentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: commentsUpdateManyWithWhereWithoutUsersInput | commentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: commentsScalarWhereInput | commentsScalarWhereInput[]
  }

  export type course_reviewsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<course_reviewsCreateWithoutUsersInput, course_reviewsUncheckedCreateWithoutUsersInput> | course_reviewsCreateWithoutUsersInput[] | course_reviewsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: course_reviewsCreateOrConnectWithoutUsersInput | course_reviewsCreateOrConnectWithoutUsersInput[]
    upsert?: course_reviewsUpsertWithWhereUniqueWithoutUsersInput | course_reviewsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: course_reviewsCreateManyUsersInputEnvelope
    set?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
    disconnect?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
    delete?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
    connect?: course_reviewsWhereUniqueInput | course_reviewsWhereUniqueInput[]
    update?: course_reviewsUpdateWithWhereUniqueWithoutUsersInput | course_reviewsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: course_reviewsUpdateManyWithWhereWithoutUsersInput | course_reviewsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: course_reviewsScalarWhereInput | course_reviewsScalarWhereInput[]
  }

  export type enrollmentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<enrollmentsCreateWithoutUsersInput, enrollmentsUncheckedCreateWithoutUsersInput> | enrollmentsCreateWithoutUsersInput[] | enrollmentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: enrollmentsCreateOrConnectWithoutUsersInput | enrollmentsCreateOrConnectWithoutUsersInput[]
    upsert?: enrollmentsUpsertWithWhereUniqueWithoutUsersInput | enrollmentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: enrollmentsCreateManyUsersInputEnvelope
    set?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    disconnect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    delete?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    connect?: enrollmentsWhereUniqueInput | enrollmentsWhereUniqueInput[]
    update?: enrollmentsUpdateWithWhereUniqueWithoutUsersInput | enrollmentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: enrollmentsUpdateManyWithWhereWithoutUsersInput | enrollmentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
  }

  export type mock_attemptsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<mock_attemptsCreateWithoutUsersInput, mock_attemptsUncheckedCreateWithoutUsersInput> | mock_attemptsCreateWithoutUsersInput[] | mock_attemptsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: mock_attemptsCreateOrConnectWithoutUsersInput | mock_attemptsCreateOrConnectWithoutUsersInput[]
    upsert?: mock_attemptsUpsertWithWhereUniqueWithoutUsersInput | mock_attemptsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: mock_attemptsCreateManyUsersInputEnvelope
    set?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
    disconnect?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
    delete?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
    connect?: mock_attemptsWhereUniqueInput | mock_attemptsWhereUniqueInput[]
    update?: mock_attemptsUpdateWithWhereUniqueWithoutUsersInput | mock_attemptsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: mock_attemptsUpdateManyWithWhereWithoutUsersInput | mock_attemptsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: mock_attemptsScalarWhereInput | mock_attemptsScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutUsersInput | paymentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutUsersInput | paymentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutUsersInput | paymentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type postsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<postsCreateWithoutUsersInput, postsUncheckedCreateWithoutUsersInput> | postsCreateWithoutUsersInput[] | postsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: postsCreateOrConnectWithoutUsersInput | postsCreateOrConnectWithoutUsersInput[]
    upsert?: postsUpsertWithWhereUniqueWithoutUsersInput | postsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: postsCreateManyUsersInputEnvelope
    set?: postsWhereUniqueInput | postsWhereUniqueInput[]
    disconnect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    delete?: postsWhereUniqueInput | postsWhereUniqueInput[]
    connect?: postsWhereUniqueInput | postsWhereUniqueInput[]
    update?: postsUpdateWithWhereUniqueWithoutUsersInput | postsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: postsUpdateManyWithWhereWithoutUsersInput | postsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: postsScalarWhereInput | postsScalarWhereInput[]
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumplan_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.plan_type | Enumplan_typeFieldRefInput<$PrismaModel>
    in?: $Enums.plan_type[] | ListEnumplan_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.plan_type[] | ListEnumplan_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumplan_typeFilter<$PrismaModel> | $Enums.plan_type
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumplan_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.plan_type | Enumplan_typeFieldRefInput<$PrismaModel>
    in?: $Enums.plan_type[] | ListEnumplan_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.plan_type[] | ListEnumplan_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumplan_typeWithAggregatesFilter<$PrismaModel> | $Enums.plan_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumplan_typeFilter<$PrismaModel>
    _max?: NestedEnumplan_typeFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedEnumenrollment_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enrollment_status | Enumenrollment_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enrollment_status[] | ListEnumenrollment_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enrollment_status[] | ListEnumenrollment_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenrollment_statusNullableFilter<$PrismaModel> | $Enums.enrollment_status | null
  }

  export type NestedEnumenrollment_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enrollment_status | Enumenrollment_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.enrollment_status[] | ListEnumenrollment_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enrollment_status[] | ListEnumenrollment_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenrollment_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.enrollment_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenrollment_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumenrollment_statusNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumquestion_typeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.question_type | Enumquestion_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.question_type[] | ListEnumquestion_typeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.question_type[] | ListEnumquestion_typeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumquestion_typeNullableFilter<$PrismaModel> | $Enums.question_type | null
  }

  export type NestedEnumquestion_typeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.question_type | Enumquestion_typeFieldRefInput<$PrismaModel> | null
    in?: $Enums.question_type[] | ListEnumquestion_typeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.question_type[] | ListEnumquestion_typeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumquestion_typeNullableWithAggregatesFilter<$PrismaModel> | $Enums.question_type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumquestion_typeNullableFilter<$PrismaModel>
    _max?: NestedEnumquestion_typeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumpayment_statusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_status | Enumpayment_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_status[] | ListEnumpayment_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.payment_status[] | ListEnumpayment_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpayment_statusNullableFilter<$PrismaModel> | $Enums.payment_status | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumpayment_statusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.payment_status | Enumpayment_statusFieldRefInput<$PrismaModel> | null
    in?: $Enums.payment_status[] | ListEnumpayment_statusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.payment_status[] | ListEnumpayment_statusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumpayment_statusNullableWithAggregatesFilter<$PrismaModel> | $Enums.payment_status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumpayment_statusNullableFilter<$PrismaModel>
    _max?: NestedEnumpayment_statusNullableFilter<$PrismaModel>
  }

  export type NestedEnumuser_roleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumuser_roleNullableFilter<$PrismaModel> | $Enums.user_role | null
  }

  export type NestedEnumuser_roleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.user_role | Enumuser_roleFieldRefInput<$PrismaModel> | null
    in?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.user_role[] | ListEnumuser_roleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumuser_roleNullableWithAggregatesFilter<$PrismaModel> | $Enums.user_role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumuser_roleNullableFilter<$PrismaModel>
    _max?: NestedEnumuser_roleNullableFilter<$PrismaModel>
  }

  export type postsCreateWithoutCategoriesInput = {
    id?: bigint | number
    title: string
    slug: string
    content: string
    external_url?: string | null
    thumbnail_url?: string | null
    published_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: string | null
    comments?: commentsCreateNestedManyWithoutPostsInput
    post_tags?: post_tagsCreateNestedManyWithoutPostsInput
    users?: usersCreateNestedOneWithoutPostsInput
    post_templates?: post_templatesCreateNestedOneWithoutPostsInput
  }

  export type postsUncheckedCreateWithoutCategoriesInput = {
    id?: bigint | number
    title: string
    slug: string
    content: string
    external_url?: string | null
    thumbnail_url?: string | null
    published_at?: Date | string | null
    created_by?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    template_id?: bigint | number | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: string | null
    comments?: commentsUncheckedCreateNestedManyWithoutPostsInput
    post_tags?: post_tagsUncheckedCreateNestedManyWithoutPostsInput
  }

  export type postsCreateOrConnectWithoutCategoriesInput = {
    where: postsWhereUniqueInput
    create: XOR<postsCreateWithoutCategoriesInput, postsUncheckedCreateWithoutCategoriesInput>
  }

  export type postsCreateManyCategoriesInputEnvelope = {
    data: postsCreateManyCategoriesInput | postsCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type postsUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: postsWhereUniqueInput
    update: XOR<postsUpdateWithoutCategoriesInput, postsUncheckedUpdateWithoutCategoriesInput>
    create: XOR<postsCreateWithoutCategoriesInput, postsUncheckedCreateWithoutCategoriesInput>
  }

  export type postsUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: postsWhereUniqueInput
    data: XOR<postsUpdateWithoutCategoriesInput, postsUncheckedUpdateWithoutCategoriesInput>
  }

  export type postsUpdateManyWithWhereWithoutCategoriesInput = {
    where: postsScalarWhereInput
    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type postsScalarWhereInput = {
    AND?: postsScalarWhereInput | postsScalarWhereInput[]
    OR?: postsScalarWhereInput[]
    NOT?: postsScalarWhereInput | postsScalarWhereInput[]
    id?: BigIntFilter<"posts"> | bigint | number
    category_id?: BigIntNullableFilter<"posts"> | bigint | number | null
    title?: StringFilter<"posts"> | string
    slug?: StringFilter<"posts"> | string
    content?: StringFilter<"posts"> | string
    external_url?: StringNullableFilter<"posts"> | string | null
    thumbnail_url?: StringNullableFilter<"posts"> | string | null
    published_at?: DateTimeNullableFilter<"posts"> | Date | string | null
    created_by?: BigIntNullableFilter<"posts"> | bigint | number | null
    created_at?: DateTimeNullableFilter<"posts"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"posts"> | Date | string | null
    template_id?: BigIntNullableFilter<"posts"> | bigint | number | null
    content_json?: JsonNullableFilter<"posts">
    content_html?: StringNullableFilter<"posts"> | string | null
  }

  export type postsCreateWithoutCommentsInput = {
    id?: bigint | number
    title: string
    slug: string
    content: string
    external_url?: string | null
    thumbnail_url?: string | null
    published_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: string | null
    post_tags?: post_tagsCreateNestedManyWithoutPostsInput
    categories?: categoriesCreateNestedOneWithoutPostsInput
    users?: usersCreateNestedOneWithoutPostsInput
    post_templates?: post_templatesCreateNestedOneWithoutPostsInput
  }

  export type postsUncheckedCreateWithoutCommentsInput = {
    id?: bigint | number
    category_id?: bigint | number | null
    title: string
    slug: string
    content: string
    external_url?: string | null
    thumbnail_url?: string | null
    published_at?: Date | string | null
    created_by?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    template_id?: bigint | number | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: string | null
    post_tags?: post_tagsUncheckedCreateNestedManyWithoutPostsInput
  }

  export type postsCreateOrConnectWithoutCommentsInput = {
    where: postsWhereUniqueInput
    create: XOR<postsCreateWithoutCommentsInput, postsUncheckedCreateWithoutCommentsInput>
  }

  export type usersCreateWithoutCommentsInput = {
    id?: bigint | number
    full_name: string
    email: string
    password_hash: string
    role?: $Enums.user_role | null
    created_at?: Date | string | null
    course_reviews?: course_reviewsCreateNestedManyWithoutUsersInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    mock_attempts?: mock_attemptsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    posts?: postsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutCommentsInput = {
    id?: bigint | number
    full_name: string
    email: string
    password_hash: string
    role?: $Enums.user_role | null
    created_at?: Date | string | null
    course_reviews?: course_reviewsUncheckedCreateNestedManyWithoutUsersInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    mock_attempts?: mock_attemptsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    posts?: postsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutCommentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>
  }

  export type postsUpsertWithoutCommentsInput = {
    update: XOR<postsUpdateWithoutCommentsInput, postsUncheckedUpdateWithoutCommentsInput>
    create: XOR<postsCreateWithoutCommentsInput, postsUncheckedCreateWithoutCommentsInput>
    where?: postsWhereInput
  }

  export type postsUpdateToOneWithWhereWithoutCommentsInput = {
    where?: postsWhereInput
    data: XOR<postsUpdateWithoutCommentsInput, postsUncheckedUpdateWithoutCommentsInput>
  }

  export type postsUpdateWithoutCommentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    post_tags?: post_tagsUpdateManyWithoutPostsNestedInput
    categories?: categoriesUpdateOneWithoutPostsNestedInput
    users?: usersUpdateOneWithoutPostsNestedInput
    post_templates?: post_templatesUpdateOneWithoutPostsNestedInput
  }

  export type postsUncheckedUpdateWithoutCommentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    post_tags?: post_tagsUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type usersUpsertWithoutCommentsInput = {
    update: XOR<usersUpdateWithoutCommentsInput, usersUncheckedUpdateWithoutCommentsInput>
    create: XOR<usersCreateWithoutCommentsInput, usersUncheckedCreateWithoutCommentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCommentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCommentsInput, usersUncheckedUpdateWithoutCommentsInput>
  }

  export type usersUpdateWithoutCommentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_reviews?: course_reviewsUpdateManyWithoutUsersNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    mock_attempts?: mock_attemptsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    posts?: postsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutCommentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_reviews?: course_reviewsUncheckedUpdateManyWithoutUsersNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    mock_attempts?: mock_attemptsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    posts?: postsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type coursesCreateWithoutCourse_plansInput = {
    id?: bigint | number
    title: string
    description?: string | null
    thumbnail_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    course_reviews?: course_reviewsCreateNestedManyWithoutCoursesInput
    course_videos?: course_videosCreateNestedManyWithoutCoursesInput
    enrollments?: enrollmentsCreateNestedManyWithoutCoursesInput
    payments?: paymentsCreateNestedManyWithoutCoursesInput
  }

  export type coursesUncheckedCreateWithoutCourse_plansInput = {
    id?: bigint | number
    title: string
    description?: string | null
    thumbnail_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    course_reviews?: course_reviewsUncheckedCreateNestedManyWithoutCoursesInput
    course_videos?: course_videosUncheckedCreateNestedManyWithoutCoursesInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutCoursesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type coursesCreateOrConnectWithoutCourse_plansInput = {
    where: coursesWhereUniqueInput
    create: XOR<coursesCreateWithoutCourse_plansInput, coursesUncheckedCreateWithoutCourse_plansInput>
  }

  export type enrollmentsCreateWithoutCourse_plansInput = {
    id?: bigint | number
    status?: $Enums.enrollment_status | null
    started_at?: Date | string | null
    expires_at?: Date | string | null
    courses?: coursesCreateNestedOneWithoutEnrollmentsInput
    users?: usersCreateNestedOneWithoutEnrollmentsInput
  }

  export type enrollmentsUncheckedCreateWithoutCourse_plansInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    course_id?: bigint | number | null
    status?: $Enums.enrollment_status | null
    started_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type enrollmentsCreateOrConnectWithoutCourse_plansInput = {
    where: enrollmentsWhereUniqueInput
    create: XOR<enrollmentsCreateWithoutCourse_plansInput, enrollmentsUncheckedCreateWithoutCourse_plansInput>
  }

  export type enrollmentsCreateManyCourse_plansInputEnvelope = {
    data: enrollmentsCreateManyCourse_plansInput | enrollmentsCreateManyCourse_plansInput[]
    skipDuplicates?: boolean
  }

  export type coursesUpsertWithoutCourse_plansInput = {
    update: XOR<coursesUpdateWithoutCourse_plansInput, coursesUncheckedUpdateWithoutCourse_plansInput>
    create: XOR<coursesCreateWithoutCourse_plansInput, coursesUncheckedCreateWithoutCourse_plansInput>
    where?: coursesWhereInput
  }

  export type coursesUpdateToOneWithWhereWithoutCourse_plansInput = {
    where?: coursesWhereInput
    data: XOR<coursesUpdateWithoutCourse_plansInput, coursesUncheckedUpdateWithoutCourse_plansInput>
  }

  export type coursesUpdateWithoutCourse_plansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_reviews?: course_reviewsUpdateManyWithoutCoursesNestedInput
    course_videos?: course_videosUpdateManyWithoutCoursesNestedInput
    enrollments?: enrollmentsUpdateManyWithoutCoursesNestedInput
    payments?: paymentsUpdateManyWithoutCoursesNestedInput
  }

  export type coursesUncheckedUpdateWithoutCourse_plansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_reviews?: course_reviewsUncheckedUpdateManyWithoutCoursesNestedInput
    course_videos?: course_videosUncheckedUpdateManyWithoutCoursesNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutCoursesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type enrollmentsUpsertWithWhereUniqueWithoutCourse_plansInput = {
    where: enrollmentsWhereUniqueInput
    update: XOR<enrollmentsUpdateWithoutCourse_plansInput, enrollmentsUncheckedUpdateWithoutCourse_plansInput>
    create: XOR<enrollmentsCreateWithoutCourse_plansInput, enrollmentsUncheckedCreateWithoutCourse_plansInput>
  }

  export type enrollmentsUpdateWithWhereUniqueWithoutCourse_plansInput = {
    where: enrollmentsWhereUniqueInput
    data: XOR<enrollmentsUpdateWithoutCourse_plansInput, enrollmentsUncheckedUpdateWithoutCourse_plansInput>
  }

  export type enrollmentsUpdateManyWithWhereWithoutCourse_plansInput = {
    where: enrollmentsScalarWhereInput
    data: XOR<enrollmentsUpdateManyMutationInput, enrollmentsUncheckedUpdateManyWithoutCourse_plansInput>
  }

  export type enrollmentsScalarWhereInput = {
    AND?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
    OR?: enrollmentsScalarWhereInput[]
    NOT?: enrollmentsScalarWhereInput | enrollmentsScalarWhereInput[]
    id?: BigIntFilter<"enrollments"> | bigint | number
    user_id?: BigIntNullableFilter<"enrollments"> | bigint | number | null
    course_id?: BigIntNullableFilter<"enrollments"> | bigint | number | null
    plan_id?: BigIntNullableFilter<"enrollments"> | bigint | number | null
    status?: Enumenrollment_statusNullableFilter<"enrollments"> | $Enums.enrollment_status | null
    started_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
    expires_at?: DateTimeNullableFilter<"enrollments"> | Date | string | null
  }

  export type coursesCreateWithoutCourse_reviewsInput = {
    id?: bigint | number
    title: string
    description?: string | null
    thumbnail_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    course_plans?: course_plansCreateNestedManyWithoutCoursesInput
    course_videos?: course_videosCreateNestedManyWithoutCoursesInput
    enrollments?: enrollmentsCreateNestedManyWithoutCoursesInput
    payments?: paymentsCreateNestedManyWithoutCoursesInput
  }

  export type coursesUncheckedCreateWithoutCourse_reviewsInput = {
    id?: bigint | number
    title: string
    description?: string | null
    thumbnail_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    course_plans?: course_plansUncheckedCreateNestedManyWithoutCoursesInput
    course_videos?: course_videosUncheckedCreateNestedManyWithoutCoursesInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutCoursesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type coursesCreateOrConnectWithoutCourse_reviewsInput = {
    where: coursesWhereUniqueInput
    create: XOR<coursesCreateWithoutCourse_reviewsInput, coursesUncheckedCreateWithoutCourse_reviewsInput>
  }

  export type usersCreateWithoutCourse_reviewsInput = {
    id?: bigint | number
    full_name: string
    email: string
    password_hash: string
    role?: $Enums.user_role | null
    created_at?: Date | string | null
    comments?: commentsCreateNestedManyWithoutUsersInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    mock_attempts?: mock_attemptsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    posts?: postsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutCourse_reviewsInput = {
    id?: bigint | number
    full_name: string
    email: string
    password_hash: string
    role?: $Enums.user_role | null
    created_at?: Date | string | null
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    mock_attempts?: mock_attemptsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    posts?: postsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutCourse_reviewsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCourse_reviewsInput, usersUncheckedCreateWithoutCourse_reviewsInput>
  }

  export type coursesUpsertWithoutCourse_reviewsInput = {
    update: XOR<coursesUpdateWithoutCourse_reviewsInput, coursesUncheckedUpdateWithoutCourse_reviewsInput>
    create: XOR<coursesCreateWithoutCourse_reviewsInput, coursesUncheckedCreateWithoutCourse_reviewsInput>
    where?: coursesWhereInput
  }

  export type coursesUpdateToOneWithWhereWithoutCourse_reviewsInput = {
    where?: coursesWhereInput
    data: XOR<coursesUpdateWithoutCourse_reviewsInput, coursesUncheckedUpdateWithoutCourse_reviewsInput>
  }

  export type coursesUpdateWithoutCourse_reviewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_plans?: course_plansUpdateManyWithoutCoursesNestedInput
    course_videos?: course_videosUpdateManyWithoutCoursesNestedInput
    enrollments?: enrollmentsUpdateManyWithoutCoursesNestedInput
    payments?: paymentsUpdateManyWithoutCoursesNestedInput
  }

  export type coursesUncheckedUpdateWithoutCourse_reviewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_plans?: course_plansUncheckedUpdateManyWithoutCoursesNestedInput
    course_videos?: course_videosUncheckedUpdateManyWithoutCoursesNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutCoursesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type usersUpsertWithoutCourse_reviewsInput = {
    update: XOR<usersUpdateWithoutCourse_reviewsInput, usersUncheckedUpdateWithoutCourse_reviewsInput>
    create: XOR<usersCreateWithoutCourse_reviewsInput, usersUncheckedCreateWithoutCourse_reviewsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCourse_reviewsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCourse_reviewsInput, usersUncheckedUpdateWithoutCourse_reviewsInput>
  }

  export type usersUpdateWithoutCourse_reviewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: commentsUpdateManyWithoutUsersNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    mock_attempts?: mock_attemptsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    posts?: postsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutCourse_reviewsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    mock_attempts?: mock_attemptsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    posts?: postsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type coursesCreateWithoutCourse_videosInput = {
    id?: bigint | number
    title: string
    description?: string | null
    thumbnail_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    course_plans?: course_plansCreateNestedManyWithoutCoursesInput
    course_reviews?: course_reviewsCreateNestedManyWithoutCoursesInput
    enrollments?: enrollmentsCreateNestedManyWithoutCoursesInput
    payments?: paymentsCreateNestedManyWithoutCoursesInput
  }

  export type coursesUncheckedCreateWithoutCourse_videosInput = {
    id?: bigint | number
    title: string
    description?: string | null
    thumbnail_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    course_plans?: course_plansUncheckedCreateNestedManyWithoutCoursesInput
    course_reviews?: course_reviewsUncheckedCreateNestedManyWithoutCoursesInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutCoursesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type coursesCreateOrConnectWithoutCourse_videosInput = {
    where: coursesWhereUniqueInput
    create: XOR<coursesCreateWithoutCourse_videosInput, coursesUncheckedCreateWithoutCourse_videosInput>
  }

  export type coursesUpsertWithoutCourse_videosInput = {
    update: XOR<coursesUpdateWithoutCourse_videosInput, coursesUncheckedUpdateWithoutCourse_videosInput>
    create: XOR<coursesCreateWithoutCourse_videosInput, coursesUncheckedCreateWithoutCourse_videosInput>
    where?: coursesWhereInput
  }

  export type coursesUpdateToOneWithWhereWithoutCourse_videosInput = {
    where?: coursesWhereInput
    data: XOR<coursesUpdateWithoutCourse_videosInput, coursesUncheckedUpdateWithoutCourse_videosInput>
  }

  export type coursesUpdateWithoutCourse_videosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_plans?: course_plansUpdateManyWithoutCoursesNestedInput
    course_reviews?: course_reviewsUpdateManyWithoutCoursesNestedInput
    enrollments?: enrollmentsUpdateManyWithoutCoursesNestedInput
    payments?: paymentsUpdateManyWithoutCoursesNestedInput
  }

  export type coursesUncheckedUpdateWithoutCourse_videosInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_plans?: course_plansUncheckedUpdateManyWithoutCoursesNestedInput
    course_reviews?: course_reviewsUncheckedUpdateManyWithoutCoursesNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutCoursesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type course_plansCreateWithoutCoursesInput = {
    id?: bigint | number
    plan_type: $Enums.plan_type
    plan_name: string
    price?: Decimal | DecimalJsLike | number | string | null
    duration_days?: number | null
    created_at?: Date | string | null
    enrollments?: enrollmentsCreateNestedManyWithoutCourse_plansInput
  }

  export type course_plansUncheckedCreateWithoutCoursesInput = {
    id?: bigint | number
    plan_type: $Enums.plan_type
    plan_name: string
    price?: Decimal | DecimalJsLike | number | string | null
    duration_days?: number | null
    created_at?: Date | string | null
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutCourse_plansInput
  }

  export type course_plansCreateOrConnectWithoutCoursesInput = {
    where: course_plansWhereUniqueInput
    create: XOR<course_plansCreateWithoutCoursesInput, course_plansUncheckedCreateWithoutCoursesInput>
  }

  export type course_plansCreateManyCoursesInputEnvelope = {
    data: course_plansCreateManyCoursesInput | course_plansCreateManyCoursesInput[]
    skipDuplicates?: boolean
  }

  export type course_reviewsCreateWithoutCoursesInput = {
    id?: bigint | number
    rating?: number | null
    review?: string | null
    created_at?: Date | string | null
    users?: usersCreateNestedOneWithoutCourse_reviewsInput
  }

  export type course_reviewsUncheckedCreateWithoutCoursesInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    rating?: number | null
    review?: string | null
    created_at?: Date | string | null
  }

  export type course_reviewsCreateOrConnectWithoutCoursesInput = {
    where: course_reviewsWhereUniqueInput
    create: XOR<course_reviewsCreateWithoutCoursesInput, course_reviewsUncheckedCreateWithoutCoursesInput>
  }

  export type course_reviewsCreateManyCoursesInputEnvelope = {
    data: course_reviewsCreateManyCoursesInput | course_reviewsCreateManyCoursesInput[]
    skipDuplicates?: boolean
  }

  export type course_videosCreateWithoutCoursesInput = {
    id?: bigint | number
    title: string
    video_url: string
    position: number
    is_demo?: boolean | null
    created_at?: Date | string | null
  }

  export type course_videosUncheckedCreateWithoutCoursesInput = {
    id?: bigint | number
    title: string
    video_url: string
    position: number
    is_demo?: boolean | null
    created_at?: Date | string | null
  }

  export type course_videosCreateOrConnectWithoutCoursesInput = {
    where: course_videosWhereUniqueInput
    create: XOR<course_videosCreateWithoutCoursesInput, course_videosUncheckedCreateWithoutCoursesInput>
  }

  export type course_videosCreateManyCoursesInputEnvelope = {
    data: course_videosCreateManyCoursesInput | course_videosCreateManyCoursesInput[]
    skipDuplicates?: boolean
  }

  export type enrollmentsCreateWithoutCoursesInput = {
    id?: bigint | number
    status?: $Enums.enrollment_status | null
    started_at?: Date | string | null
    expires_at?: Date | string | null
    course_plans?: course_plansCreateNestedOneWithoutEnrollmentsInput
    users?: usersCreateNestedOneWithoutEnrollmentsInput
  }

  export type enrollmentsUncheckedCreateWithoutCoursesInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    plan_id?: bigint | number | null
    status?: $Enums.enrollment_status | null
    started_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type enrollmentsCreateOrConnectWithoutCoursesInput = {
    where: enrollmentsWhereUniqueInput
    create: XOR<enrollmentsCreateWithoutCoursesInput, enrollmentsUncheckedCreateWithoutCoursesInput>
  }

  export type enrollmentsCreateManyCoursesInputEnvelope = {
    data: enrollmentsCreateManyCoursesInput | enrollmentsCreateManyCoursesInput[]
    skipDuplicates?: boolean
  }

  export type paymentsCreateWithoutCoursesInput = {
    id?: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    status?: $Enums.payment_status | null
    transaction_id?: string | null
    created_at?: Date | string | null
    mock_series?: mock_seriesCreateNestedOneWithoutPaymentsInput
    users?: usersCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutCoursesInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    status?: $Enums.payment_status | null
    transaction_id?: string | null
    created_at?: Date | string | null
    mock_series_id?: bigint | number | null
  }

  export type paymentsCreateOrConnectWithoutCoursesInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutCoursesInput, paymentsUncheckedCreateWithoutCoursesInput>
  }

  export type paymentsCreateManyCoursesInputEnvelope = {
    data: paymentsCreateManyCoursesInput | paymentsCreateManyCoursesInput[]
    skipDuplicates?: boolean
  }

  export type course_plansUpsertWithWhereUniqueWithoutCoursesInput = {
    where: course_plansWhereUniqueInput
    update: XOR<course_plansUpdateWithoutCoursesInput, course_plansUncheckedUpdateWithoutCoursesInput>
    create: XOR<course_plansCreateWithoutCoursesInput, course_plansUncheckedCreateWithoutCoursesInput>
  }

  export type course_plansUpdateWithWhereUniqueWithoutCoursesInput = {
    where: course_plansWhereUniqueInput
    data: XOR<course_plansUpdateWithoutCoursesInput, course_plansUncheckedUpdateWithoutCoursesInput>
  }

  export type course_plansUpdateManyWithWhereWithoutCoursesInput = {
    where: course_plansScalarWhereInput
    data: XOR<course_plansUpdateManyMutationInput, course_plansUncheckedUpdateManyWithoutCoursesInput>
  }

  export type course_plansScalarWhereInput = {
    AND?: course_plansScalarWhereInput | course_plansScalarWhereInput[]
    OR?: course_plansScalarWhereInput[]
    NOT?: course_plansScalarWhereInput | course_plansScalarWhereInput[]
    id?: BigIntFilter<"course_plans"> | bigint | number
    course_id?: BigIntNullableFilter<"course_plans"> | bigint | number | null
    plan_type?: Enumplan_typeFilter<"course_plans"> | $Enums.plan_type
    plan_name?: StringFilter<"course_plans"> | string
    price?: DecimalNullableFilter<"course_plans"> | Decimal | DecimalJsLike | number | string | null
    duration_days?: IntNullableFilter<"course_plans"> | number | null
    created_at?: DateTimeNullableFilter<"course_plans"> | Date | string | null
  }

  export type course_reviewsUpsertWithWhereUniqueWithoutCoursesInput = {
    where: course_reviewsWhereUniqueInput
    update: XOR<course_reviewsUpdateWithoutCoursesInput, course_reviewsUncheckedUpdateWithoutCoursesInput>
    create: XOR<course_reviewsCreateWithoutCoursesInput, course_reviewsUncheckedCreateWithoutCoursesInput>
  }

  export type course_reviewsUpdateWithWhereUniqueWithoutCoursesInput = {
    where: course_reviewsWhereUniqueInput
    data: XOR<course_reviewsUpdateWithoutCoursesInput, course_reviewsUncheckedUpdateWithoutCoursesInput>
  }

  export type course_reviewsUpdateManyWithWhereWithoutCoursesInput = {
    where: course_reviewsScalarWhereInput
    data: XOR<course_reviewsUpdateManyMutationInput, course_reviewsUncheckedUpdateManyWithoutCoursesInput>
  }

  export type course_reviewsScalarWhereInput = {
    AND?: course_reviewsScalarWhereInput | course_reviewsScalarWhereInput[]
    OR?: course_reviewsScalarWhereInput[]
    NOT?: course_reviewsScalarWhereInput | course_reviewsScalarWhereInput[]
    id?: BigIntFilter<"course_reviews"> | bigint | number
    course_id?: BigIntNullableFilter<"course_reviews"> | bigint | number | null
    user_id?: BigIntNullableFilter<"course_reviews"> | bigint | number | null
    rating?: IntNullableFilter<"course_reviews"> | number | null
    review?: StringNullableFilter<"course_reviews"> | string | null
    created_at?: DateTimeNullableFilter<"course_reviews"> | Date | string | null
  }

  export type course_videosUpsertWithWhereUniqueWithoutCoursesInput = {
    where: course_videosWhereUniqueInput
    update: XOR<course_videosUpdateWithoutCoursesInput, course_videosUncheckedUpdateWithoutCoursesInput>
    create: XOR<course_videosCreateWithoutCoursesInput, course_videosUncheckedCreateWithoutCoursesInput>
  }

  export type course_videosUpdateWithWhereUniqueWithoutCoursesInput = {
    where: course_videosWhereUniqueInput
    data: XOR<course_videosUpdateWithoutCoursesInput, course_videosUncheckedUpdateWithoutCoursesInput>
  }

  export type course_videosUpdateManyWithWhereWithoutCoursesInput = {
    where: course_videosScalarWhereInput
    data: XOR<course_videosUpdateManyMutationInput, course_videosUncheckedUpdateManyWithoutCoursesInput>
  }

  export type course_videosScalarWhereInput = {
    AND?: course_videosScalarWhereInput | course_videosScalarWhereInput[]
    OR?: course_videosScalarWhereInput[]
    NOT?: course_videosScalarWhereInput | course_videosScalarWhereInput[]
    id?: BigIntFilter<"course_videos"> | bigint | number
    course_id?: BigIntNullableFilter<"course_videos"> | bigint | number | null
    title?: StringFilter<"course_videos"> | string
    video_url?: StringFilter<"course_videos"> | string
    position?: IntFilter<"course_videos"> | number
    is_demo?: BoolNullableFilter<"course_videos"> | boolean | null
    created_at?: DateTimeNullableFilter<"course_videos"> | Date | string | null
  }

  export type enrollmentsUpsertWithWhereUniqueWithoutCoursesInput = {
    where: enrollmentsWhereUniqueInput
    update: XOR<enrollmentsUpdateWithoutCoursesInput, enrollmentsUncheckedUpdateWithoutCoursesInput>
    create: XOR<enrollmentsCreateWithoutCoursesInput, enrollmentsUncheckedCreateWithoutCoursesInput>
  }

  export type enrollmentsUpdateWithWhereUniqueWithoutCoursesInput = {
    where: enrollmentsWhereUniqueInput
    data: XOR<enrollmentsUpdateWithoutCoursesInput, enrollmentsUncheckedUpdateWithoutCoursesInput>
  }

  export type enrollmentsUpdateManyWithWhereWithoutCoursesInput = {
    where: enrollmentsScalarWhereInput
    data: XOR<enrollmentsUpdateManyMutationInput, enrollmentsUncheckedUpdateManyWithoutCoursesInput>
  }

  export type paymentsUpsertWithWhereUniqueWithoutCoursesInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutCoursesInput, paymentsUncheckedUpdateWithoutCoursesInput>
    create: XOR<paymentsCreateWithoutCoursesInput, paymentsUncheckedCreateWithoutCoursesInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutCoursesInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutCoursesInput, paymentsUncheckedUpdateWithoutCoursesInput>
  }

  export type paymentsUpdateManyWithWhereWithoutCoursesInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutCoursesInput>
  }

  export type paymentsScalarWhereInput = {
    AND?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    OR?: paymentsScalarWhereInput[]
    NOT?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    id?: BigIntFilter<"payments"> | bigint | number
    user_id?: BigIntNullableFilter<"payments"> | bigint | number | null
    course_id?: BigIntNullableFilter<"payments"> | bigint | number | null
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_method?: StringFilter<"payments"> | string
    status?: Enumpayment_statusNullableFilter<"payments"> | $Enums.payment_status | null
    transaction_id?: StringNullableFilter<"payments"> | string | null
    created_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    mock_series_id?: BigIntNullableFilter<"payments"> | bigint | number | null
  }

  export type coursesCreateWithoutEnrollmentsInput = {
    id?: bigint | number
    title: string
    description?: string | null
    thumbnail_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    course_plans?: course_plansCreateNestedManyWithoutCoursesInput
    course_reviews?: course_reviewsCreateNestedManyWithoutCoursesInput
    course_videos?: course_videosCreateNestedManyWithoutCoursesInput
    payments?: paymentsCreateNestedManyWithoutCoursesInput
  }

  export type coursesUncheckedCreateWithoutEnrollmentsInput = {
    id?: bigint | number
    title: string
    description?: string | null
    thumbnail_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    course_plans?: course_plansUncheckedCreateNestedManyWithoutCoursesInput
    course_reviews?: course_reviewsUncheckedCreateNestedManyWithoutCoursesInput
    course_videos?: course_videosUncheckedCreateNestedManyWithoutCoursesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type coursesCreateOrConnectWithoutEnrollmentsInput = {
    where: coursesWhereUniqueInput
    create: XOR<coursesCreateWithoutEnrollmentsInput, coursesUncheckedCreateWithoutEnrollmentsInput>
  }

  export type course_plansCreateWithoutEnrollmentsInput = {
    id?: bigint | number
    plan_type: $Enums.plan_type
    plan_name: string
    price?: Decimal | DecimalJsLike | number | string | null
    duration_days?: number | null
    created_at?: Date | string | null
    courses?: coursesCreateNestedOneWithoutCourse_plansInput
  }

  export type course_plansUncheckedCreateWithoutEnrollmentsInput = {
    id?: bigint | number
    course_id?: bigint | number | null
    plan_type: $Enums.plan_type
    plan_name: string
    price?: Decimal | DecimalJsLike | number | string | null
    duration_days?: number | null
    created_at?: Date | string | null
  }

  export type course_plansCreateOrConnectWithoutEnrollmentsInput = {
    where: course_plansWhereUniqueInput
    create: XOR<course_plansCreateWithoutEnrollmentsInput, course_plansUncheckedCreateWithoutEnrollmentsInput>
  }

  export type usersCreateWithoutEnrollmentsInput = {
    id?: bigint | number
    full_name: string
    email: string
    password_hash: string
    role?: $Enums.user_role | null
    created_at?: Date | string | null
    comments?: commentsCreateNestedManyWithoutUsersInput
    course_reviews?: course_reviewsCreateNestedManyWithoutUsersInput
    mock_attempts?: mock_attemptsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    posts?: postsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutEnrollmentsInput = {
    id?: bigint | number
    full_name: string
    email: string
    password_hash: string
    role?: $Enums.user_role | null
    created_at?: Date | string | null
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    course_reviews?: course_reviewsUncheckedCreateNestedManyWithoutUsersInput
    mock_attempts?: mock_attemptsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    posts?: postsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutEnrollmentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutEnrollmentsInput, usersUncheckedCreateWithoutEnrollmentsInput>
  }

  export type coursesUpsertWithoutEnrollmentsInput = {
    update: XOR<coursesUpdateWithoutEnrollmentsInput, coursesUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<coursesCreateWithoutEnrollmentsInput, coursesUncheckedCreateWithoutEnrollmentsInput>
    where?: coursesWhereInput
  }

  export type coursesUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: coursesWhereInput
    data: XOR<coursesUpdateWithoutEnrollmentsInput, coursesUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type coursesUpdateWithoutEnrollmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_plans?: course_plansUpdateManyWithoutCoursesNestedInput
    course_reviews?: course_reviewsUpdateManyWithoutCoursesNestedInput
    course_videos?: course_videosUpdateManyWithoutCoursesNestedInput
    payments?: paymentsUpdateManyWithoutCoursesNestedInput
  }

  export type coursesUncheckedUpdateWithoutEnrollmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_plans?: course_plansUncheckedUpdateManyWithoutCoursesNestedInput
    course_reviews?: course_reviewsUncheckedUpdateManyWithoutCoursesNestedInput
    course_videos?: course_videosUncheckedUpdateManyWithoutCoursesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type course_plansUpsertWithoutEnrollmentsInput = {
    update: XOR<course_plansUpdateWithoutEnrollmentsInput, course_plansUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<course_plansCreateWithoutEnrollmentsInput, course_plansUncheckedCreateWithoutEnrollmentsInput>
    where?: course_plansWhereInput
  }

  export type course_plansUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: course_plansWhereInput
    data: XOR<course_plansUpdateWithoutEnrollmentsInput, course_plansUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type course_plansUpdateWithoutEnrollmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plan_type?: Enumplan_typeFieldUpdateOperationsInput | $Enums.plan_type
    plan_name?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration_days?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: coursesUpdateOneWithoutCourse_plansNestedInput
  }

  export type course_plansUncheckedUpdateWithoutEnrollmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    plan_type?: Enumplan_typeFieldUpdateOperationsInput | $Enums.plan_type
    plan_name?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration_days?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUpsertWithoutEnrollmentsInput = {
    update: XOR<usersUpdateWithoutEnrollmentsInput, usersUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<usersCreateWithoutEnrollmentsInput, usersUncheckedCreateWithoutEnrollmentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutEnrollmentsInput, usersUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type usersUpdateWithoutEnrollmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: commentsUpdateManyWithoutUsersNestedInput
    course_reviews?: course_reviewsUpdateManyWithoutUsersNestedInput
    mock_attempts?: mock_attemptsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    posts?: postsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutEnrollmentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    course_reviews?: course_reviewsUncheckedUpdateManyWithoutUsersNestedInput
    mock_attempts?: mock_attemptsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    posts?: postsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type mock_testsCreateWithoutMock_attemptsInput = {
    id?: bigint | number
    title: string
    description?: string | null
    duration_minutes: number
    total_marks: number
    created_at?: Date | string | null
    is_free?: boolean | null
    mock_questions?: mock_questionsCreateNestedManyWithoutMock_testsInput
    mock_series?: mock_seriesCreateNestedOneWithoutMock_testsInput
  }

  export type mock_testsUncheckedCreateWithoutMock_attemptsInput = {
    id?: bigint | number
    series_id?: bigint | number | null
    title: string
    description?: string | null
    duration_minutes: number
    total_marks: number
    created_at?: Date | string | null
    is_free?: boolean | null
    mock_questions?: mock_questionsUncheckedCreateNestedManyWithoutMock_testsInput
  }

  export type mock_testsCreateOrConnectWithoutMock_attemptsInput = {
    where: mock_testsWhereUniqueInput
    create: XOR<mock_testsCreateWithoutMock_attemptsInput, mock_testsUncheckedCreateWithoutMock_attemptsInput>
  }

  export type usersCreateWithoutMock_attemptsInput = {
    id?: bigint | number
    full_name: string
    email: string
    password_hash: string
    role?: $Enums.user_role | null
    created_at?: Date | string | null
    comments?: commentsCreateNestedManyWithoutUsersInput
    course_reviews?: course_reviewsCreateNestedManyWithoutUsersInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    posts?: postsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutMock_attemptsInput = {
    id?: bigint | number
    full_name: string
    email: string
    password_hash: string
    role?: $Enums.user_role | null
    created_at?: Date | string | null
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    course_reviews?: course_reviewsUncheckedCreateNestedManyWithoutUsersInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    posts?: postsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutMock_attemptsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMock_attemptsInput, usersUncheckedCreateWithoutMock_attemptsInput>
  }

  export type mock_testsUpsertWithoutMock_attemptsInput = {
    update: XOR<mock_testsUpdateWithoutMock_attemptsInput, mock_testsUncheckedUpdateWithoutMock_attemptsInput>
    create: XOR<mock_testsCreateWithoutMock_attemptsInput, mock_testsUncheckedCreateWithoutMock_attemptsInput>
    where?: mock_testsWhereInput
  }

  export type mock_testsUpdateToOneWithWhereWithoutMock_attemptsInput = {
    where?: mock_testsWhereInput
    data: XOR<mock_testsUpdateWithoutMock_attemptsInput, mock_testsUncheckedUpdateWithoutMock_attemptsInput>
  }

  export type mock_testsUpdateWithoutMock_attemptsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration_minutes?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_free?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mock_questions?: mock_questionsUpdateManyWithoutMock_testsNestedInput
    mock_series?: mock_seriesUpdateOneWithoutMock_testsNestedInput
  }

  export type mock_testsUncheckedUpdateWithoutMock_attemptsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    series_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration_minutes?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_free?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mock_questions?: mock_questionsUncheckedUpdateManyWithoutMock_testsNestedInput
  }

  export type usersUpsertWithoutMock_attemptsInput = {
    update: XOR<usersUpdateWithoutMock_attemptsInput, usersUncheckedUpdateWithoutMock_attemptsInput>
    create: XOR<usersCreateWithoutMock_attemptsInput, usersUncheckedCreateWithoutMock_attemptsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutMock_attemptsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutMock_attemptsInput, usersUncheckedUpdateWithoutMock_attemptsInput>
  }

  export type usersUpdateWithoutMock_attemptsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: commentsUpdateManyWithoutUsersNestedInput
    course_reviews?: course_reviewsUpdateManyWithoutUsersNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    posts?: postsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutMock_attemptsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    course_reviews?: course_reviewsUncheckedUpdateManyWithoutUsersNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    posts?: postsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type mock_seriesCreateWithoutMock_categoriesInput = {
    id?: bigint | number
    title: string
    description?: string | null
    created_at?: Date | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    mock_tests?: mock_testsCreateNestedManyWithoutMock_seriesInput
    payments?: paymentsCreateNestedManyWithoutMock_seriesInput
  }

  export type mock_seriesUncheckedCreateWithoutMock_categoriesInput = {
    id?: bigint | number
    title: string
    description?: string | null
    created_at?: Date | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    mock_tests?: mock_testsUncheckedCreateNestedManyWithoutMock_seriesInput
    payments?: paymentsUncheckedCreateNestedManyWithoutMock_seriesInput
  }

  export type mock_seriesCreateOrConnectWithoutMock_categoriesInput = {
    where: mock_seriesWhereUniqueInput
    create: XOR<mock_seriesCreateWithoutMock_categoriesInput, mock_seriesUncheckedCreateWithoutMock_categoriesInput>
  }

  export type mock_seriesCreateManyMock_categoriesInputEnvelope = {
    data: mock_seriesCreateManyMock_categoriesInput | mock_seriesCreateManyMock_categoriesInput[]
    skipDuplicates?: boolean
  }

  export type mock_seriesUpsertWithWhereUniqueWithoutMock_categoriesInput = {
    where: mock_seriesWhereUniqueInput
    update: XOR<mock_seriesUpdateWithoutMock_categoriesInput, mock_seriesUncheckedUpdateWithoutMock_categoriesInput>
    create: XOR<mock_seriesCreateWithoutMock_categoriesInput, mock_seriesUncheckedCreateWithoutMock_categoriesInput>
  }

  export type mock_seriesUpdateWithWhereUniqueWithoutMock_categoriesInput = {
    where: mock_seriesWhereUniqueInput
    data: XOR<mock_seriesUpdateWithoutMock_categoriesInput, mock_seriesUncheckedUpdateWithoutMock_categoriesInput>
  }

  export type mock_seriesUpdateManyWithWhereWithoutMock_categoriesInput = {
    where: mock_seriesScalarWhereInput
    data: XOR<mock_seriesUpdateManyMutationInput, mock_seriesUncheckedUpdateManyWithoutMock_categoriesInput>
  }

  export type mock_seriesScalarWhereInput = {
    AND?: mock_seriesScalarWhereInput | mock_seriesScalarWhereInput[]
    OR?: mock_seriesScalarWhereInput[]
    NOT?: mock_seriesScalarWhereInput | mock_seriesScalarWhereInput[]
    id?: BigIntFilter<"mock_series"> | bigint | number
    category_id?: BigIntNullableFilter<"mock_series"> | bigint | number | null
    title?: StringFilter<"mock_series"> | string
    description?: StringNullableFilter<"mock_series"> | string | null
    created_at?: DateTimeNullableFilter<"mock_series"> | Date | string | null
    price?: DecimalNullableFilter<"mock_series"> | Decimal | DecimalJsLike | number | string | null
  }

  export type mock_testsCreateWithoutMock_questionsInput = {
    id?: bigint | number
    title: string
    description?: string | null
    duration_minutes: number
    total_marks: number
    created_at?: Date | string | null
    is_free?: boolean | null
    mock_attempts?: mock_attemptsCreateNestedManyWithoutMock_testsInput
    mock_series?: mock_seriesCreateNestedOneWithoutMock_testsInput
  }

  export type mock_testsUncheckedCreateWithoutMock_questionsInput = {
    id?: bigint | number
    series_id?: bigint | number | null
    title: string
    description?: string | null
    duration_minutes: number
    total_marks: number
    created_at?: Date | string | null
    is_free?: boolean | null
    mock_attempts?: mock_attemptsUncheckedCreateNestedManyWithoutMock_testsInput
  }

  export type mock_testsCreateOrConnectWithoutMock_questionsInput = {
    where: mock_testsWhereUniqueInput
    create: XOR<mock_testsCreateWithoutMock_questionsInput, mock_testsUncheckedCreateWithoutMock_questionsInput>
  }

  export type mock_testsUpsertWithoutMock_questionsInput = {
    update: XOR<mock_testsUpdateWithoutMock_questionsInput, mock_testsUncheckedUpdateWithoutMock_questionsInput>
    create: XOR<mock_testsCreateWithoutMock_questionsInput, mock_testsUncheckedCreateWithoutMock_questionsInput>
    where?: mock_testsWhereInput
  }

  export type mock_testsUpdateToOneWithWhereWithoutMock_questionsInput = {
    where?: mock_testsWhereInput
    data: XOR<mock_testsUpdateWithoutMock_questionsInput, mock_testsUncheckedUpdateWithoutMock_questionsInput>
  }

  export type mock_testsUpdateWithoutMock_questionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration_minutes?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_free?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mock_attempts?: mock_attemptsUpdateManyWithoutMock_testsNestedInput
    mock_series?: mock_seriesUpdateOneWithoutMock_testsNestedInput
  }

  export type mock_testsUncheckedUpdateWithoutMock_questionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    series_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration_minutes?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_free?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mock_attempts?: mock_attemptsUncheckedUpdateManyWithoutMock_testsNestedInput
  }

  export type mock_categoriesCreateWithoutMock_seriesInput = {
    id?: bigint | number
    name: string
    description?: string | null
  }

  export type mock_categoriesUncheckedCreateWithoutMock_seriesInput = {
    id?: bigint | number
    name: string
    description?: string | null
  }

  export type mock_categoriesCreateOrConnectWithoutMock_seriesInput = {
    where: mock_categoriesWhereUniqueInput
    create: XOR<mock_categoriesCreateWithoutMock_seriesInput, mock_categoriesUncheckedCreateWithoutMock_seriesInput>
  }

  export type mock_testsCreateWithoutMock_seriesInput = {
    id?: bigint | number
    title: string
    description?: string | null
    duration_minutes: number
    total_marks: number
    created_at?: Date | string | null
    is_free?: boolean | null
    mock_attempts?: mock_attemptsCreateNestedManyWithoutMock_testsInput
    mock_questions?: mock_questionsCreateNestedManyWithoutMock_testsInput
  }

  export type mock_testsUncheckedCreateWithoutMock_seriesInput = {
    id?: bigint | number
    title: string
    description?: string | null
    duration_minutes: number
    total_marks: number
    created_at?: Date | string | null
    is_free?: boolean | null
    mock_attempts?: mock_attemptsUncheckedCreateNestedManyWithoutMock_testsInput
    mock_questions?: mock_questionsUncheckedCreateNestedManyWithoutMock_testsInput
  }

  export type mock_testsCreateOrConnectWithoutMock_seriesInput = {
    where: mock_testsWhereUniqueInput
    create: XOR<mock_testsCreateWithoutMock_seriesInput, mock_testsUncheckedCreateWithoutMock_seriesInput>
  }

  export type mock_testsCreateManyMock_seriesInputEnvelope = {
    data: mock_testsCreateManyMock_seriesInput | mock_testsCreateManyMock_seriesInput[]
    skipDuplicates?: boolean
  }

  export type paymentsCreateWithoutMock_seriesInput = {
    id?: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    status?: $Enums.payment_status | null
    transaction_id?: string | null
    created_at?: Date | string | null
    courses?: coursesCreateNestedOneWithoutPaymentsInput
    users?: usersCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutMock_seriesInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    course_id?: bigint | number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    status?: $Enums.payment_status | null
    transaction_id?: string | null
    created_at?: Date | string | null
  }

  export type paymentsCreateOrConnectWithoutMock_seriesInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutMock_seriesInput, paymentsUncheckedCreateWithoutMock_seriesInput>
  }

  export type paymentsCreateManyMock_seriesInputEnvelope = {
    data: paymentsCreateManyMock_seriesInput | paymentsCreateManyMock_seriesInput[]
    skipDuplicates?: boolean
  }

  export type mock_categoriesUpsertWithoutMock_seriesInput = {
    update: XOR<mock_categoriesUpdateWithoutMock_seriesInput, mock_categoriesUncheckedUpdateWithoutMock_seriesInput>
    create: XOR<mock_categoriesCreateWithoutMock_seriesInput, mock_categoriesUncheckedCreateWithoutMock_seriesInput>
    where?: mock_categoriesWhereInput
  }

  export type mock_categoriesUpdateToOneWithWhereWithoutMock_seriesInput = {
    where?: mock_categoriesWhereInput
    data: XOR<mock_categoriesUpdateWithoutMock_seriesInput, mock_categoriesUncheckedUpdateWithoutMock_seriesInput>
  }

  export type mock_categoriesUpdateWithoutMock_seriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mock_categoriesUncheckedUpdateWithoutMock_seriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mock_testsUpsertWithWhereUniqueWithoutMock_seriesInput = {
    where: mock_testsWhereUniqueInput
    update: XOR<mock_testsUpdateWithoutMock_seriesInput, mock_testsUncheckedUpdateWithoutMock_seriesInput>
    create: XOR<mock_testsCreateWithoutMock_seriesInput, mock_testsUncheckedCreateWithoutMock_seriesInput>
  }

  export type mock_testsUpdateWithWhereUniqueWithoutMock_seriesInput = {
    where: mock_testsWhereUniqueInput
    data: XOR<mock_testsUpdateWithoutMock_seriesInput, mock_testsUncheckedUpdateWithoutMock_seriesInput>
  }

  export type mock_testsUpdateManyWithWhereWithoutMock_seriesInput = {
    where: mock_testsScalarWhereInput
    data: XOR<mock_testsUpdateManyMutationInput, mock_testsUncheckedUpdateManyWithoutMock_seriesInput>
  }

  export type mock_testsScalarWhereInput = {
    AND?: mock_testsScalarWhereInput | mock_testsScalarWhereInput[]
    OR?: mock_testsScalarWhereInput[]
    NOT?: mock_testsScalarWhereInput | mock_testsScalarWhereInput[]
    id?: BigIntFilter<"mock_tests"> | bigint | number
    series_id?: BigIntNullableFilter<"mock_tests"> | bigint | number | null
    title?: StringFilter<"mock_tests"> | string
    description?: StringNullableFilter<"mock_tests"> | string | null
    duration_minutes?: IntFilter<"mock_tests"> | number
    total_marks?: IntFilter<"mock_tests"> | number
    created_at?: DateTimeNullableFilter<"mock_tests"> | Date | string | null
    is_free?: BoolNullableFilter<"mock_tests"> | boolean | null
  }

  export type paymentsUpsertWithWhereUniqueWithoutMock_seriesInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutMock_seriesInput, paymentsUncheckedUpdateWithoutMock_seriesInput>
    create: XOR<paymentsCreateWithoutMock_seriesInput, paymentsUncheckedCreateWithoutMock_seriesInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutMock_seriesInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutMock_seriesInput, paymentsUncheckedUpdateWithoutMock_seriesInput>
  }

  export type paymentsUpdateManyWithWhereWithoutMock_seriesInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutMock_seriesInput>
  }

  export type mock_attemptsCreateWithoutMock_testsInput = {
    id?: bigint | number
    answers: JsonNullValueInput | InputJsonValue
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    users?: usersCreateNestedOneWithoutMock_attemptsInput
  }

  export type mock_attemptsUncheckedCreateWithoutMock_testsInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    answers: JsonNullValueInput | InputJsonValue
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
  }

  export type mock_attemptsCreateOrConnectWithoutMock_testsInput = {
    where: mock_attemptsWhereUniqueInput
    create: XOR<mock_attemptsCreateWithoutMock_testsInput, mock_attemptsUncheckedCreateWithoutMock_testsInput>
  }

  export type mock_attemptsCreateManyMock_testsInputEnvelope = {
    data: mock_attemptsCreateManyMock_testsInput | mock_attemptsCreateManyMock_testsInput[]
    skipDuplicates?: boolean
  }

  export type mock_questionsCreateWithoutMock_testsInput = {
    id?: bigint | number
    question_text: string
    question_type?: $Enums.question_type | null
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: string
    marks?: number | null
  }

  export type mock_questionsUncheckedCreateWithoutMock_testsInput = {
    id?: bigint | number
    question_text: string
    question_type?: $Enums.question_type | null
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: string
    marks?: number | null
  }

  export type mock_questionsCreateOrConnectWithoutMock_testsInput = {
    where: mock_questionsWhereUniqueInput
    create: XOR<mock_questionsCreateWithoutMock_testsInput, mock_questionsUncheckedCreateWithoutMock_testsInput>
  }

  export type mock_questionsCreateManyMock_testsInputEnvelope = {
    data: mock_questionsCreateManyMock_testsInput | mock_questionsCreateManyMock_testsInput[]
    skipDuplicates?: boolean
  }

  export type mock_seriesCreateWithoutMock_testsInput = {
    id?: bigint | number
    title: string
    description?: string | null
    created_at?: Date | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    mock_categories?: mock_categoriesCreateNestedOneWithoutMock_seriesInput
    payments?: paymentsCreateNestedManyWithoutMock_seriesInput
  }

  export type mock_seriesUncheckedCreateWithoutMock_testsInput = {
    id?: bigint | number
    category_id?: bigint | number | null
    title: string
    description?: string | null
    created_at?: Date | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutMock_seriesInput
  }

  export type mock_seriesCreateOrConnectWithoutMock_testsInput = {
    where: mock_seriesWhereUniqueInput
    create: XOR<mock_seriesCreateWithoutMock_testsInput, mock_seriesUncheckedCreateWithoutMock_testsInput>
  }

  export type mock_attemptsUpsertWithWhereUniqueWithoutMock_testsInput = {
    where: mock_attemptsWhereUniqueInput
    update: XOR<mock_attemptsUpdateWithoutMock_testsInput, mock_attemptsUncheckedUpdateWithoutMock_testsInput>
    create: XOR<mock_attemptsCreateWithoutMock_testsInput, mock_attemptsUncheckedCreateWithoutMock_testsInput>
  }

  export type mock_attemptsUpdateWithWhereUniqueWithoutMock_testsInput = {
    where: mock_attemptsWhereUniqueInput
    data: XOR<mock_attemptsUpdateWithoutMock_testsInput, mock_attemptsUncheckedUpdateWithoutMock_testsInput>
  }

  export type mock_attemptsUpdateManyWithWhereWithoutMock_testsInput = {
    where: mock_attemptsScalarWhereInput
    data: XOR<mock_attemptsUpdateManyMutationInput, mock_attemptsUncheckedUpdateManyWithoutMock_testsInput>
  }

  export type mock_attemptsScalarWhereInput = {
    AND?: mock_attemptsScalarWhereInput | mock_attemptsScalarWhereInput[]
    OR?: mock_attemptsScalarWhereInput[]
    NOT?: mock_attemptsScalarWhereInput | mock_attemptsScalarWhereInput[]
    id?: BigIntFilter<"mock_attempts"> | bigint | number
    test_id?: BigIntNullableFilter<"mock_attempts"> | bigint | number | null
    user_id?: BigIntNullableFilter<"mock_attempts"> | bigint | number | null
    answers?: JsonFilter<"mock_attempts">
    score?: IntNullableFilter<"mock_attempts"> | number | null
    started_at?: DateTimeNullableFilter<"mock_attempts"> | Date | string | null
    completed_at?: DateTimeNullableFilter<"mock_attempts"> | Date | string | null
  }

  export type mock_questionsUpsertWithWhereUniqueWithoutMock_testsInput = {
    where: mock_questionsWhereUniqueInput
    update: XOR<mock_questionsUpdateWithoutMock_testsInput, mock_questionsUncheckedUpdateWithoutMock_testsInput>
    create: XOR<mock_questionsCreateWithoutMock_testsInput, mock_questionsUncheckedCreateWithoutMock_testsInput>
  }

  export type mock_questionsUpdateWithWhereUniqueWithoutMock_testsInput = {
    where: mock_questionsWhereUniqueInput
    data: XOR<mock_questionsUpdateWithoutMock_testsInput, mock_questionsUncheckedUpdateWithoutMock_testsInput>
  }

  export type mock_questionsUpdateManyWithWhereWithoutMock_testsInput = {
    where: mock_questionsScalarWhereInput
    data: XOR<mock_questionsUpdateManyMutationInput, mock_questionsUncheckedUpdateManyWithoutMock_testsInput>
  }

  export type mock_questionsScalarWhereInput = {
    AND?: mock_questionsScalarWhereInput | mock_questionsScalarWhereInput[]
    OR?: mock_questionsScalarWhereInput[]
    NOT?: mock_questionsScalarWhereInput | mock_questionsScalarWhereInput[]
    id?: BigIntFilter<"mock_questions"> | bigint | number
    test_id?: BigIntNullableFilter<"mock_questions"> | bigint | number | null
    question_text?: StringFilter<"mock_questions"> | string
    question_type?: Enumquestion_typeNullableFilter<"mock_questions"> | $Enums.question_type | null
    options?: JsonNullableFilter<"mock_questions">
    correct_answer?: StringFilter<"mock_questions"> | string
    marks?: IntNullableFilter<"mock_questions"> | number | null
  }

  export type mock_seriesUpsertWithoutMock_testsInput = {
    update: XOR<mock_seriesUpdateWithoutMock_testsInput, mock_seriesUncheckedUpdateWithoutMock_testsInput>
    create: XOR<mock_seriesCreateWithoutMock_testsInput, mock_seriesUncheckedCreateWithoutMock_testsInput>
    where?: mock_seriesWhereInput
  }

  export type mock_seriesUpdateToOneWithWhereWithoutMock_testsInput = {
    where?: mock_seriesWhereInput
    data: XOR<mock_seriesUpdateWithoutMock_testsInput, mock_seriesUncheckedUpdateWithoutMock_testsInput>
  }

  export type mock_seriesUpdateWithoutMock_testsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mock_categories?: mock_categoriesUpdateOneWithoutMock_seriesNestedInput
    payments?: paymentsUpdateManyWithoutMock_seriesNestedInput
  }

  export type mock_seriesUncheckedUpdateWithoutMock_testsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    payments?: paymentsUncheckedUpdateManyWithoutMock_seriesNestedInput
  }

  export type coursesCreateWithoutPaymentsInput = {
    id?: bigint | number
    title: string
    description?: string | null
    thumbnail_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    course_plans?: course_plansCreateNestedManyWithoutCoursesInput
    course_reviews?: course_reviewsCreateNestedManyWithoutCoursesInput
    course_videos?: course_videosCreateNestedManyWithoutCoursesInput
    enrollments?: enrollmentsCreateNestedManyWithoutCoursesInput
  }

  export type coursesUncheckedCreateWithoutPaymentsInput = {
    id?: bigint | number
    title: string
    description?: string | null
    thumbnail_url?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    course_plans?: course_plansUncheckedCreateNestedManyWithoutCoursesInput
    course_reviews?: course_reviewsUncheckedCreateNestedManyWithoutCoursesInput
    course_videos?: course_videosUncheckedCreateNestedManyWithoutCoursesInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutCoursesInput
  }

  export type coursesCreateOrConnectWithoutPaymentsInput = {
    where: coursesWhereUniqueInput
    create: XOR<coursesCreateWithoutPaymentsInput, coursesUncheckedCreateWithoutPaymentsInput>
  }

  export type mock_seriesCreateWithoutPaymentsInput = {
    id?: bigint | number
    title: string
    description?: string | null
    created_at?: Date | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    mock_categories?: mock_categoriesCreateNestedOneWithoutMock_seriesInput
    mock_tests?: mock_testsCreateNestedManyWithoutMock_seriesInput
  }

  export type mock_seriesUncheckedCreateWithoutPaymentsInput = {
    id?: bigint | number
    category_id?: bigint | number | null
    title: string
    description?: string | null
    created_at?: Date | string | null
    price?: Decimal | DecimalJsLike | number | string | null
    mock_tests?: mock_testsUncheckedCreateNestedManyWithoutMock_seriesInput
  }

  export type mock_seriesCreateOrConnectWithoutPaymentsInput = {
    where: mock_seriesWhereUniqueInput
    create: XOR<mock_seriesCreateWithoutPaymentsInput, mock_seriesUncheckedCreateWithoutPaymentsInput>
  }

  export type usersCreateWithoutPaymentsInput = {
    id?: bigint | number
    full_name: string
    email: string
    password_hash: string
    role?: $Enums.user_role | null
    created_at?: Date | string | null
    comments?: commentsCreateNestedManyWithoutUsersInput
    course_reviews?: course_reviewsCreateNestedManyWithoutUsersInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    mock_attempts?: mock_attemptsCreateNestedManyWithoutUsersInput
    posts?: postsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPaymentsInput = {
    id?: bigint | number
    full_name: string
    email: string
    password_hash: string
    role?: $Enums.user_role | null
    created_at?: Date | string | null
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    course_reviews?: course_reviewsUncheckedCreateNestedManyWithoutUsersInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    mock_attempts?: mock_attemptsUncheckedCreateNestedManyWithoutUsersInput
    posts?: postsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPaymentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
  }

  export type coursesUpsertWithoutPaymentsInput = {
    update: XOR<coursesUpdateWithoutPaymentsInput, coursesUncheckedUpdateWithoutPaymentsInput>
    create: XOR<coursesCreateWithoutPaymentsInput, coursesUncheckedCreateWithoutPaymentsInput>
    where?: coursesWhereInput
  }

  export type coursesUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: coursesWhereInput
    data: XOR<coursesUpdateWithoutPaymentsInput, coursesUncheckedUpdateWithoutPaymentsInput>
  }

  export type coursesUpdateWithoutPaymentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_plans?: course_plansUpdateManyWithoutCoursesNestedInput
    course_reviews?: course_reviewsUpdateManyWithoutCoursesNestedInput
    course_videos?: course_videosUpdateManyWithoutCoursesNestedInput
    enrollments?: enrollmentsUpdateManyWithoutCoursesNestedInput
  }

  export type coursesUncheckedUpdateWithoutPaymentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_plans?: course_plansUncheckedUpdateManyWithoutCoursesNestedInput
    course_reviews?: course_reviewsUncheckedUpdateManyWithoutCoursesNestedInput
    course_videos?: course_videosUncheckedUpdateManyWithoutCoursesNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutCoursesNestedInput
  }

  export type mock_seriesUpsertWithoutPaymentsInput = {
    update: XOR<mock_seriesUpdateWithoutPaymentsInput, mock_seriesUncheckedUpdateWithoutPaymentsInput>
    create: XOR<mock_seriesCreateWithoutPaymentsInput, mock_seriesUncheckedCreateWithoutPaymentsInput>
    where?: mock_seriesWhereInput
  }

  export type mock_seriesUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: mock_seriesWhereInput
    data: XOR<mock_seriesUpdateWithoutPaymentsInput, mock_seriesUncheckedUpdateWithoutPaymentsInput>
  }

  export type mock_seriesUpdateWithoutPaymentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mock_categories?: mock_categoriesUpdateOneWithoutMock_seriesNestedInput
    mock_tests?: mock_testsUpdateManyWithoutMock_seriesNestedInput
  }

  export type mock_seriesUncheckedUpdateWithoutPaymentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mock_tests?: mock_testsUncheckedUpdateManyWithoutMock_seriesNestedInput
  }

  export type usersUpsertWithoutPaymentsInput = {
    update: XOR<usersUpdateWithoutPaymentsInput, usersUncheckedUpdateWithoutPaymentsInput>
    create: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPaymentsInput, usersUncheckedUpdateWithoutPaymentsInput>
  }

  export type usersUpdateWithoutPaymentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: commentsUpdateManyWithoutUsersNestedInput
    course_reviews?: course_reviewsUpdateManyWithoutUsersNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    mock_attempts?: mock_attemptsUpdateManyWithoutUsersNestedInput
    posts?: postsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPaymentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    course_reviews?: course_reviewsUncheckedUpdateManyWithoutUsersNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    mock_attempts?: mock_attemptsUncheckedUpdateManyWithoutUsersNestedInput
    posts?: postsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type postsCreateWithoutPost_tagsInput = {
    id?: bigint | number
    title: string
    slug: string
    content: string
    external_url?: string | null
    thumbnail_url?: string | null
    published_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: string | null
    comments?: commentsCreateNestedManyWithoutPostsInput
    categories?: categoriesCreateNestedOneWithoutPostsInput
    users?: usersCreateNestedOneWithoutPostsInput
    post_templates?: post_templatesCreateNestedOneWithoutPostsInput
  }

  export type postsUncheckedCreateWithoutPost_tagsInput = {
    id?: bigint | number
    category_id?: bigint | number | null
    title: string
    slug: string
    content: string
    external_url?: string | null
    thumbnail_url?: string | null
    published_at?: Date | string | null
    created_by?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    template_id?: bigint | number | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: string | null
    comments?: commentsUncheckedCreateNestedManyWithoutPostsInput
  }

  export type postsCreateOrConnectWithoutPost_tagsInput = {
    where: postsWhereUniqueInput
    create: XOR<postsCreateWithoutPost_tagsInput, postsUncheckedCreateWithoutPost_tagsInput>
  }

  export type tagsCreateWithoutPost_tagsInput = {
    id?: bigint | number
    name: string
  }

  export type tagsUncheckedCreateWithoutPost_tagsInput = {
    id?: bigint | number
    name: string
  }

  export type tagsCreateOrConnectWithoutPost_tagsInput = {
    where: tagsWhereUniqueInput
    create: XOR<tagsCreateWithoutPost_tagsInput, tagsUncheckedCreateWithoutPost_tagsInput>
  }

  export type postsUpsertWithoutPost_tagsInput = {
    update: XOR<postsUpdateWithoutPost_tagsInput, postsUncheckedUpdateWithoutPost_tagsInput>
    create: XOR<postsCreateWithoutPost_tagsInput, postsUncheckedCreateWithoutPost_tagsInput>
    where?: postsWhereInput
  }

  export type postsUpdateToOneWithWhereWithoutPost_tagsInput = {
    where?: postsWhereInput
    data: XOR<postsUpdateWithoutPost_tagsInput, postsUncheckedUpdateWithoutPost_tagsInput>
  }

  export type postsUpdateWithoutPost_tagsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUpdateManyWithoutPostsNestedInput
    categories?: categoriesUpdateOneWithoutPostsNestedInput
    users?: usersUpdateOneWithoutPostsNestedInput
    post_templates?: post_templatesUpdateOneWithoutPostsNestedInput
  }

  export type postsUncheckedUpdateWithoutPost_tagsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type tagsUpsertWithoutPost_tagsInput = {
    update: XOR<tagsUpdateWithoutPost_tagsInput, tagsUncheckedUpdateWithoutPost_tagsInput>
    create: XOR<tagsCreateWithoutPost_tagsInput, tagsUncheckedCreateWithoutPost_tagsInput>
    where?: tagsWhereInput
  }

  export type tagsUpdateToOneWithWhereWithoutPost_tagsInput = {
    where?: tagsWhereInput
    data: XOR<tagsUpdateWithoutPost_tagsInput, tagsUncheckedUpdateWithoutPost_tagsInput>
  }

  export type tagsUpdateWithoutPost_tagsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type tagsUncheckedUpdateWithoutPost_tagsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type postsCreateWithoutPost_templatesInput = {
    id?: bigint | number
    title: string
    slug: string
    content: string
    external_url?: string | null
    thumbnail_url?: string | null
    published_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: string | null
    comments?: commentsCreateNestedManyWithoutPostsInput
    post_tags?: post_tagsCreateNestedManyWithoutPostsInput
    categories?: categoriesCreateNestedOneWithoutPostsInput
    users?: usersCreateNestedOneWithoutPostsInput
  }

  export type postsUncheckedCreateWithoutPost_templatesInput = {
    id?: bigint | number
    category_id?: bigint | number | null
    title: string
    slug: string
    content: string
    external_url?: string | null
    thumbnail_url?: string | null
    published_at?: Date | string | null
    created_by?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: string | null
    comments?: commentsUncheckedCreateNestedManyWithoutPostsInput
    post_tags?: post_tagsUncheckedCreateNestedManyWithoutPostsInput
  }

  export type postsCreateOrConnectWithoutPost_templatesInput = {
    where: postsWhereUniqueInput
    create: XOR<postsCreateWithoutPost_templatesInput, postsUncheckedCreateWithoutPost_templatesInput>
  }

  export type postsCreateManyPost_templatesInputEnvelope = {
    data: postsCreateManyPost_templatesInput | postsCreateManyPost_templatesInput[]
    skipDuplicates?: boolean
  }

  export type postsUpsertWithWhereUniqueWithoutPost_templatesInput = {
    where: postsWhereUniqueInput
    update: XOR<postsUpdateWithoutPost_templatesInput, postsUncheckedUpdateWithoutPost_templatesInput>
    create: XOR<postsCreateWithoutPost_templatesInput, postsUncheckedCreateWithoutPost_templatesInput>
  }

  export type postsUpdateWithWhereUniqueWithoutPost_templatesInput = {
    where: postsWhereUniqueInput
    data: XOR<postsUpdateWithoutPost_templatesInput, postsUncheckedUpdateWithoutPost_templatesInput>
  }

  export type postsUpdateManyWithWhereWithoutPost_templatesInput = {
    where: postsScalarWhereInput
    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyWithoutPost_templatesInput>
  }

  export type commentsCreateWithoutPostsInput = {
    id?: bigint | number
    content: string
    created_at?: Date | string | null
    users?: usersCreateNestedOneWithoutCommentsInput
  }

  export type commentsUncheckedCreateWithoutPostsInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    content: string
    created_at?: Date | string | null
  }

  export type commentsCreateOrConnectWithoutPostsInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutPostsInput, commentsUncheckedCreateWithoutPostsInput>
  }

  export type commentsCreateManyPostsInputEnvelope = {
    data: commentsCreateManyPostsInput | commentsCreateManyPostsInput[]
    skipDuplicates?: boolean
  }

  export type post_tagsCreateWithoutPostsInput = {
    tags: tagsCreateNestedOneWithoutPost_tagsInput
  }

  export type post_tagsUncheckedCreateWithoutPostsInput = {
    tag_id: bigint | number
  }

  export type post_tagsCreateOrConnectWithoutPostsInput = {
    where: post_tagsWhereUniqueInput
    create: XOR<post_tagsCreateWithoutPostsInput, post_tagsUncheckedCreateWithoutPostsInput>
  }

  export type post_tagsCreateManyPostsInputEnvelope = {
    data: post_tagsCreateManyPostsInput | post_tagsCreateManyPostsInput[]
    skipDuplicates?: boolean
  }

  export type categoriesCreateWithoutPostsInput = {
    id?: bigint | number
    name: string
    description?: string | null
    created_at?: Date | string | null
  }

  export type categoriesUncheckedCreateWithoutPostsInput = {
    id?: bigint | number
    name: string
    description?: string | null
    created_at?: Date | string | null
  }

  export type categoriesCreateOrConnectWithoutPostsInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutPostsInput, categoriesUncheckedCreateWithoutPostsInput>
  }

  export type usersCreateWithoutPostsInput = {
    id?: bigint | number
    full_name: string
    email: string
    password_hash: string
    role?: $Enums.user_role | null
    created_at?: Date | string | null
    comments?: commentsCreateNestedManyWithoutUsersInput
    course_reviews?: course_reviewsCreateNestedManyWithoutUsersInput
    enrollments?: enrollmentsCreateNestedManyWithoutUsersInput
    mock_attempts?: mock_attemptsCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPostsInput = {
    id?: bigint | number
    full_name: string
    email: string
    password_hash: string
    role?: $Enums.user_role | null
    created_at?: Date | string | null
    comments?: commentsUncheckedCreateNestedManyWithoutUsersInput
    course_reviews?: course_reviewsUncheckedCreateNestedManyWithoutUsersInput
    enrollments?: enrollmentsUncheckedCreateNestedManyWithoutUsersInput
    mock_attempts?: mock_attemptsUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPostsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPostsInput, usersUncheckedCreateWithoutPostsInput>
  }

  export type post_templatesCreateWithoutPostsInput = {
    id?: bigint | number
    name: string
    description?: string | null
    structure: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type post_templatesUncheckedCreateWithoutPostsInput = {
    id?: bigint | number
    name: string
    description?: string | null
    structure: JsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type post_templatesCreateOrConnectWithoutPostsInput = {
    where: post_templatesWhereUniqueInput
    create: XOR<post_templatesCreateWithoutPostsInput, post_templatesUncheckedCreateWithoutPostsInput>
  }

  export type commentsUpsertWithWhereUniqueWithoutPostsInput = {
    where: commentsWhereUniqueInput
    update: XOR<commentsUpdateWithoutPostsInput, commentsUncheckedUpdateWithoutPostsInput>
    create: XOR<commentsCreateWithoutPostsInput, commentsUncheckedCreateWithoutPostsInput>
  }

  export type commentsUpdateWithWhereUniqueWithoutPostsInput = {
    where: commentsWhereUniqueInput
    data: XOR<commentsUpdateWithoutPostsInput, commentsUncheckedUpdateWithoutPostsInput>
  }

  export type commentsUpdateManyWithWhereWithoutPostsInput = {
    where: commentsScalarWhereInput
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutPostsInput>
  }

  export type commentsScalarWhereInput = {
    AND?: commentsScalarWhereInput | commentsScalarWhereInput[]
    OR?: commentsScalarWhereInput[]
    NOT?: commentsScalarWhereInput | commentsScalarWhereInput[]
    id?: BigIntFilter<"comments"> | bigint | number
    post_id?: BigIntNullableFilter<"comments"> | bigint | number | null
    user_id?: BigIntNullableFilter<"comments"> | bigint | number | null
    content?: StringFilter<"comments"> | string
    created_at?: DateTimeNullableFilter<"comments"> | Date | string | null
  }

  export type post_tagsUpsertWithWhereUniqueWithoutPostsInput = {
    where: post_tagsWhereUniqueInput
    update: XOR<post_tagsUpdateWithoutPostsInput, post_tagsUncheckedUpdateWithoutPostsInput>
    create: XOR<post_tagsCreateWithoutPostsInput, post_tagsUncheckedCreateWithoutPostsInput>
  }

  export type post_tagsUpdateWithWhereUniqueWithoutPostsInput = {
    where: post_tagsWhereUniqueInput
    data: XOR<post_tagsUpdateWithoutPostsInput, post_tagsUncheckedUpdateWithoutPostsInput>
  }

  export type post_tagsUpdateManyWithWhereWithoutPostsInput = {
    where: post_tagsScalarWhereInput
    data: XOR<post_tagsUpdateManyMutationInput, post_tagsUncheckedUpdateManyWithoutPostsInput>
  }

  export type post_tagsScalarWhereInput = {
    AND?: post_tagsScalarWhereInput | post_tagsScalarWhereInput[]
    OR?: post_tagsScalarWhereInput[]
    NOT?: post_tagsScalarWhereInput | post_tagsScalarWhereInput[]
    post_id?: BigIntFilter<"post_tags"> | bigint | number
    tag_id?: BigIntFilter<"post_tags"> | bigint | number
  }

  export type categoriesUpsertWithoutPostsInput = {
    update: XOR<categoriesUpdateWithoutPostsInput, categoriesUncheckedUpdateWithoutPostsInput>
    create: XOR<categoriesCreateWithoutPostsInput, categoriesUncheckedCreateWithoutPostsInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutPostsInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutPostsInput, categoriesUncheckedUpdateWithoutPostsInput>
  }

  export type categoriesUpdateWithoutPostsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type categoriesUncheckedUpdateWithoutPostsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUpsertWithoutPostsInput = {
    update: XOR<usersUpdateWithoutPostsInput, usersUncheckedUpdateWithoutPostsInput>
    create: XOR<usersCreateWithoutPostsInput, usersUncheckedCreateWithoutPostsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPostsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPostsInput, usersUncheckedUpdateWithoutPostsInput>
  }

  export type usersUpdateWithoutPostsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: commentsUpdateManyWithoutUsersNestedInput
    course_reviews?: course_reviewsUpdateManyWithoutUsersNestedInput
    enrollments?: enrollmentsUpdateManyWithoutUsersNestedInput
    mock_attempts?: mock_attemptsUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPostsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    full_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumuser_roleFieldUpdateOperationsInput | $Enums.user_role | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comments?: commentsUncheckedUpdateManyWithoutUsersNestedInput
    course_reviews?: course_reviewsUncheckedUpdateManyWithoutUsersNestedInput
    enrollments?: enrollmentsUncheckedUpdateManyWithoutUsersNestedInput
    mock_attempts?: mock_attemptsUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type post_templatesUpsertWithoutPostsInput = {
    update: XOR<post_templatesUpdateWithoutPostsInput, post_templatesUncheckedUpdateWithoutPostsInput>
    create: XOR<post_templatesCreateWithoutPostsInput, post_templatesUncheckedCreateWithoutPostsInput>
    where?: post_templatesWhereInput
  }

  export type post_templatesUpdateToOneWithWhereWithoutPostsInput = {
    where?: post_templatesWhereInput
    data: XOR<post_templatesUpdateWithoutPostsInput, post_templatesUncheckedUpdateWithoutPostsInput>
  }

  export type post_templatesUpdateWithoutPostsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type post_templatesUncheckedUpdateWithoutPostsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    structure?: JsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type post_tagsCreateWithoutTagsInput = {
    posts: postsCreateNestedOneWithoutPost_tagsInput
  }

  export type post_tagsUncheckedCreateWithoutTagsInput = {
    post_id: bigint | number
  }

  export type post_tagsCreateOrConnectWithoutTagsInput = {
    where: post_tagsWhereUniqueInput
    create: XOR<post_tagsCreateWithoutTagsInput, post_tagsUncheckedCreateWithoutTagsInput>
  }

  export type post_tagsCreateManyTagsInputEnvelope = {
    data: post_tagsCreateManyTagsInput | post_tagsCreateManyTagsInput[]
    skipDuplicates?: boolean
  }

  export type post_tagsUpsertWithWhereUniqueWithoutTagsInput = {
    where: post_tagsWhereUniqueInput
    update: XOR<post_tagsUpdateWithoutTagsInput, post_tagsUncheckedUpdateWithoutTagsInput>
    create: XOR<post_tagsCreateWithoutTagsInput, post_tagsUncheckedCreateWithoutTagsInput>
  }

  export type post_tagsUpdateWithWhereUniqueWithoutTagsInput = {
    where: post_tagsWhereUniqueInput
    data: XOR<post_tagsUpdateWithoutTagsInput, post_tagsUncheckedUpdateWithoutTagsInput>
  }

  export type post_tagsUpdateManyWithWhereWithoutTagsInput = {
    where: post_tagsScalarWhereInput
    data: XOR<post_tagsUpdateManyMutationInput, post_tagsUncheckedUpdateManyWithoutTagsInput>
  }

  export type commentsCreateWithoutUsersInput = {
    id?: bigint | number
    content: string
    created_at?: Date | string | null
    posts?: postsCreateNestedOneWithoutCommentsInput
  }

  export type commentsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    post_id?: bigint | number | null
    content: string
    created_at?: Date | string | null
  }

  export type commentsCreateOrConnectWithoutUsersInput = {
    where: commentsWhereUniqueInput
    create: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput>
  }

  export type commentsCreateManyUsersInputEnvelope = {
    data: commentsCreateManyUsersInput | commentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type course_reviewsCreateWithoutUsersInput = {
    id?: bigint | number
    rating?: number | null
    review?: string | null
    created_at?: Date | string | null
    courses?: coursesCreateNestedOneWithoutCourse_reviewsInput
  }

  export type course_reviewsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    course_id?: bigint | number | null
    rating?: number | null
    review?: string | null
    created_at?: Date | string | null
  }

  export type course_reviewsCreateOrConnectWithoutUsersInput = {
    where: course_reviewsWhereUniqueInput
    create: XOR<course_reviewsCreateWithoutUsersInput, course_reviewsUncheckedCreateWithoutUsersInput>
  }

  export type course_reviewsCreateManyUsersInputEnvelope = {
    data: course_reviewsCreateManyUsersInput | course_reviewsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type enrollmentsCreateWithoutUsersInput = {
    id?: bigint | number
    status?: $Enums.enrollment_status | null
    started_at?: Date | string | null
    expires_at?: Date | string | null
    courses?: coursesCreateNestedOneWithoutEnrollmentsInput
    course_plans?: course_plansCreateNestedOneWithoutEnrollmentsInput
  }

  export type enrollmentsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    course_id?: bigint | number | null
    plan_id?: bigint | number | null
    status?: $Enums.enrollment_status | null
    started_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type enrollmentsCreateOrConnectWithoutUsersInput = {
    where: enrollmentsWhereUniqueInput
    create: XOR<enrollmentsCreateWithoutUsersInput, enrollmentsUncheckedCreateWithoutUsersInput>
  }

  export type enrollmentsCreateManyUsersInputEnvelope = {
    data: enrollmentsCreateManyUsersInput | enrollmentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type mock_attemptsCreateWithoutUsersInput = {
    id?: bigint | number
    answers: JsonNullValueInput | InputJsonValue
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
    mock_tests?: mock_testsCreateNestedOneWithoutMock_attemptsInput
  }

  export type mock_attemptsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    test_id?: bigint | number | null
    answers: JsonNullValueInput | InputJsonValue
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
  }

  export type mock_attemptsCreateOrConnectWithoutUsersInput = {
    where: mock_attemptsWhereUniqueInput
    create: XOR<mock_attemptsCreateWithoutUsersInput, mock_attemptsUncheckedCreateWithoutUsersInput>
  }

  export type mock_attemptsCreateManyUsersInputEnvelope = {
    data: mock_attemptsCreateManyUsersInput | mock_attemptsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type paymentsCreateWithoutUsersInput = {
    id?: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    status?: $Enums.payment_status | null
    transaction_id?: string | null
    created_at?: Date | string | null
    courses?: coursesCreateNestedOneWithoutPaymentsInput
    mock_series?: mock_seriesCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    course_id?: bigint | number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    status?: $Enums.payment_status | null
    transaction_id?: string | null
    created_at?: Date | string | null
    mock_series_id?: bigint | number | null
  }

  export type paymentsCreateOrConnectWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput>
  }

  export type paymentsCreateManyUsersInputEnvelope = {
    data: paymentsCreateManyUsersInput | paymentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type postsCreateWithoutUsersInput = {
    id?: bigint | number
    title: string
    slug: string
    content: string
    external_url?: string | null
    thumbnail_url?: string | null
    published_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: string | null
    comments?: commentsCreateNestedManyWithoutPostsInput
    post_tags?: post_tagsCreateNestedManyWithoutPostsInput
    categories?: categoriesCreateNestedOneWithoutPostsInput
    post_templates?: post_templatesCreateNestedOneWithoutPostsInput
  }

  export type postsUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    category_id?: bigint | number | null
    title: string
    slug: string
    content: string
    external_url?: string | null
    thumbnail_url?: string | null
    published_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    template_id?: bigint | number | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: string | null
    comments?: commentsUncheckedCreateNestedManyWithoutPostsInput
    post_tags?: post_tagsUncheckedCreateNestedManyWithoutPostsInput
  }

  export type postsCreateOrConnectWithoutUsersInput = {
    where: postsWhereUniqueInput
    create: XOR<postsCreateWithoutUsersInput, postsUncheckedCreateWithoutUsersInput>
  }

  export type postsCreateManyUsersInputEnvelope = {
    data: postsCreateManyUsersInput | postsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type commentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: commentsWhereUniqueInput
    update: XOR<commentsUpdateWithoutUsersInput, commentsUncheckedUpdateWithoutUsersInput>
    create: XOR<commentsCreateWithoutUsersInput, commentsUncheckedCreateWithoutUsersInput>
  }

  export type commentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: commentsWhereUniqueInput
    data: XOR<commentsUpdateWithoutUsersInput, commentsUncheckedUpdateWithoutUsersInput>
  }

  export type commentsUpdateManyWithWhereWithoutUsersInput = {
    where: commentsScalarWhereInput
    data: XOR<commentsUpdateManyMutationInput, commentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type course_reviewsUpsertWithWhereUniqueWithoutUsersInput = {
    where: course_reviewsWhereUniqueInput
    update: XOR<course_reviewsUpdateWithoutUsersInput, course_reviewsUncheckedUpdateWithoutUsersInput>
    create: XOR<course_reviewsCreateWithoutUsersInput, course_reviewsUncheckedCreateWithoutUsersInput>
  }

  export type course_reviewsUpdateWithWhereUniqueWithoutUsersInput = {
    where: course_reviewsWhereUniqueInput
    data: XOR<course_reviewsUpdateWithoutUsersInput, course_reviewsUncheckedUpdateWithoutUsersInput>
  }

  export type course_reviewsUpdateManyWithWhereWithoutUsersInput = {
    where: course_reviewsScalarWhereInput
    data: XOR<course_reviewsUpdateManyMutationInput, course_reviewsUncheckedUpdateManyWithoutUsersInput>
  }

  export type enrollmentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: enrollmentsWhereUniqueInput
    update: XOR<enrollmentsUpdateWithoutUsersInput, enrollmentsUncheckedUpdateWithoutUsersInput>
    create: XOR<enrollmentsCreateWithoutUsersInput, enrollmentsUncheckedCreateWithoutUsersInput>
  }

  export type enrollmentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: enrollmentsWhereUniqueInput
    data: XOR<enrollmentsUpdateWithoutUsersInput, enrollmentsUncheckedUpdateWithoutUsersInput>
  }

  export type enrollmentsUpdateManyWithWhereWithoutUsersInput = {
    where: enrollmentsScalarWhereInput
    data: XOR<enrollmentsUpdateManyMutationInput, enrollmentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type mock_attemptsUpsertWithWhereUniqueWithoutUsersInput = {
    where: mock_attemptsWhereUniqueInput
    update: XOR<mock_attemptsUpdateWithoutUsersInput, mock_attemptsUncheckedUpdateWithoutUsersInput>
    create: XOR<mock_attemptsCreateWithoutUsersInput, mock_attemptsUncheckedCreateWithoutUsersInput>
  }

  export type mock_attemptsUpdateWithWhereUniqueWithoutUsersInput = {
    where: mock_attemptsWhereUniqueInput
    data: XOR<mock_attemptsUpdateWithoutUsersInput, mock_attemptsUncheckedUpdateWithoutUsersInput>
  }

  export type mock_attemptsUpdateManyWithWhereWithoutUsersInput = {
    where: mock_attemptsScalarWhereInput
    data: XOR<mock_attemptsUpdateManyMutationInput, mock_attemptsUncheckedUpdateManyWithoutUsersInput>
  }

  export type paymentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutUsersInput, paymentsUncheckedUpdateWithoutUsersInput>
    create: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutUsersInput, paymentsUncheckedUpdateWithoutUsersInput>
  }

  export type paymentsUpdateManyWithWhereWithoutUsersInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type postsUpsertWithWhereUniqueWithoutUsersInput = {
    where: postsWhereUniqueInput
    update: XOR<postsUpdateWithoutUsersInput, postsUncheckedUpdateWithoutUsersInput>
    create: XOR<postsCreateWithoutUsersInput, postsUncheckedCreateWithoutUsersInput>
  }

  export type postsUpdateWithWhereUniqueWithoutUsersInput = {
    where: postsWhereUniqueInput
    data: XOR<postsUpdateWithoutUsersInput, postsUncheckedUpdateWithoutUsersInput>
  }

  export type postsUpdateManyWithWhereWithoutUsersInput = {
    where: postsScalarWhereInput
    data: XOR<postsUpdateManyMutationInput, postsUncheckedUpdateManyWithoutUsersInput>
  }

  export type postsCreateManyCategoriesInput = {
    id?: bigint | number
    title: string
    slug: string
    content: string
    external_url?: string | null
    thumbnail_url?: string | null
    published_at?: Date | string | null
    created_by?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    template_id?: bigint | number | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: string | null
  }

  export type postsUpdateWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUpdateManyWithoutPostsNestedInput
    post_tags?: post_tagsUpdateManyWithoutPostsNestedInput
    users?: usersUpdateOneWithoutPostsNestedInput
    post_templates?: post_templatesUpdateOneWithoutPostsNestedInput
  }

  export type postsUncheckedUpdateWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUncheckedUpdateManyWithoutPostsNestedInput
    post_tags?: post_tagsUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type postsUncheckedUpdateManyWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type enrollmentsCreateManyCourse_plansInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    course_id?: bigint | number | null
    status?: $Enums.enrollment_status | null
    started_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type enrollmentsUpdateWithoutCourse_plansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: NullableEnumenrollment_statusFieldUpdateOperationsInput | $Enums.enrollment_status | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: coursesUpdateOneWithoutEnrollmentsNestedInput
    users?: usersUpdateOneWithoutEnrollmentsNestedInput
  }

  export type enrollmentsUncheckedUpdateWithoutCourse_plansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: NullableEnumenrollment_statusFieldUpdateOperationsInput | $Enums.enrollment_status | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsUncheckedUpdateManyWithoutCourse_plansInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: NullableEnumenrollment_statusFieldUpdateOperationsInput | $Enums.enrollment_status | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type course_plansCreateManyCoursesInput = {
    id?: bigint | number
    plan_type: $Enums.plan_type
    plan_name: string
    price?: Decimal | DecimalJsLike | number | string | null
    duration_days?: number | null
    created_at?: Date | string | null
  }

  export type course_reviewsCreateManyCoursesInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    rating?: number | null
    review?: string | null
    created_at?: Date | string | null
  }

  export type course_videosCreateManyCoursesInput = {
    id?: bigint | number
    title: string
    video_url: string
    position: number
    is_demo?: boolean | null
    created_at?: Date | string | null
  }

  export type enrollmentsCreateManyCoursesInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    plan_id?: bigint | number | null
    status?: $Enums.enrollment_status | null
    started_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type paymentsCreateManyCoursesInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    status?: $Enums.payment_status | null
    transaction_id?: string | null
    created_at?: Date | string | null
    mock_series_id?: bigint | number | null
  }

  export type course_plansUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plan_type?: Enumplan_typeFieldUpdateOperationsInput | $Enums.plan_type
    plan_name?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration_days?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollments?: enrollmentsUpdateManyWithoutCourse_plansNestedInput
  }

  export type course_plansUncheckedUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plan_type?: Enumplan_typeFieldUpdateOperationsInput | $Enums.plan_type
    plan_name?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration_days?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    enrollments?: enrollmentsUncheckedUpdateManyWithoutCourse_plansNestedInput
  }

  export type course_plansUncheckedUpdateManyWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    plan_type?: Enumplan_typeFieldUpdateOperationsInput | $Enums.plan_type
    plan_name?: StringFieldUpdateOperationsInput | string
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    duration_days?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type course_reviewsUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutCourse_reviewsNestedInput
  }

  export type course_reviewsUncheckedUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type course_reviewsUncheckedUpdateManyWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type course_videosUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    video_url?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type course_videosUncheckedUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    video_url?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type course_videosUncheckedUpdateManyWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    video_url?: StringFieldUpdateOperationsInput | string
    position?: IntFieldUpdateOperationsInput | number
    is_demo?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: NullableEnumenrollment_statusFieldUpdateOperationsInput | $Enums.enrollment_status | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course_plans?: course_plansUpdateOneWithoutEnrollmentsNestedInput
    users?: usersUpdateOneWithoutEnrollmentsNestedInput
  }

  export type enrollmentsUncheckedUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    plan_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: NullableEnumenrollment_statusFieldUpdateOperationsInput | $Enums.enrollment_status | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsUncheckedUpdateManyWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    plan_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: NullableEnumenrollment_statusFieldUpdateOperationsInput | $Enums.enrollment_status | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mock_series?: mock_seriesUpdateOneWithoutPaymentsNestedInput
    users?: usersUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mock_series_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type paymentsUncheckedUpdateManyWithoutCoursesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mock_series_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type mock_seriesCreateManyMock_categoriesInput = {
    id?: bigint | number
    title: string
    description?: string | null
    created_at?: Date | string | null
    price?: Decimal | DecimalJsLike | number | string | null
  }

  export type mock_seriesUpdateWithoutMock_categoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mock_tests?: mock_testsUpdateManyWithoutMock_seriesNestedInput
    payments?: paymentsUpdateManyWithoutMock_seriesNestedInput
  }

  export type mock_seriesUncheckedUpdateWithoutMock_categoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    mock_tests?: mock_testsUncheckedUpdateManyWithoutMock_seriesNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutMock_seriesNestedInput
  }

  export type mock_seriesUncheckedUpdateManyWithoutMock_categoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type mock_testsCreateManyMock_seriesInput = {
    id?: bigint | number
    title: string
    description?: string | null
    duration_minutes: number
    total_marks: number
    created_at?: Date | string | null
    is_free?: boolean | null
  }

  export type paymentsCreateManyMock_seriesInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    course_id?: bigint | number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    status?: $Enums.payment_status | null
    transaction_id?: string | null
    created_at?: Date | string | null
  }

  export type mock_testsUpdateWithoutMock_seriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration_minutes?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_free?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mock_attempts?: mock_attemptsUpdateManyWithoutMock_testsNestedInput
    mock_questions?: mock_questionsUpdateManyWithoutMock_testsNestedInput
  }

  export type mock_testsUncheckedUpdateWithoutMock_seriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration_minutes?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_free?: NullableBoolFieldUpdateOperationsInput | boolean | null
    mock_attempts?: mock_attemptsUncheckedUpdateManyWithoutMock_testsNestedInput
    mock_questions?: mock_questionsUncheckedUpdateManyWithoutMock_testsNestedInput
  }

  export type mock_testsUncheckedUpdateManyWithoutMock_seriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration_minutes?: IntFieldUpdateOperationsInput | number
    total_marks?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_free?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type paymentsUpdateWithoutMock_seriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: coursesUpdateOneWithoutPaymentsNestedInput
    users?: usersUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutMock_seriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsUncheckedUpdateManyWithoutMock_seriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mock_attemptsCreateManyMock_testsInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    answers: JsonNullValueInput | InputJsonValue
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
  }

  export type mock_questionsCreateManyMock_testsInput = {
    id?: bigint | number
    question_text: string
    question_type?: $Enums.question_type | null
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer: string
    marks?: number | null
  }

  export type mock_attemptsUpdateWithoutMock_testsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    answers?: JsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutMock_attemptsNestedInput
  }

  export type mock_attemptsUncheckedUpdateWithoutMock_testsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    answers?: JsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mock_attemptsUncheckedUpdateManyWithoutMock_testsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    answers?: JsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mock_questionsUpdateWithoutMock_testsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: NullableEnumquestion_typeFieldUpdateOperationsInput | $Enums.question_type | null
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: StringFieldUpdateOperationsInput | string
    marks?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mock_questionsUncheckedUpdateWithoutMock_testsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: NullableEnumquestion_typeFieldUpdateOperationsInput | $Enums.question_type | null
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: StringFieldUpdateOperationsInput | string
    marks?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type mock_questionsUncheckedUpdateManyWithoutMock_testsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    question_text?: StringFieldUpdateOperationsInput | string
    question_type?: NullableEnumquestion_typeFieldUpdateOperationsInput | $Enums.question_type | null
    options?: NullableJsonNullValueInput | InputJsonValue
    correct_answer?: StringFieldUpdateOperationsInput | string
    marks?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type postsCreateManyPost_templatesInput = {
    id?: bigint | number
    category_id?: bigint | number | null
    title: string
    slug: string
    content: string
    external_url?: string | null
    thumbnail_url?: string | null
    published_at?: Date | string | null
    created_by?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: string | null
  }

  export type postsUpdateWithoutPost_templatesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUpdateManyWithoutPostsNestedInput
    post_tags?: post_tagsUpdateManyWithoutPostsNestedInput
    categories?: categoriesUpdateOneWithoutPostsNestedInput
    users?: usersUpdateOneWithoutPostsNestedInput
  }

  export type postsUncheckedUpdateWithoutPost_templatesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUncheckedUpdateManyWithoutPostsNestedInput
    post_tags?: post_tagsUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type postsUncheckedUpdateManyWithoutPost_templatesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_by?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentsCreateManyPostsInput = {
    id?: bigint | number
    user_id?: bigint | number | null
    content: string
    created_at?: Date | string | null
  }

  export type post_tagsCreateManyPostsInput = {
    tag_id: bigint | number
  }

  export type commentsUpdateWithoutPostsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateWithoutPostsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type commentsUncheckedUpdateManyWithoutPostsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type post_tagsUpdateWithoutPostsInput = {
    tags?: tagsUpdateOneRequiredWithoutPost_tagsNestedInput
  }

  export type post_tagsUncheckedUpdateWithoutPostsInput = {
    tag_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type post_tagsUncheckedUpdateManyWithoutPostsInput = {
    tag_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type post_tagsCreateManyTagsInput = {
    post_id: bigint | number
  }

  export type post_tagsUpdateWithoutTagsInput = {
    posts?: postsUpdateOneRequiredWithoutPost_tagsNestedInput
  }

  export type post_tagsUncheckedUpdateWithoutTagsInput = {
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type post_tagsUncheckedUpdateManyWithoutTagsInput = {
    post_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type commentsCreateManyUsersInput = {
    id?: bigint | number
    post_id?: bigint | number | null
    content: string
    created_at?: Date | string | null
  }

  export type course_reviewsCreateManyUsersInput = {
    id?: bigint | number
    course_id?: bigint | number | null
    rating?: number | null
    review?: string | null
    created_at?: Date | string | null
  }

  export type enrollmentsCreateManyUsersInput = {
    id?: bigint | number
    course_id?: bigint | number | null
    plan_id?: bigint | number | null
    status?: $Enums.enrollment_status | null
    started_at?: Date | string | null
    expires_at?: Date | string | null
  }

  export type mock_attemptsCreateManyUsersInput = {
    id?: bigint | number
    test_id?: bigint | number | null
    answers: JsonNullValueInput | InputJsonValue
    score?: number | null
    started_at?: Date | string | null
    completed_at?: Date | string | null
  }

  export type paymentsCreateManyUsersInput = {
    id?: bigint | number
    course_id?: bigint | number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    status?: $Enums.payment_status | null
    transaction_id?: string | null
    created_at?: Date | string | null
    mock_series_id?: bigint | number | null
  }

  export type postsCreateManyUsersInput = {
    id?: bigint | number
    category_id?: bigint | number | null
    title: string
    slug: string
    content: string
    external_url?: string | null
    thumbnail_url?: string | null
    published_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    template_id?: bigint | number | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: string | null
  }

  export type commentsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    posts?: postsUpdateOneWithoutCommentsNestedInput
  }

  export type commentsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type commentsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    post_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type course_reviewsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: coursesUpdateOneWithoutCourse_reviewsNestedInput
  }

  export type course_reviewsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type course_reviewsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    review?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: NullableEnumenrollment_statusFieldUpdateOperationsInput | $Enums.enrollment_status | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: coursesUpdateOneWithoutEnrollmentsNestedInput
    course_plans?: course_plansUpdateOneWithoutEnrollmentsNestedInput
  }

  export type enrollmentsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    plan_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: NullableEnumenrollment_statusFieldUpdateOperationsInput | $Enums.enrollment_status | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type enrollmentsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    plan_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: NullableEnumenrollment_statusFieldUpdateOperationsInput | $Enums.enrollment_status | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expires_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mock_attemptsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    answers?: JsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mock_tests?: mock_testsUpdateOneWithoutMock_attemptsNestedInput
  }

  export type mock_attemptsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    answers?: JsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type mock_attemptsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    test_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    answers?: JsonNullValueInput | InputJsonValue
    score?: NullableIntFieldUpdateOperationsInput | number | null
    started_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    courses?: coursesUpdateOneWithoutPaymentsNestedInput
    mock_series?: mock_seriesUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mock_series_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type paymentsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    course_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    status?: NullableEnumpayment_statusFieldUpdateOperationsInput | $Enums.payment_status | null
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    mock_series_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type postsUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUpdateManyWithoutPostsNestedInput
    post_tags?: post_tagsUpdateManyWithoutPostsNestedInput
    categories?: categoriesUpdateOneWithoutPostsNestedInput
    post_templates?: post_templatesUpdateOneWithoutPostsNestedInput
  }

  export type postsUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: commentsUncheckedUpdateManyWithoutPostsNestedInput
    post_tags?: post_tagsUncheckedUpdateManyWithoutPostsNestedInput
  }

  export type postsUncheckedUpdateManyWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    external_url?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail_url?: NullableStringFieldUpdateOperationsInput | string | null
    published_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    template_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    content_json?: NullableJsonNullValueInput | InputJsonValue
    content_html?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}